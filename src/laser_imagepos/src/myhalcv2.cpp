#include "myhalcv2/myhalcv2.h"

namespace Myhalcv2
{
    Uint8 *u8_buffer_x3Temp1,*u8_buffer_x1Temp1,*u8_buffer_x1Temp2,*u8_buffer_x1Temp3,*u8_buffer_x1Temp4,*u8_buffer_x1Temp5,*u8_buffer_x1Temp6;
    static unsigned long mhc_next = 1;
    MyConect conect_buffer1,conect_buffer2,conect_buffer3;
    Uint8* titer_ptr;
    Uint8* titer_ptr0;
    Int32 titer_step, titer_elemSize;
    Int32 titer_err, titer_count;
    Int32 titer_minusDelta, titer_plusDelta;
    Int32 titer_minusStep, titer_plusStep;
    Int32 titer_totalStep;
    float f_gabor_11x11[121];
    Int16 i16_gabor_11x11[121];
    Uint32 CV_hist[256];
    float CV_g[256];//方差otsu,概率分布contrast
    float CV_pp[256];//各值概率otsu
    Mypaixu paixu_conect[MHC_MARK_POINTNUM];
    Int16 *CV_Sin,*CV_Cos,*CV_RoateSin,*CV_RoateCos;
    peaktrough_info *u8_peaktrough_info;
    peaktrough_Que *u8_peaktrough_Que;
    peaktrough_Que32FC *u8_peaktrough_Que32FC;
    Uint8 *u8_peaktrough_temp_1,*u8_peaktrough_temp_2;
    Uint8 *u8_ver_temp_1;
    double STC_alpha=2.25,STC_beta=1,STC_rho=0.075,STC_sigma=0.5;
    L_Point32 STC_center;
    cv::Rect STC_cxtRegion;
    cv::Mat STC_cxtPriorPro,STC_cxtPosteriorPro,STC_STModel,STC_STCModel,STC_hammingWin,STC_hammingWin_adapt;			// spatio-temporal context model
    Int32 STC_hammingWin_up_dis,STC_hammingWin_down_dis,STC_hammingWin_left_dis,STC_hammingWin_right_dis;

    Uint8 gaussian_3x3[9] =
    {
        16, 32, 16,
        32, 64, 32,
        16, 32, 16,
    };
    Uint8 gaussian_5x5[25] =
    {
        1,  4,  6,  4, 1,
        4, 16, 24, 16, 4,
        6, 24, 36, 24, 6,
        4, 16, 24, 16, 4,
        1,  4,  6,  4, 1
    };

    Uint8 gaussian_7x7[49] =
    {
    1, 2,  3,  4,  3, 2, 1,
    2, 4,  7,  7,  7, 4, 2,
    3, 7,  9, 11,  9, 7, 3,
    4, 7, 11, 16, 11, 7, 4,
    3, 7,  9, 11,  9, 7, 3,
    2, 4,  7,  7,  7, 4, 2,
    1, 2,  3,  4,  3, 2, 1
    };

    Int8 gaussian_H5[25] =
    {
    -1, -2,  0,  2,  1,
    -4, -8,  0,  8,  4,
    -6, -12, 0,  12, 6,
    -4, -8,  0,  8,  4,
    -1, -2,  0,  2,  1
    };

    Int8 gaussian_V5[25] =
    {
    -1,  -4,  -6,  -4,  -1,
    -2,  -8,  -12, -8,  -2,
     0,   0,   0,   0,   0,
     2,   8,   12,  8,   2,
     1,   4,   6,   4,   1
    };

    static const float SinTable[] =
        { 0.0000000f, 0.0174524f, 0.0348995f, 0.0523360f, 0.0697565f, 0.0871557f,
        0.1045285f, 0.1218693f, 0.1391731f, 0.1564345f, 0.1736482f, 0.1908090f,
        0.2079117f, 0.2249511f, 0.2419219f, 0.2588190f, 0.2756374f, 0.2923717f,
        0.3090170f, 0.3255682f, 0.3420201f, 0.3583679f, 0.3746066f, 0.3907311f,
        0.4067366f, 0.4226183f, 0.4383711f, 0.4539905f, 0.4694716f, 0.4848096f,
        0.5000000f, 0.5150381f, 0.5299193f, 0.5446390f, 0.5591929f, 0.5735764f,
        0.5877853f, 0.6018150f, 0.6156615f, 0.6293204f, 0.6427876f, 0.6560590f,
        0.6691306f, 0.6819984f, 0.6946584f, 0.7071068f, 0.7193398f, 0.7313537f,
        0.7431448f, 0.7547096f, 0.7660444f, 0.7771460f, 0.7880108f, 0.7986355f,
        0.8090170f, 0.8191520f, 0.8290376f, 0.8386706f, 0.8480481f, 0.8571673f,
        0.8660254f, 0.8746197f, 0.8829476f, 0.8910065f, 0.8987940f, 0.9063078f,
        0.9135455f, 0.9205049f, 0.9271839f, 0.9335804f, 0.9396926f, 0.9455186f,
        0.9510565f, 0.9563048f, 0.9612617f, 0.9659258f, 0.9702957f, 0.9743701f,
        0.9781476f, 0.9816272f, 0.9848078f, 0.9876883f, 0.9902681f, 0.9925462f,
        0.9945219f, 0.9961947f, 0.9975641f, 0.9986295f, 0.9993908f, 0.9998477f,
        1.0000000f, 0.9998477f, 0.9993908f, 0.9986295f, 0.9975641f, 0.9961947f,
        0.9945219f, 0.9925462f, 0.9902681f, 0.9876883f, 0.9848078f, 0.9816272f,
        0.9781476f, 0.9743701f, 0.9702957f, 0.9659258f, 0.9612617f, 0.9563048f,
        0.9510565f, 0.9455186f, 0.9396926f, 0.9335804f, 0.9271839f, 0.9205049f,
        0.9135455f, 0.9063078f, 0.8987940f, 0.8910065f, 0.8829476f, 0.8746197f,
        0.8660254f, 0.8571673f, 0.8480481f, 0.8386706f, 0.8290376f, 0.8191520f,
        0.8090170f, 0.7986355f, 0.7880108f, 0.7771460f, 0.7660444f, 0.7547096f,
        0.7431448f, 0.7313537f, 0.7193398f, 0.7071068f, 0.6946584f, 0.6819984f,
        0.6691306f, 0.6560590f, 0.6427876f, 0.6293204f, 0.6156615f, 0.6018150f,
        0.5877853f, 0.5735764f, 0.5591929f, 0.5446390f, 0.5299193f, 0.5150381f,
        0.5000000f, 0.4848096f, 0.4694716f, 0.4539905f, 0.4383711f, 0.4226183f,
        0.4067366f, 0.3907311f, 0.3746066f, 0.3583679f, 0.3420201f, 0.3255682f,
        0.3090170f, 0.2923717f, 0.2756374f, 0.2588190f, 0.2419219f, 0.2249511f,
        0.2079117f, 0.1908090f, 0.1736482f, 0.1564345f, 0.1391731f, 0.1218693f,
        0.1045285f, 0.0871557f, 0.0697565f, 0.0523360f, 0.0348995f, 0.0174524f,
        0.0000000f, -0.0174524f, -0.0348995f, -0.0523360f, -0.0697565f, -0.0871557f,
        -0.1045285f, -0.1218693f, -0.1391731f, -0.1564345f, -0.1736482f, -0.1908090f,
        -0.2079117f, -0.2249511f, -0.2419219f, -0.2588190f, -0.2756374f, -0.2923717f,
        -0.3090170f, -0.3255682f, -0.3420201f, -0.3583679f, -0.3746066f, -0.3907311f,
        -0.4067366f, -0.4226183f, -0.4383711f, -0.4539905f, -0.4694716f, -0.4848096f,
        -0.5000000f, -0.5150381f, -0.5299193f, -0.5446390f, -0.5591929f, -0.5735764f,
        -0.5877853f, -0.6018150f, -0.6156615f, -0.6293204f, -0.6427876f, -0.6560590f,
        -0.6691306f, -0.6819984f, -0.6946584f, -0.7071068f, -0.7193398f, -0.7313537f,
        -0.7431448f, -0.7547096f, -0.7660444f, -0.7771460f, -0.7880108f, -0.7986355f,
        -0.8090170f, -0.8191520f, -0.8290376f, -0.8386706f, -0.8480481f, -0.8571673f,
        -0.8660254f, -0.8746197f, -0.8829476f, -0.8910065f, -0.8987940f, -0.9063078f,
        -0.9135455f, -0.9205049f, -0.9271839f, -0.9335804f, -0.9396926f, -0.9455186f,
        -0.9510565f, -0.9563048f, -0.9612617f, -0.9659258f, -0.9702957f, -0.9743701f,
        -0.9781476f, -0.9816272f, -0.9848078f, -0.9876883f, -0.9902681f, -0.9925462f,
        -0.9945219f, -0.9961947f, -0.9975641f, -0.9986295f, -0.9993908f, -0.9998477f,
        -1.0000000f, -0.9998477f, -0.9993908f, -0.9986295f, -0.9975641f, -0.9961947f,
        -0.9945219f, -0.9925462f, -0.9902681f, -0.9876883f, -0.9848078f, -0.9816272f,
        -0.9781476f, -0.9743701f, -0.9702957f, -0.9659258f, -0.9612617f, -0.9563048f,
        -0.9510565f, -0.9455186f, -0.9396926f, -0.9335804f, -0.9271839f, -0.9205049f,
        -0.9135455f, -0.9063078f, -0.8987940f, -0.8910065f, -0.8829476f, -0.8746197f,
        -0.8660254f, -0.8571673f, -0.8480481f, -0.8386706f, -0.8290376f, -0.8191520f,
        -0.8090170f, -0.7986355f, -0.7880108f, -0.7771460f, -0.7660444f, -0.7547096f,
        -0.7431448f, -0.7313537f, -0.7193398f, -0.7071068f, -0.6946584f, -0.6819984f,
        -0.6691306f, -0.6560590f, -0.6427876f, -0.6293204f, -0.6156615f, -0.6018150f,
        -0.5877853f, -0.5735764f, -0.5591929f, -0.5446390f, -0.5299193f, -0.5150381f,
        -0.5000000f, -0.4848096f, -0.4694716f, -0.4539905f, -0.4383711f, -0.4226183f,
        -0.4067366f, -0.3907311f, -0.3746066f, -0.3583679f, -0.3420201f, -0.3255682f,
        -0.3090170f, -0.2923717f, -0.2756374f, -0.2588190f, -0.2419219f, -0.2249511f,
        -0.2079117f, -0.1908090f, -0.1736482f, -0.1564345f, -0.1391731f, -0.1218693f,
        -0.1045285f, -0.0871557f, -0.0697565f, -0.0523360f, -0.0348995f, -0.0174524f,
        -0.0000000f, 0.0174524f, 0.0348995f, 0.0523360f, 0.0697565f, 0.0871557f,
        0.1045285f, 0.1218693f, 0.1391731f, 0.1564345f, 0.1736482f, 0.1908090f,
        0.2079117f, 0.2249511f, 0.2419219f, 0.2588190f, 0.2756374f, 0.2923717f,
        0.3090170f, 0.3255682f, 0.3420201f, 0.3583679f, 0.3746066f, 0.3907311f,
        0.4067366f, 0.4226183f, 0.4383711f, 0.4539905f, 0.4694716f, 0.4848096f,
        0.5000000f, 0.5150381f, 0.5299193f, 0.5446390f, 0.5591929f, 0.5735764f,
        0.5877853f, 0.6018150f, 0.6156615f, 0.6293204f, 0.6427876f, 0.6560590f,
        0.6691306f, 0.6819984f, 0.6946584f, 0.7071068f, 0.7193398f, 0.7313537f,
        0.7431448f, 0.7547096f, 0.7660444f, 0.7771460f, 0.7880108f, 0.7986355f,
        0.8090170f, 0.8191520f, 0.8290376f, 0.8386706f, 0.8480481f, 0.8571673f,
        0.8660254f, 0.8746197f, 0.8829476f, 0.8910065f, 0.8987940f, 0.9063078f,
        0.9135455f, 0.9205049f, 0.9271839f, 0.9335804f, 0.9396926f, 0.9455186f,
        0.9510565f, 0.9563048f, 0.9612617f, 0.9659258f, 0.9702957f, 0.9743701f,
        0.9781476f, 0.9816272f, 0.9848078f, 0.9876883f, 0.9902681f, 0.9925462f,
        0.9945219f, 0.9961947f, 0.9975641f, 0.9986295f, 0.9993908f, 0.9998477f,
        1.0000000f
    };


    MHC_BITMAPFILEHEADER MHC_BitMapFileHeader =
    {
        0x4D42,   	 //bfType
        0x00000000,  //bfSize
        0x0000,      //bfReserved1
        0x0000,      //bfReserved2
        0x00000436   //bfOffbits
    };
    MHC_BITMAPFILEHEADERZOOM MHC_BitMapFileHeaderZoom =
    {
        0x4D420000,  //bfType
        0x00000000,  //bfSize
        0x0000,      //bfReserved1
        0x0000,      //bfReserved2
        0x00000436   //bfOffbits
    };

    MHC_BITMAPINFOHEADER MHC_BitMapInfoHeader =
    {
        0x00000028,  //biSize
        0x000001F0,  //biWidth
        0x00000174,  //biHeight
        0x0001,      //biPlanes
        0x0008,      //biBitCount
        0x00000000,  //biCompression
        0x0002C0D0,  //biSizeImage
        0x00000000,  //biXPelsPerMeter
        0x00000000,  //biYPelsPerMeter
        0x00000100,  //biClrUsed
        0x00000100  //biClrImportant
    };
    //==========================================================xjj
    MHC_BITMAPFILEHEADERZOOM MHC_BitMapFileHeader_24Zoom =
    {
        0x4D420000,  //bfType
        0x00000000,  //bfSize
        0x0000,      //bfReserved1
        0x0000,      //bfReserved2
        0x00000036   //bfOffbits
    };

    MHC_BITMAPINFOHEADER MHC_BitMapInfoHeader_24 =
    {
        0x00000028,  //biSize
        0x000001F0,  //biWidth
        0x00000174,  //biHeight
        0x0001,      //biPlanes
        0x0018,      //biBitCount
        0x00000000,  //biCompression
        0x0012FC00,  //biSizeImage
        0x00000000,  //biXPelsPerMeter
        0x00000000,  //biYPelsPerMeter
        0x00000000,  //biClrUsed
        0x00000000  //biClrImportant
    };

    void *MEM_alloc(Int32 add ,Int32 size,Int32 heep)
    {
        void *p;
        p=malloc(size);
        return p;
    }

    Int32 getConectsize()
    {
        Int32 size;
        size=sizeof(L_Point);
        return size;
    }

    Int32 getHoughsize()
    {
        Int32 size;
        size=getsizeof(CCV_16UC1)*MHC_TETARANGE*MHC_ROLENGTH;
        return size;
    }

    void VLIB_InitializeTrigLUTs(Int16 *pSin,Int16 *pCos,float ThetaMin,float ThetaMax,Int32 NumThetaPoints)
    {
        Int32 i,n=1;
        float Theta;
        float Thetaevery=(ThetaMax - ThetaMin)/(NumThetaPoints-7);
        for(i = 3; i < NumThetaPoints-3; i++)
        {
            Theta = ThetaMin + (i-3)*Thetaevery;

            pSin[i] = (Int16)(floor(256.0*sin(Theta*CV_PI/180) + 0.5));
            pCos[i] = (Int16)(floor(256.0*cos(Theta*CV_PI/180) + 0.5));
        }
        for(i = 2; i >= 0; i--)
        {
            Theta = ThetaMin - n*Thetaevery;

            pSin[i] = (Int16)(floor(256.0*sin(Theta*CV_PI/180) + 0.5));
            pCos[i] = (Int16)(floor(256.0*cos(Theta*CV_PI/180) + 0.5));
            n++;
        }
        n=1;
        for(i = NumThetaPoints-3; i < NumThetaPoints; i++)
        {
            Theta = ThetaMax + n*Thetaevery;

            pSin[i] = (Int16)(floor(256.0*sin(Theta*CV_PI/180) + 0.5));
            pCos[i] = (Int16)(floor(256.0*cos(Theta*CV_PI/180) + 0.5));
            n++;
        }
        return;
    }

    void VLIB_mat2d_sincos(Int16 *pSin,Int16 *pCos,float ThetaMin,float ThetaMax,float NumThetaPoints)
    {
        float Theta;
        Int32 i;
        for(i=0;i<MHC_ROATE;i++)
        {
            Theta=ThetaMin+i*(ThetaMax-ThetaMin)/(NumThetaPoints-1);
            pSin[i]=(Int32)(floor(256.0*sin(Theta*CV_PI/180)+0.5));
            pCos[i]=(Int32)(floor(256.0*cos(Theta*CV_PI/180)+0.5));
        }
    }

    void MyhalcvMemInit(Uint32 nHeight,Uint32 nWidth)
    {
        u8_buffer_x3Temp1=(Uint8*)MEM_alloc(DDR2HEAP,sizeof(Int32)*nHeight*nWidth,32);
        u8_buffer_x1Temp1=(Uint8*)MEM_alloc(DDR2HEAP,sizeof(Int32)*nHeight*nWidth,32);
        u8_buffer_x1Temp2=(Uint8*)MEM_alloc(DDR2HEAP,sizeof(Int32)*nHeight*nWidth,32);
        u8_buffer_x1Temp3=(Uint8*)MEM_alloc(DDR2HEAP,getConectsize()*nHeight*nWidth,32);
        u8_buffer_x1Temp4=(Uint8*)MEM_alloc(DDR2HEAP,sizeof(Int16)*nHeight*nWidth,32);
        u8_buffer_x1Temp5=(Uint8*)MEM_alloc(DDR2HEAP,sizeof(Int16)*nHeight*nWidth,32);
        u8_buffer_x1Temp6=(Uint8*)MEM_alloc(DDR2HEAP,sizeof(Int16)*nHeight*nWidth,32);


        CV_Sin = (Int16*)MEM_alloc(DDR2HEAP,sizeof(Uint16)*MHC_TETARANGE,32);
        CV_Cos = (Int16*)MEM_alloc(DDR2HEAP,sizeof(Uint16)*MHC_TETARANGE,32);

        CV_RoateSin = (Int16*)MEM_alloc(DDR2HEAP,sizeof(Uint16)*MHC_ROATE,32);
        CV_RoateCos = (Int16*)MEM_alloc(DDR2HEAP,sizeof(Uint16)*MHC_ROATE,32);

        u8_peaktrough_info = (peaktrough_info*)MEM_alloc(DDR2HEAP,sizeof(peaktrough_info)*MHC_PEAK_NUM,32);
        u8_peaktrough_Que = (peaktrough_Que*)MEM_alloc(DDR2HEAP,sizeof(peaktrough_Que)*MHC_PEAK_NUM,32);
        u8_peaktrough_Que32FC = (peaktrough_Que32FC*)u8_peaktrough_Que;
        u8_peaktrough_temp_1 = (Uint8*)MEM_alloc(DDR2HEAP,sizeof(Int32)*MHC_PEAK_NUM,32);
        u8_peaktrough_temp_2 = (Uint8*)MEM_alloc(DDR2HEAP,sizeof(Int32)*MHC_PEAK_NUM,32);

        u8_ver_temp_1 = (Uint8*)MEM_alloc(DDR2HEAP,sizeof(Vec2v)*MHC_VER_NUM,32);


        VLIB_InitializeTrigLUTs(CV_Sin,CV_Cos,-90,90,MHC_TETARANGE);
        VLIB_mat2d_sincos(CV_RoateSin,CV_RoateCos,-90,90,MHC_ROATE);

    }

    void MyhalcvMemFree()
    {
        free(u8_buffer_x3Temp1);
        free(u8_buffer_x1Temp1);
        free(u8_buffer_x1Temp2);
        free(u8_buffer_x1Temp3);
        free(u8_buffer_x1Temp4);
        free(u8_buffer_x1Temp5);
        free(u8_buffer_x1Temp6);
        free(CV_Sin);
        free(CV_Sin);
        free(CV_RoateSin);
        free(CV_RoateCos);
        free(u8_peaktrough_info);
        free(u8_peaktrough_Que);
        free(u8_peaktrough_temp_1);
        free(u8_peaktrough_temp_2);
        free(u8_ver_temp_1);
    }

    void MatToCvMat(Mat matIn,cv::Mat *matOut)
    {
        int nWidth=matIn.nWidth;
        int nHeight=matIn.nHeight;
        switch(matIn._type)
        {
        case CCV_8UC1:
            *matOut=cv::Mat(nHeight,nWidth,CV_8UC1);
            memcpy(matOut->data,matIn.data,getsizeof(matIn._type)*nHeight*nWidth);
        break;
        case CCV_8SC1:
            *matOut=cv::Mat(nHeight,nWidth,CV_8SC1);
            memcpy(matOut->data,matIn.data,getsizeof(matIn._type)*nHeight*nWidth);
        break;
        case CCV_16UC1:
            *matOut=cv::Mat(nHeight,nWidth,CV_16UC1);
            memcpy(matOut->data,matIn.data,getsizeof(matIn._type)*nHeight*nWidth);
        break;
        case CCV_16SC1:
            *matOut=cv::Mat(nHeight,nWidth,CV_16SC1);
            memcpy(matOut->data,matIn.data,getsizeof(matIn._type)*nHeight*nWidth);
        break;
        case CCV_32SC1:
            *matOut=cv::Mat(nHeight,nWidth,CV_32SC1);
            memcpy(matOut->data,matIn.data,getsizeof(matIn._type)*nHeight*nWidth);
        break;
        case CCV_32FC1:
            *matOut=cv::Mat(nHeight,nWidth,CV_32FC1);
            memcpy(matOut->data,matIn.data,getsizeof(matIn._type)*nHeight*nWidth);
        break;
        case CCV_64FC1:
            *matOut=cv::Mat(nHeight,nWidth,CV_64FC1);
            memcpy(matOut->data,matIn.data,getsizeof(matIn._type)*nHeight*nWidth);
        break;
        case CCV_8UC3:
            *matOut=cv::Mat(nHeight,nWidth,CV_8UC3);
            for(int j=0;j<nHeight;j++)
            {
                cv::Vec3b *data=matOut->ptr<cv::Vec3b>(j);
                for(int i=0;i<nWidth;i++)
                {
                    data[i][0]=matIn.ptr_Vec3b[j*nWidth+i].data1;
                    data[i][1]=matIn.ptr_Vec3b[j*nWidth+i].data2;
                    data[i][2]=matIn.ptr_Vec3b[j*nWidth+i].data3;
                }
            }
        break;
        case CCV_8SC3:
            *matOut=cv::Mat(nHeight,nWidth,CV_8SC3);
            for(int j=0;j<nHeight;j++)
            {
                cv::Vec3b *data=matOut->ptr<cv::Vec3b>(j);
                for(int i=0;i<nWidth;i++)
                {
                    data[i][0]=matIn.ptr_Vec3ib[j*nWidth+i].data1;
                    data[i][1]=matIn.ptr_Vec3ib[j*nWidth+i].data2;
                    data[i][2]=matIn.ptr_Vec3ib[j*nWidth+i].data3;
                }
            }
        break;
        case CCV_16UC3:
            *matOut=cv::Mat(nHeight,nWidth,CV_16UC3);
            for(int j=0;j<nHeight;j++)
            {
                cv::Vec3s *data=matOut->ptr<cv::Vec3s>(j);
                for(int i=0;i<nWidth;i++)
                {
                    data[i][0]=matIn.ptr_Vec3s[j*nWidth+i].data1;
                    data[i][1]=matIn.ptr_Vec3s[j*nWidth+i].data2;
                    data[i][2]=matIn.ptr_Vec3s[j*nWidth+i].data3;
                }
            }
        break;
        case CCV_16SC3:
            *matOut=cv::Mat(nHeight,nWidth,CV_16SC3);
            for(int j=0;j<nHeight;j++)
            {
                cv::Vec3w *data=matOut->ptr<cv::Vec3w>(j);
                for(int i=0;i<nWidth;i++)
                {
                    data[i][0]=matIn.ptr_Vec3w[j*nWidth+i].data1;
                    data[i][1]=matIn.ptr_Vec3w[j*nWidth+i].data2;
                    data[i][2]=matIn.ptr_Vec3w[j*nWidth+i].data3;
                }
            }
        break;
        case CCV_32SC3:
            *matOut=cv::Mat(nHeight,nWidth,CV_32SC3);
            for(int j=0;j<nHeight;j++)
            {
                cv::Vec3i *data=matOut->ptr<cv::Vec3i>(j);
                for(int i=0;i<nWidth;i++)
                {
                    data[i][0]=matIn.ptr_Vec3i[j*nWidth+i].data1;
                    data[i][1]=matIn.ptr_Vec3i[j*nWidth+i].data2;
                    data[i][2]=matIn.ptr_Vec3i[j*nWidth+i].data3;
                }
            }
        break;
        case CCV_32FC3:
            *matOut=cv::Mat(nHeight,nWidth,CV_32FC3);
            for(int j=0;j<nHeight;j++)
            {
                cv::Vec3f *data=matOut->ptr<cv::Vec3f>(j);
                for(int i=0;i<nWidth;i++)
                {
                    data[i][0]=matIn.ptr_Vec3f[j*nWidth+i].data1;
                    data[i][1]=matIn.ptr_Vec3f[j*nWidth+i].data2;
                    data[i][2]=matIn.ptr_Vec3f[j*nWidth+i].data3;
                }
            }
        break;
        case CCV_64FC3:
            *matOut=cv::Mat(nHeight,nWidth,CV_32FC3);
            for(int j=0;j<nHeight;j++)
            {
                cv::Vec3d *data=matOut->ptr<cv::Vec3d>(j);
                for(int i=0;i<nWidth;i++)
                {
                    data[i][0]=matIn.ptr_Vec3d[j*nWidth+i].data1;
                    data[i][1]=matIn.ptr_Vec3d[j*nWidth+i].data2;
                    data[i][2]=matIn.ptr_Vec3d[j*nWidth+i].data3;
                }
            }
        break;
        }
    }

    void CvMatToMat(cv::Mat matIn,Mat *matOut,void *buffer)
    {
        int nWidth=matIn.cols;
        int nHeight=matIn.rows;
        switch(matIn.type())
        {
        case CV_8UC1:
            (*matOut)=MatCreat(nHeight,nWidth,CCV_8UC1,buffer);
            memcpy(matOut->data,matIn.data,matIn.elemSize()*nHeight*nWidth);
        break;
        case CV_8SC1:
            (*matOut)=MatCreat(nHeight,nWidth,CCV_8SC1,buffer);
            memcpy(matOut->data,matIn.data,matIn.elemSize()*nHeight*nWidth);
        break;
        case CV_16UC1:
            (*matOut)=MatCreat(nHeight,nWidth,CCV_16UC1,buffer);
            memcpy(matOut->data,matIn.data,matIn.elemSize()*nHeight*nWidth);
        break;
        case CV_16SC1:
            (*matOut)=MatCreat(nHeight,nWidth,CCV_16SC1,buffer);
            memcpy(matOut->data,matIn.data,matIn.elemSize()*nHeight*nWidth);
        break;
        case CV_32SC1:
            (*matOut)=MatCreat(nHeight,nWidth,CCV_32SC1,buffer);
            memcpy(matOut->data,matIn.data,matIn.elemSize()*nHeight*nWidth);
        break;
        case CV_32FC1:
            (*matOut)=MatCreat(nHeight,nWidth,CCV_32FC1,buffer);
            memcpy(matOut->data,matIn.data,matIn.elemSize()*nHeight*nWidth);
        break;
        case CV_64FC1:
            (*matOut)=MatCreat(nHeight,nWidth,CCV_64FC1,buffer);
            memcpy(matOut->data,matIn.data,matIn.elemSize()*nHeight*nWidth);
        break;
        case CV_8UC3:
            (*matOut)=MatCreat(nHeight,nWidth,CCV_8UC3,buffer);
            for(int j=0;j<nHeight;j++)
            {
                cv::Vec3b *data=matIn.ptr<cv::Vec3b>(j);
                for(int i=0;i<nWidth;i++)
                {
                    matOut->ptr_Vec3b[j*nWidth+i].data1=data[i][0];
                    matOut->ptr_Vec3b[j*nWidth+i].data2=data[i][1];
                    matOut->ptr_Vec3b[j*nWidth+i].data3=data[i][2];
                }
            }
        break;
        case CV_8SC3:
            (*matOut)=MatCreat(nHeight,nWidth,CCV_8SC3,buffer);
            for(int j=0;j<nHeight;j++)
            {
                cv::Vec3b *data=matIn.ptr<cv::Vec3b>(j);
                for(int i=0;i<nWidth;i++)
                {
                    matOut->ptr_Vec3ib[j*nWidth+i].data1=data[i][0];
                    matOut->ptr_Vec3ib[j*nWidth+i].data2=data[i][1];
                    matOut->ptr_Vec3ib[j*nWidth+i].data3=data[i][2];
                }
            }
        break;
        case CV_16UC3:
            (*matOut)=MatCreat(nHeight,nWidth,CCV_16UC3,buffer);
            for(int j=0;j<nHeight;j++)
            {
                cv::Vec3s *data=matIn.ptr<cv::Vec3s>(j);
                for(int i=0;i<nWidth;i++)
                {
                    matOut->ptr_Vec3s[j*nWidth+i].data1=data[i][0];
                    matOut->ptr_Vec3s[j*nWidth+i].data2=data[i][1];
                    matOut->ptr_Vec3s[j*nWidth+i].data3=data[i][2];
                }
            }
        break;
        case CV_16SC3:
            (*matOut)=MatCreat(nHeight,nWidth,CCV_16SC3,buffer);
            for(int j=0;j<nHeight;j++)
            {
                cv::Vec3w *data=matIn.ptr<cv::Vec3w>(j);
                for(int i=0;i<nWidth;i++)
                {
                    matOut->ptr_Vec3w[j*nWidth+i].data1=data[i][0];
                    matOut->ptr_Vec3w[j*nWidth+i].data2=data[i][1];
                    matOut->ptr_Vec3w[j*nWidth+i].data3=data[i][2];
                }
            }
        break;
        case CV_32SC3:
            (*matOut)=MatCreat(nHeight,nWidth,CCV_32SC3,buffer);
            for(int j=0;j<nHeight;j++)
            {
                cv::Vec3i *data=matIn.ptr<cv::Vec3i>(j);
                for(int i=0;i<nWidth;i++)
                {
                    matOut->ptr_Vec3i[j*nWidth+i].data1=data[i][0];
                    matOut->ptr_Vec3i[j*nWidth+i].data2=data[i][1];
                    matOut->ptr_Vec3i[j*nWidth+i].data3=data[i][2];
                }
            }
        break;
        case CV_32FC3:
            (*matOut)=MatCreat(nHeight,nWidth,CCV_32FC3,buffer);
            for(int j=0;j<nHeight;j++)
            {
                cv::Vec3f *data=matIn.ptr<cv::Vec3f>(j);
                for(int i=0;i<nWidth;i++)
                {
                    matOut->ptr_Vec3f[j*nWidth+i].data1=data[i][0];
                    matOut->ptr_Vec3f[j*nWidth+i].data2=data[i][1];
                    matOut->ptr_Vec3f[j*nWidth+i].data3=data[i][2];
                }
            }
        break;
        case CV_64FC3:
            (*matOut)=MatCreat(nHeight,nWidth,CCV_64FC3,buffer);
            for(int j=0;j<nHeight;j++)
            {
                cv::Vec3d *data=matIn.ptr<cv::Vec3d>(j);
                for(int i=0;i<nWidth;i++)
                {
                    matOut->ptr_Vec3d[j*nWidth+i].data1=data[i][0];
                    matOut->ptr_Vec3d[j*nWidth+i].data2=data[i][1];
                    matOut->ptr_Vec3d[j*nWidth+i].data3=data[i][2];
                }
            }
        break;
        }
    }

    void IMG_pix_expand (int n, unsigned char *in_data, short *out_data)
    {
        int j;
        for (j = 0; j < n; j++)
            out_data[j] = (short) in_data[j];
    }

    void IMG_pix_sat(int n,const short *in_data,unsigned char *out_data)
    {
        int i,pixel;
        for (i = 0; i < n; i++)
        {
            pixel = in_data[i];
            if (pixel > 0xFF)
            {
                out_data[i] = 0xFF;
            }
            else if (pixel < 0x00)
            {
                out_data[i] = 0x00;
            }
            else
            {
                out_data[i] = pixel;
            }
        }
    }

    void IMG_sobel_3x3_8(Uint8 *in,Uint8 *out,short cols,short rows)
    {
      int H, O, V, i;
      int i00, i01, i02;
      int i10,      i12;
      int i20, i21, i22;
      int w = cols;

      for (i=0; i<cols*(rows-2)-2; i++) {
        i00=in[i    ]; i01=in[i    +1]; i02=in[i    +2];
        i10=in[i+  w];                  i12=in[i+  w+2];
        i20=in[i+2*w]; i21=in[i+2*w+1]; i22=in[i+2*w+2];

        H = -   i00 - 2*i01 -   i02 +
            +   i20 + 2*i21 +   i22;

        V = -   i00         +   i02
            - 2*i10         + 2*i12
            -   i20         +   i22;

        O = abs(H) + abs(V);

        if (O > 255) O = 255;

        out[i + 1] = O;
      }
    }

    void IMG_sobel_3x3_16(Uint16 * in,Uint16 * out,short cols,short rows)
    {
      int H, O, V, i;
      int i00, i01, i02;
      int i10,      i12;
      int i20, i21, i22;
      int w = cols;

      for (i=0; i<cols*(rows-2)-2; i++) {

        i00 = in[i + 0 * w]; i01 = in[i + 0 * w + 1]; i02 = in[i + 0 * w + 2];
        i10 = in[i + 1 * w];                          i12 = in[i + 1 * w + 2];
        i20 = in[i + 2 * w]; i21 = in[i + 2 * w + 1]; i22 = in[i + 2 * w + 2];

        H = -   i00  -  2*i01  -    i02  +
            +   i20  +  2*i21  +    i22;

        V = -   i00            +    i02
            - 2*i10            +  2*i12
            -   i20            +    i22;

        O = abs(H) + abs(V);

        if (O > 65535) O = 65535;

        out[i + 1] = O;
      }
    }

    void IMG_sobel_3x3_16s(short *in,short *out,short cols,short rows)
    {
      int    H,       O,       V;
      int    i;
      int    i00,     i01,     i02;
      int    i10,     i12;
      int    i20,     i21,     i22;

      for (i=0; i<(cols*(rows-2)-2); i++) {

        i00 =   in[i               ];
        i01 =   in[i            + 1];
        i02 =   in[i            + 2];
        i10 =   in[i +     cols    ];
        i12 =   in[i +     cols + 2];
        i20 =   in[i + 2 * cols    ];
        i21 =   in[i + 2 * cols + 1];
        i22 =   in[i + 2 * cols + 2];

        H   =   - i00 - 2 * i01 -  i02
                + i20 + 2 * i21 +  i22;

        V   =   - i00      +     i02
                - 2 * i10  + 2 * i12
                - i20      +     i22;

        O   =   abs(H) + abs(V);


        O   =   (O > 32767) ? 32767 : O;


        out[i + 1] = O;
      }
    }

    void IMG_sobel_5x5_16s(short *in,short *out,short cols,short rows)
    {
        int    H,       O,       V;
        int    i;

        int    i00,     i01,     i02;
        int    i03,     i04,     i10;
        int    i11,     i12,     i13;
        int    i14,     i20,     i21;
        int    i23,     i24,     i30;
        int    i31,     i32,     i33;
        int    i34,     i40,     i41;
        int    i42,     i43,     i44;


        for (i = 0; i < cols * (rows - 4) - 4; i++) {

            i00 = in[i               ];
            i01 = in[i +            1];
            i02 = in[i +            2];
            i03 = in[i +            3];
            i04 = in[i +            4];

            i10 = in[i +     cols    ];
            i11 = in[i +     cols + 1];
            i12 = in[i +     cols + 2];
            i13 = in[i +     cols + 3];
            i14 = in[i +     cols + 4];

            i20 = in[i + 2 * cols    ];
            i21 = in[i + 2 * cols + 1];
            i23 = in[i + 2 * cols + 3];
            i24 = in[i + 2 * cols + 4];

            i30 = in[i + 3 * cols    ];
            i31 = in[i + 3 * cols + 1];
            i32 = in[i + 3 * cols + 2];
            i33 = in[i + 3 * cols + 3];
            i34 = in[i + 3 * cols + 4];

            i40 = in[i + 4 * cols    ];
            i41 = in[i + 4 * cols + 1];
            i42 = in[i + 4 * cols + 2];
            i43 = in[i + 4 * cols + 3];
            i44 = in[i + 4 * cols + 4];

            H = -     i00 - 4 * i01 - 6 * i02 - 4 * i03 -     i04
                - 2 * i10 - 8 * i11 -12 * i12 - 8 * i13 - 2 * i14

                + 2 * i30 + 8 * i31 +12 * i32 + 8 * i33 + 2 * i34
                +     i40 + 4 * i41 + 6 * i42 + 4 * i43 +     i44;

            V = +     i00 + 2 * i01           - 2 * i03 -     i04
                + 4 * i10 + 8 * i11           - 8 * i13 - 4 * i14
                + 6 * i20 +12 * i21           -12 * i23 - 6 * i24
                + 4 * i30 + 8 * i31           - 8 * i33 - 4 * i34
                +     i40 + 2 * i41           - 2 * i43 -     i44;

            O = abs(H) + abs(V);


            O = (O > 32767) ? 32767 : O;

            out[i + 2] = O;
        }
    }

    void IMG_sobel_7x7_16s(short *in,short *out,short cols,short rows)
    {
      int   H,     O,      V;

      int   i;

      int   i00,   i01,    i02;
      int   i03,   i04,    i05;
      int   i06,   i10,    i11;
      int   i12,   i13,    i14;
      int   i15,   i16,    i20;
      int   i21,   i22,    i23;
      int   i24,   i25,    i26;
      int   i30,   i31,    i32;
      int   i34,   i35,    i36;
      int   i40,   i41,    i42;
      int   i43,   i44,    i45;
      int   i46,   i50,    i51;
      int   i52,   i53,    i54;
      int   i55,   i56,    i60;
      int   i61,   i62,    i63;
      int   i64,   i65,    i66;


      for (i=0; i<(cols*(rows-6)-6); i++) {

        i00 = in[i               ];
        i01 = in[i             +1];
        i02 = in[i             +2];
        i03 = in[i             +3];
        i04 = in[i             +4];
        i05 = in[i             +5];
        i06 = in[i             +6];

        i10 = in[i +     cols    ];
        i11 = in[i +     cols + 1];
        i12 = in[i +     cols + 2];
        i13 = in[i +     cols + 3];
        i14 = in[i +     cols + 4];
        i15 = in[i +     cols + 5];
        i16 = in[i +     cols + 6];

        i20 = in[i + 2 * cols    ];
        i21 = in[i + 2 * cols + 1];
        i22 = in[i + 2 * cols + 2];
        i23 = in[i + 2 * cols + 3];
        i24 = in[i + 2 * cols + 4];
        i25 = in[i + 2 * cols + 5];
        i26 = in[i + 2 * cols + 6];

        i30 = in[i + 3 * cols    ];
        i31 = in[i + 3 * cols + 1];
        i32 = in[i + 3 * cols + 2];
        i34 = in[i + 3 * cols + 4];
        i35 = in[i + 3 * cols + 5];
        i36 = in[i + 3 * cols + 6];

        i40 = in[i + 4 * cols    ];
        i41 = in[i + 4 * cols + 1];
        i42 = in[i + 4 * cols + 2];
        i43 = in[i + 4 * cols + 3];
        i44 = in[i + 4 * cols + 4];
        i45 = in[i + 4 * cols + 5];
        i46 = in[i + 4 * cols + 6];

        i50 = in[i + 5 * cols    ];
        i51 = in[i + 5 * cols + 1];
        i52 = in[i + 5 * cols + 2];
        i53 = in[i + 5 * cols + 3];
        i54 = in[i + 5 * cols + 4];
        i55 = in[i + 5 * cols + 5];
        i56 = in[i + 5 * cols + 6];

        i60 = in[i + 6 * cols    ];
        i61 = in[i + 6 * cols + 1];
        i62 = in[i + 6 * cols + 2];
        i63 = in[i + 6 * cols + 3];
        i64 = in[i + 6 * cols + 4];
        i65 = in[i + 6 * cols + 5];
        i66 = in[i + 6 * cols + 6];


        H = -     i00 -  i01 - i02 - 2 * i03 - i04 - i05 - i06
            -     i10 -  i11 - i12 - 2 * i13 - i14 - i15 - i16
            -     i20 -  i21 - i22 - 2 * i23 - i24 - i25 - i26

            +     i40 +  i41 + i42 + 2 * i43 + i44 + i45 + i46
            +     i50 +  i51 + i52 + 2 * i53 + i54 + i55 + i56
            +     i60 +  i61 + i62 + 2 * i63 + i64 + i65 + i66;

        V = -     i00 -     i01 -     i02    +      i04 +     i05 +   i06
            -     i10 -     i11 -     i12    +      i14 +     i15 +   i16
            -     i20 -     i21 -     i22    +      i24 +     i25 +   i26
            - 2 * i30 - 2 * i31 - 2 * i32    +  2 * i34 + 2 * i35 + 2*i36
            -     i40 -     i41 -     i42    +      i44 +     i45 +   i46
            -     i50 -     i51 -     i52    +      i54 +     i55 +   i56
            -     i60 -     i61 -     i62    +      i64 +     i65 +   i66;

        O = abs(H) + abs(V);

        O = (O > 32767) ? 32767 : O;

        out[i + 3] = O;
      }
    }

    void IMG_thr_le2min_8(unsigned char *in_data, unsigned char *out_data,short cols, short rows,unsigned char threshold)
    {
      int i, pixels = rows * cols;

      for (i=0; i<pixels; i++) {
        out_data[i] = in_data[i] <= threshold ? 0 : in_data[i];
      }
    }

    void IMG_thr_le2min_16(unsigned short *in_data, unsigned short *out_data,short cols, short rows,unsigned char threshold)
    {
      int i, pixels = rows * cols;

      for (i=0; i<pixels; i++) {
        out_data[i] = in_data[i] <= threshold ? 0 : in_data[i];
      }
    }

    void IMG_thr_gt2max_8(unsigned char *in_data, unsigned char *out_data,short cols, short rows,unsigned char threshold)
    {
      int i, pixels = rows * cols;
      for (i=0; i<pixels; i++) {
        out_data[i] = in_data[i] > threshold ? 255 : in_data[i];
      }
    }

    void IMG_thr_gt2max_16(unsigned short *in_data,unsigned short *out_data,short cols,short rows, unsigned short threshold)
    {
      int i, pixels = rows * cols;
      for (i=0; i<pixels; i++) {
        out_data[i] = in_data[i] > threshold ? 0xffff : in_data[i];
      }
    }

    int IMG_perimeter_8(unsigned char *in,int cols,unsigned char *out)
    {
        int i, count = 0;
        unsigned char pix_lft, pix_rgt, pix_top, pix_bot, pix_mid;

        for(i = 0; i < cols; i++)
        {
            pix_lft = in[i - 1];
            pix_mid = in[i + 0];
            pix_rgt = in[i + 1];

            pix_top = in[i - cols];
            pix_bot = in[i + cols];

            if (((pix_lft == 0) || (pix_rgt == 0) ||
                 (pix_top == 0) || (pix_bot == 0)) && (pix_mid > 0))
            {
                out[i] = pix_mid;
                count++;
            } else
            {
                out[i] = 0;
            }
        }
        if (out[cols-1]) count--;
        if (out[0])      count--;
        out[0] = out[cols-1] = 0;

        return count;
    }

    void IMG_and_8 ( Uint8 * restrict imgR1,Uint8 * restrict imgR2,Int8 * restrict imgW,Int32 count)
    {
        Int32 i;
        for (i = 0; i < count; i ++)
        {
            if(imgR1[i]!=0&&imgR2[i]!=0)
                imgW[i]=1;
            else
                imgW[i]=0;
        }
    }

    void IMG_and_16 ( Uint16 * restrict imgR1,Uint16 * restrict imgR2,Int16 * restrict imgW,Int32 count)
    {
        Int32 i;
        for (i = 0; i < count ; i ++)
        {
            if(imgR1[i]!=0&&imgR2[i]!=0)
                imgW[i]=1;
            else
                imgW[i]=0;
        }
    }

    void IMG_or_8 ( Uint8 * restrict imgR1,Uint8 * restrict imgR2,Int8 * restrict imgW,Int32 count)
    {
        Int32 i;
        for (i = 0; i < count; i ++)
        {
            if(imgR1[i]!=0||imgR2[i]!=0)
                imgW[i]=1;
            else
                imgW[i]=0;
        }
    }

    void IMG_or_16 ( Uint16 * restrict imgR1,Uint16 * restrict imgR2,Int16 * restrict imgW,Int32 count)
    {
        Int32 i;
        for (i = 0; i < count; i ++)
        {
            if(imgR1[i]!=0||imgR2[i]!=0)
                imgW[i]=1;
            else
                imgW[i]=0;
        }
    }

    void IMG_not_8 ( Uint8 * restrict imgR,Uint8  * restrict imgW,Int32 count)
    {
        Int32 i;
        for (i = 0; i < count; i ++)
        {
            if(imgR[i]!=0)
                imgW[i]=0;
            else
                imgW[i]=1;
        }
    }

    void IMG_not_16 (Uint16 * restrict imgR,Uint16 * restrict imgW,Int32 count)
    {
        Int32 i;
        for (i = 0; i < count; i ++)
        {
            if(imgR[i]!=0)
                imgW[i]=1;
            else
                imgW[i]=0;
        }
    }


    void IMG_add_8 ( Int8 * restrict imgR1,Int8 * restrict imgR2,Int8 * restrict imgW,Int32 count)
    {
        Int32 i;
        for (i = 0; i < count; i ++)
        {
            imgW[i]=imgR1[i]+imgR2[i];
        }
    }


    void IMG_add_16s ( Int16 * restrict imgR1,Int16 * restrict imgR2,Int16 * restrict imgW,Int32 count)
    {
        Int32 i;
        for (i = 0; i < count ; i ++)
        {
            imgW[i]=imgR1[i]+imgR2[i];
        }
    }

    void IMG_sub_8 ( Int8 * restrict imgR1,Int8 * restrict imgR2,Int8 * restrict imgW,Int32 count)
    {
        Int32 i;
        for (i = 0; i < count; i ++ )
        {
            imgW[i]=imgR1[i]-imgR2[i];
        }
    }

    void IMG_sub_16s ( Int16 * restrict imgR1,Int16 * restrict imgR2,Int16 * restrict imgW,Int32 count)
    {
        Int32 i;
        for (i = 0; i < count; i ++ )
        {
            imgW[i]=imgR1[i]-imgR2[i];
        }
    }

    void IMG_mul_8 ( Int8 * restrict imgR1,Int8 * restrict imgR2,Int16 * restrict imgW,Int32 count)
    {
        Int32 i;
        for (i = 0; i < count; i ++)
        {
            imgW[i]=imgR1[i]*imgR2[i];
        }
    }


    void IMG_mul_16s ( Int16 * restrict imgR1,Int16 * restrict imgR2,Int32 * restrict imgW,Int32 count)
    {
        Int32 i;
        for (i = 0; i < count; i ++)
        {
            imgW[i]=imgR1[i]*imgR2[i];
        }
    }


    void IMG_addS_8 ( Int8 * restrict imgR,Int8 * restrict imgW,Int8 constData,Int32 count)
    {
        Int32 i;
        for (i = 0; i < count; i ++)
        {
            imgW[i]=imgR[i]+constData;
        }
    }


    void IMG_addS_16s ( Int16 * restrict imgR,Int16 * restrict imgW,Int16 constData,Int32 count)
    {
        Int32 i;
        for (i = 0; i < count; i ++)
        {
            imgW[i]=imgR[i]+constData;
        }
    }


    void IMG_subS_8 ( Int8 * restrict imgR,Int8 * restrict imgW,Int8 constData,Int32 count)
    {
        Int32 i;
        for (i = 0; i < count; i ++ )
        {
            imgW[i]=imgR[i]-constData;
        }
    }


    void IMG_subS_16s ( Int16 * restrict imgR,Int16 * restrict imgW,Int16 constData,Int32 count)
    {
        Int32 i;
        for (i = 0; i < count; i ++ )
        {
            imgW[i]=imgR[i]-constData;
        }
    }

    void IMG_invS_8 ( Int8 * restrict imgR,Int8 * restrict imgW,Int32 count)
    {
        Int32 i;
        for (i = 0; i < count; i ++ )
        {
            imgW[i]=0xff-imgR[i];
        }
    }

    void IMG_invS_16s ( Int16 * restrict imgR,Int16 * restrict imgW,Int32 count)
    {
        Int32 i;
        for (i = 0; i < count; i ++ )
        {
            imgW[i]=0xffff-imgR[i];
        }
    }

    void IMG_mulS_8 (Uint8* restrict imgR,Int16 * restrict imgW,Int8 constData,Int32 count)
    {
        Int32 i;
        for (i = 0; i < count; i ++ )
        {
            imgW[i]=imgR[i]*constData;
        }
    }

    void IMG_mulS_16s ( Int16 * restrict imgR,Int32 * restrict imgW,Int16 constData,Int32 count)
    {
        Int32 i;
        for (i = 0; i < count; i ++ )
        {
            imgW[i]=imgR[i]*constData;
        }
    }

    void DSP_fltoq15(float x[], short r[], short nx)
    {
        int i, a;

        for(i = 0; i < nx; i++)
        {
            a = 32768 * x[i];

            if (a>32767)  a =  32767;
            if (a<-32768) a = -32768;

            r[i] = (short) a;
        }
    }

    Int8 My_float_to_q15(float *pIn,Int16 num,Int16 *pOut)
    {
        DSP_fltoq15(pIn,pOut,num);
        return 0;
    }

    void DSP_q15tofl(const short *restrict x, float *r, int nx )
    {
        int i;

        for (i=0;i<nx;i++)
            r[i]=(float)x[i]/32768;
    }

    Int8 My_q15_to_float(Int16 *pIn,Int16 num,float *pOut)
    {
        DSP_q15tofl(pIn,pOut,num);
        return 0;
    }

    Int32 trans_x(Int32 inX,Int32 inY,Int32 Range,Int32 Ox,Int32 Oy)
    {
        return((((inX-Ox)*CV_RoateCos[Range]-(inY-Oy)*CV_RoateSin[Range])>>8)+Ox);
    }

    Int32 trans_y(Int32 inX,Int32 inY,Int32 Range,Int32 Ox,Int32 Oy)
    {
        return((((inX-Ox)*CV_RoateSin[Range]+(inY-Oy)*CV_RoateCos[Range])>>8)+Oy);
    }

    void ICV_HLINE( Uint8 *ptr, Int32 xl, Int32 xr, Int32 color, Int32 pix_size )
    {
        Uint8* hline_ptr = (Uint8*)(ptr) + (xl)*(pix_size);
        Uint8* hline_max_ptr = (Uint8*)(ptr) + (xr)*(pix_size);

        for( ; hline_ptr <= hline_max_ptr; hline_ptr += (pix_size))
        {
            hline_ptr[0] = (Uint8)color;
        }
    }

    void ICV_HLINE3COL( Uint8 *ptr, Int32 xl, Int32 xr, Int32 color1,Int32 color2,Int32 color3, Int32 pix_size )
    {
        Uint8* hline_ptr = (Uint8*)(ptr) + (xl)*(pix_size);
        Uint8* hline_max_ptr = (Uint8*)(ptr) + (xr)*(pix_size);

        for( ; hline_ptr <= hline_max_ptr; hline_ptr += (pix_size))
        {
            hline_ptr[0] = (Uint8)color1;
            hline_ptr[1] = (Uint8)color2;
            hline_ptr[2] = (Uint8)color3;                                                \
        }
    }

    void ICV_PUT_POINT (Uint8 *ptr,Int32 x,Int32 color,Int32 pix_size)
    {
        *(ptr+(x)*pix_size) = (Uint8)color;
    }

    void ICV_PUT_POINT3COL (Uint8 *ptr,Int32 x,Int32 color1,Int32 color2,Int32 color3,Int32 pix_size)
    {
        *(ptr+(x)*pix_size) = (Uint8)color1;
        *(ptr+(x)*pix_size+1) = (Uint8)color2;
        *(ptr+(x)*pix_size+2) = (Uint8)color3;
    }

    Int32 func_nc8(Int32 *b)
    {
        Int32 n_odd[4] = { 1, 3, 5, 7 };
        Int32 i, j, sum, d[10];

        for (i = 0; i <= 9; i++) {
            j = i;
            if (i == 9) j = 1;
            if (abs(*(b + j)) == 1)
            {
                d[i] = 1;
            }
            else
            {
                d[i] = 0;
            }
        }
        sum = 0;
        for (i = 0; i < 4; i++)
        {
            j = n_odd[i];
            sum = sum + d[j] - d[j] * d[j + 1] * d[j + 2];
        }
        return (sum);
    }

    void Circle( Mat* img, L_Point32 center, Int32 radius, Int32 color, Int32 fill)//实心圆
    {
        Int32 nnWidth=img->nWidth;
        Int32 nnHeight=img->nHeight;
        Int32 step = getsizeof(img->_type)*nnWidth;
        Int32 pix_size = getsizeof(img->_type);
        Uint8* ptr = img->data;
        Int32 err = 0, dx = radius, dy = 0, plus = 1, minus = (radius << 1) - 1;
        Int32 inside = center.x >= radius && center.x < nnWidth - radius &&
            center.y >= radius && center.y < nnHeight - radius;

        while( dx >= dy )
        {
            Int32 mask;
            Int32 y11 = center.y - dy, y12 = center.y + dy, y21 = center.y - dx, y22 = center.y + dx;
            Int32 x11 = center.x - dx, x12 = center.x + dx, x21 = center.x - dy, x22 = center.x + dy;

            if( inside )
            {
                Uint8 *tptr0 = ptr + y11 * step;
                Uint8 *tptr1 = ptr + y12 * step;

                if( !fill )
                {
                    ICV_PUT_POINT( tptr0, x11 ,color ,pix_size);
                    ICV_PUT_POINT( tptr1, x11 ,color ,pix_size);
                    ICV_PUT_POINT( tptr0, x12 ,color ,pix_size);
                    ICV_PUT_POINT( tptr1, x12 ,color ,pix_size);
                }
                else
                {
                    ICV_HLINE( tptr0, x11, x12, color, pix_size );
                    ICV_HLINE( tptr1, x11, x12, color, pix_size );
                }

                tptr0 = ptr + y21 * step;
                tptr1 = ptr + y22 * step;

                if( !fill )
                {
                    ICV_PUT_POINT( tptr0, x21 ,color ,pix_size);
                    ICV_PUT_POINT( tptr1, x21 ,color ,pix_size);
                    ICV_PUT_POINT( tptr0, x22 ,color ,pix_size);
                    ICV_PUT_POINT( tptr1, x22 ,color ,pix_size);
                }
                else
                {
                    ICV_HLINE( tptr0, x21, x22, color, pix_size );
                    ICV_HLINE( tptr1, x21, x22, color, pix_size );
                }
            }
            else if( x11 < nnWidth && x12 >= 0 && y21 < nnHeight && y22 >= 0 )
            {
                if( fill )
                {
                    x11 = MAX( x11, 0 );
                    x12 = MIN( x12, nnWidth - 1 );
                }

                if( (unsigned)y11 < (unsigned)nnHeight )
                {
                    Uint8 *tptr = ptr + y11 * step;

                    if( !fill )
                    {
                        if( x11 >= 0 )
                            ICV_PUT_POINT( tptr, x11 ,color ,pix_size);
                        if( x12 < nnWidth )
                            ICV_PUT_POINT( tptr, x12 ,color ,pix_size);
                    }
                    else
                        ICV_HLINE( tptr, x11, x12, color, pix_size );
                }

                if( (unsigned)y12 < (unsigned)nnHeight )
                {
                    Uint8 *tptr = ptr + y12 * step;

                    if( !fill )
                    {
                        if( x11 >= 0 )
                            ICV_PUT_POINT( tptr, x11 ,color ,pix_size);
                        if( x12 < nnWidth )
                            ICV_PUT_POINT( tptr, x12 ,color ,pix_size);
                    }
                    else
                        ICV_HLINE( tptr, x11, x12, color, pix_size );
                }

                if( x21 < nnWidth && x22 >= 0 )
                {
                    if( fill )
                    {
                        x21 = MAX( x21, 0 );
                        x22 = MIN( x22, nnWidth - 1 );
                    }

                    if( (unsigned)y21 < (unsigned)nnHeight )
                    {
                        Uint8 *tptr = ptr + y21 * step;

                        if( !fill )
                        {
                            if( x21 >= 0 )
                                ICV_PUT_POINT( tptr, x21 ,color ,pix_size);
                            if( x22 < nnWidth )
                                ICV_PUT_POINT( tptr, x22 ,color ,pix_size);
                        }
                        else
                            ICV_HLINE( tptr, x21, x22, color, pix_size );
                    }

                    if( (unsigned)y22 < (unsigned)nnHeight )
                    {
                        Uint8 *tptr = ptr + y22 * step;

                        if( !fill )
                        {
                            if( x21 >= 0 )
                                ICV_PUT_POINT( tptr, x21 ,color ,pix_size);
                            if( x22 < nnWidth )
                                ICV_PUT_POINT( tptr, x22 ,color ,pix_size);
                        }
                        else
                            ICV_HLINE( tptr, x21, x22, color, pix_size );
                    }
                }
            }
            dy++;
            err += plus;
            plus += 2;

            mask = (err <= 0) - 1;

            err -= minus & mask;
            dx += mask;
            minus -= mask & 2;
        }
    }

    void CirclePoint( Mat* img, L_Point32 center, Int32 radius, Int32 fill,L_Point *buffer,Int32 *buffernum,Uint8 noclear)//实心圆
    {
        Uint32 nnWidth=img->nWidth;
        Uint32 nnHeight=img->nHeight;
        Int32 step = getsizeof(img->_type)*nnWidth;
        Int32 pix_size = getsizeof(img->_type);
        Int32 err = 0, dx = radius, dy = 0, plus = 1, minus = (radius << 1) - 1;
        Int32 inside = center.x >= radius && center.x < nnWidth - radius &&
            center.y >= radius && center.y < nnHeight - radius;
        Int32 nbuffernum=0;
        Int32 di;

        if(noclear==1)
            nbuffernum=*buffernum;

        while( dx >= dy )
        {
            Int32 mask;
            Int32 y11 = center.y - dy, y12 = center.y + dy, y21 = center.y - dx, y22 = center.y + dx;
            Int32 x11 = center.x - dx, x12 = center.x + dx, x21 = center.x - dy, x22 = center.x + dy;

            if( inside )
            {
                if( !fill )
                {
                    buffer[nbuffernum].x=(Uint16)x11;
                    buffer[nbuffernum++].y=(Uint16)y11;
                    buffer[nbuffernum].x=(Uint16)x11;
                    buffer[nbuffernum++].y=(Uint16)y12;
                    buffer[nbuffernum].x=(Uint16)x11;
                    buffer[nbuffernum++].y=(Uint16)y12;
                    buffer[nbuffernum].x=(Uint16)x12;
                    buffer[nbuffernum++].y=(Uint16)y12;
                }
                else
                {
                    for(di=x11;di<=x12;di++)
                    {
                        buffer[nbuffernum].x=(Uint16)di;
                        buffer[nbuffernum++].y=(Uint16)y11;
                    }
                    for(di=x11;di<=x12;di++)
                    {
                        buffer[nbuffernum].x=(Uint16)di;
                        buffer[nbuffernum++].y=(Uint16)y12;
                    }
                }
                if( !fill )
                {
                    buffer[nbuffernum].x=(Uint16)x21;
                    buffer[nbuffernum++].y=(Uint16)y21;
                    buffer[nbuffernum].x=(Uint16)x21;
                    buffer[nbuffernum++].y=(Uint16)y22;
                    buffer[nbuffernum].x=(Uint16)x22;
                    buffer[nbuffernum++].y=(Uint16)y21;
                    buffer[nbuffernum].x=(Uint16)x22;
                    buffer[nbuffernum++].y=(Uint16)y22;
                }
                else
                {
                    for(di=x21;di<=x22;di++)
                    {
                        buffer[nbuffernum].x=(Uint16)di;
                        buffer[nbuffernum++].y=(Uint16)y21;
                    }
                    for(di=x21;di<=x22;di++)
                    {
                        buffer[nbuffernum].x=(Uint16)di;
                        buffer[nbuffernum++].y=(Uint16)y22;
                    }
                }
            }
            else if( x11 < nnWidth && x12 >= 0 && y21 < nnHeight && y22 >= 0 )
            {
                if( fill )
                {
                    x11 = MAX( x11, 0 );
                    x12 = MIN( x12, nnWidth - 1 );
                }

                if( (unsigned)y11 < (unsigned)nnHeight )
                {
                    if( !fill )
                    {
                        if( x11 >= 0 )
                        {
                            buffer[nbuffernum].x=(Uint16)x11;
                            buffer[nbuffernum++].y=(Uint16)y11;
                        }
                        if( x12 < nnWidth )
                        {
                            buffer[nbuffernum].x=(Uint16)x12;
                            buffer[nbuffernum++].y=(Uint16)y11;
                        }
                    }
                    else
                    {
                        for(di=x11;di<=x12;di++)
                        {
                            buffer[nbuffernum].x=(Uint16)di;
                            buffer[nbuffernum++].y=(Uint16)y11;
                        }
                    }
                }

                if( (unsigned)y12 < (unsigned)nnHeight )
                {
                    if( !fill )
                    {
                        if( x11 >= 0 )
                        {
                            buffer[nbuffernum].x=(Uint16)x11;
                            buffer[nbuffernum++].y=(Uint16)y12;
                        }
                        if( x12 < nnWidth )
                        {
                            buffer[nbuffernum].x=(Uint16)x12;
                            buffer[nbuffernum++].y=(Uint16)y12;
                        }
                    }
                    else
                    {
                        for(di=x11;di<=x12;di++)
                        {
                            buffer[nbuffernum].x=(Uint16)di;
                            buffer[nbuffernum++].y=(Uint16)y12;
                        }
                    }
                }

                if( x21 < nnWidth && x22 >= 0 )
                {
                    if( fill )
                    {
                        x21 = MAX( x21, 0 );
                        x22 = MIN( x22, nnWidth - 1 );
                    }

                    if( (unsigned)y21 < (unsigned)nnHeight )
                    {
                        if( !fill )
                        {
                            if( x21 >= 0 )
                            {
                                buffer[nbuffernum].x=(Uint16)x21;
                                buffer[nbuffernum++].y=(Uint16)y21;
                            }
                            if( x22 < nnWidth )
                            {
                                buffer[nbuffernum].x=(Uint16)x22;
                                buffer[nbuffernum++].y=(Uint16)y21;
                            }
                        }
                        else
                        {
                            for(di=x21;di<=x22;di++)
                            {
                                buffer[nbuffernum].x=(Uint16)di;
                                buffer[nbuffernum++].y=(Uint16)y21;
                            }
                        }
                    }

                    if( (unsigned)y22 < (unsigned)nnHeight )
                    {
                        if( !fill )
                        {
                            if( x21 >= 0 )
                            {
                                buffer[nbuffernum].x=(Uint16)x21;
                                buffer[nbuffernum++].y=(Uint16)y22;
                            }
                            if( x22 < nnWidth )
                            {
                                buffer[nbuffernum].x=(Uint16)x22;
                                buffer[nbuffernum++].y=(Uint16)y22;
                            }
                        }
                        else
                        {
                            for(di=x21;di<=x22;di++)
                            {
                                buffer[nbuffernum].x=(Uint16)di;
                                buffer[nbuffernum++].y=(Uint16)y22;
                            }
                        }
                    }
                }
            }
            dy++;
            err += plus;
            plus += 2;

            mask = (err <= 0) - 1;

            err -= minus & mask;
            dx += mask;
            minus -= mask & 2;
        }
        *buffernum=nbuffernum;
    }

    void Circle3col( Mat* img, L_Point32 center, Int32 radius, Int32 color1,Int32 color2,Int32 color3, Int32 fill)//实心圆
    {
        Uint32 nnWidth=img->nWidth;
        Uint32 nnHeight=img->nHeight;
        Int32 step = getsizeof(img->_type)*nnWidth;
        Int32 pix_size = getsizeof(img->_type);
        Uint8* ptr = img->data;
        Int32 err = 0, dx = radius, dy = 0, plus = 1, minus = (radius << 1) - 1;
        Int32 inside = center.x >= radius && center.x < nnWidth - radius &&
            center.y >= radius && center.y < nnHeight - radius;

        while( dx >= dy )
        {
            Int32 mask;
            Int32 y11 = center.y - dy, y12 = center.y + dy, y21 = center.y - dx, y22 = center.y + dx;
            Int32 x11 = center.x - dx, x12 = center.x + dx, x21 = center.x - dy, x22 = center.x + dy;

            if( inside )
            {
                Uint8 *tptr0 = ptr + y11 * step;
                Uint8 *tptr1 = ptr + y12 * step;

                if( !fill )
                {
                    ICV_PUT_POINT3COL( tptr0, x11 ,color1,color2,color3 ,pix_size);
                    ICV_PUT_POINT3COL( tptr1, x11 ,color1,color2,color3 ,pix_size);
                    ICV_PUT_POINT3COL( tptr0, x12 ,color1,color2,color3 ,pix_size);
                    ICV_PUT_POINT3COL( tptr1, x12 ,color1,color2,color3 ,pix_size);
                }
                else
                {
                    ICV_HLINE3COL( tptr0, x11, x12, color1,color2,color3, pix_size );
                    ICV_HLINE3COL( tptr1, x11, x12, color1,color2,color3, pix_size );
                }

                tptr0 = ptr + y21 * step;
                tptr1 = ptr + y22 * step;

                if( !fill )
                {
                    ICV_PUT_POINT3COL( tptr0, x21 ,color1,color2,color3 ,pix_size);
                    ICV_PUT_POINT3COL( tptr1, x21 ,color1,color2,color3 ,pix_size);
                    ICV_PUT_POINT3COL( tptr0, x22 ,color1,color2,color3 ,pix_size);
                    ICV_PUT_POINT3COL( tptr1, x22 ,color1,color2,color3 ,pix_size);
                }
                else
                {
                    ICV_HLINE3COL( tptr0, x21, x22, color1,color2,color3, pix_size );
                    ICV_HLINE3COL( tptr1, x21, x22, color1,color2,color3, pix_size );
                }
            }
            else if( x11 < nnWidth && x12 >= 0 && y21 < nnHeight && y22 >= 0 )
            {
                if( fill )
                {
                    x11 = MAX( x11, 0 );
                    x12 = MIN( x12, nnWidth - 1 );
                }

                if( (unsigned)y11 < (unsigned)nnHeight )
                {
                    Uint8 *tptr = ptr + y11 * step;

                    if( !fill )
                    {
                        if( x11 >= 0 )
                            ICV_PUT_POINT3COL( tptr, x11 ,color1,color2,color3 ,pix_size);
                        if( x12 < nnWidth )
                            ICV_PUT_POINT3COL( tptr, x12 ,color1,color2,color3 ,pix_size);
                    }
                    else
                        ICV_HLINE3COL( tptr, x11, x12, color1,color2,color3, pix_size );
                }

                if( (unsigned)y12 < (unsigned)nnHeight )
                {
                    Uint8 *tptr = ptr + y12 * step;

                    if( !fill )
                    {
                        if( x11 >= 0 )
                            ICV_PUT_POINT3COL( tptr, x11 ,color1,color2,color3 ,pix_size);
                        if( x12 < nnWidth )
                            ICV_PUT_POINT3COL( tptr, x12 ,color1,color2,color3 ,pix_size);
                    }
                    else
                        ICV_HLINE3COL( tptr, x11, x12, color1,color2,color3, pix_size );
                }

                if( x21 < nnWidth && x22 >= 0 )
                {
                    if( fill )
                    {
                        x21 = MAX( x21, 0 );
                        x22 = MIN( x22, nnWidth - 1 );
                    }

                    if( (unsigned)y21 < (unsigned)nnHeight )
                    {
                        Uint8 *tptr = ptr + y21 * step;

                        if( !fill )
                        {
                            if( x21 >= 0 )
                                ICV_PUT_POINT3COL( tptr, x21 ,color1,color2,color3 ,pix_size);
                            if( x22 < nnWidth )
                                ICV_PUT_POINT3COL( tptr, x22 ,color1,color2,color3 ,pix_size);
                        }
                        else
                            ICV_HLINE3COL( tptr, x21, x22, color1,color2,color3, pix_size );
                    }

                    if( (unsigned)y22 < (unsigned)nnHeight )
                    {
                        Uint8 *tptr = ptr + y22 * step;

                        if( !fill )
                        {
                            if( x21 >= 0 )
                                ICV_PUT_POINT3COL( tptr, x21 ,color1,color2,color3 ,pix_size);
                            if( x22 < nnWidth )
                                ICV_PUT_POINT3COL( tptr, x22 ,color1,color2,color3 ,pix_size);
                        }
                        else
                            ICV_HLINE3COL( tptr, x21, x22, color1,color2,color3, pix_size );
                    }
                }
            }
            dy++;
            err += plus;
            plus += 2;

            mask = (err <= 0) - 1;

            err -= minus & mask;
            dx += mask;
            minus -= mask & 2;
        }
    }

    Int8 MyCircle(Mat *matIn_Out,L_Point32 center, Int32 radius,Int32 color, circletype connectivity)
    {
        switch(matIn_Out->_type)
        {
            case CCV_8UC1:
                Circle( matIn_Out, center, radius, color, connectivity<0 );
            break;
            case CCV_8UC3:
                Circle3col( matIn_Out, center, radius, color,color,color, connectivity<0 );
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 MyCircle3col(Mat *matIn_Out,L_Point32 center, Int32 radius,Int32 color1,Int32 color2,Int32 color3, circletype connectivity)
    {
        Int32 color;
        switch(matIn_Out->_type)
        {
            case CCV_8UC1:
                color=(color1+color2+color3)/3;
                Circle( matIn_Out, center, radius, color, connectivity<0 );
            break;
            case CCV_8UC3:
                Circle3col( matIn_Out, center, radius, color1,color2,color3, connectivity<0 );
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }



    Int8 Myrectangle(Mat *matIn_Out,Int32 left,Int32 right,Int32 top,Int32 deep,Int32 color,Int32 thickness)
    {
        Int32 nHeight=matIn_Out->height;
        Int32 nWidth=matIn_Out->width;
        Int32 nStartY=matIn_Out->starty;
        Int32 nStartX=matIn_Out->startx;
        Int32 nnWidth=matIn_Out->nWidth;
        Int32 i,j;
        Int32 Temp1,Temp2;

        if(left<nStartX)
            left=nStartX;
        if(right>nStartX+nWidth-1)
            right=nStartX+nWidth-1;
        if(top<nStartY)
            top=nStartY;
        if(deep>nStartY+nHeight-1)
            deep=nStartY+nHeight-1;

        if(thickness<0)
        {
            switch(matIn_Out->_type)
            {
                case CCV_8UC1:
                    for(j=top;j<=deep;j++)
                    {
                        memset(&matIn_Out->ptr_uchar[j*nnWidth+left],color,(right-left+1)*getsizeof(matIn_Out->_type));
                    }
                break;
                case CCV_8UC3:
                    for(j=top;j<=deep;j++)
                    {
                        for(i=left;i<=right;i++)
                        {
                            matIn_Out->ptr_Vec3b[j*nnWidth+i].data1=color;
                            matIn_Out->ptr_Vec3b[j*nnWidth+i].data2=color;
                            matIn_Out->ptr_Vec3b[j*nnWidth+i].data3=color;
                        }
                    }
                break;
                default:
                    return 1;
                break;
            }
        }
        else if(thickness>0)
        {
            switch(matIn_Out->_type)
            {
                case CCV_8UC1:
                    Temp1=left+thickness;
                    if(Temp1>nStartX+nWidth)
                        Temp1=nStartX+nWidth;
                    if(Temp1>right+1)
                        Temp1=right+1;
                    Temp2=right-thickness;
                    if(Temp2<-1)
                        Temp2=-1;
                    if(Temp2<left-1)
                        Temp2=left-1;
                    for(j=top;j<=deep;j++)
                    {
                        memset(&matIn_Out->ptr_uchar[j*nnWidth+left],color,(Temp1-left)*getsizeof(matIn_Out->_type));
                        memset(&matIn_Out->ptr_uchar[j*nnWidth+Temp2+1],color,(right-Temp2)*getsizeof(matIn_Out->_type));
                    }
                    Temp1=top+thickness;
                    if(Temp1>nStartY+nHeight)
                        Temp1=nStartY+nHeight;
                    if(Temp1>deep+1)
                        Temp1=deep+1;
                    Temp2=deep-thickness;
                    if(Temp2<-1)
                        Temp2=-1;
                    if(Temp2<top-1)
                        Temp2=top-1;
                    for(i=left;i<=right;i++)
                    {
                        for(j=top;j<Temp1;j++)
                        {
                            matIn_Out->ptr_uchar[j*nnWidth+i]=color;
                        }
                        for(j=Temp2+1;j<=deep;j++)
                        {
                            matIn_Out->ptr_uchar[j*nnWidth+i]=color;
                        }
                    }
                break;
                case CCV_8UC3:
                    Temp1=left+thickness;
                    if(Temp1>nStartX+nWidth)
                        Temp1=nStartX+nWidth;
                    if(Temp1>right+1)
                        Temp1=right+1;
                    Temp2=right-thickness;
                    if(Temp2<-1)
                        Temp2=-1;
                    if(Temp2<left-1)
                        Temp2=left-1;
                    for(j=top;j<=deep;j++)
                    {
                        for(i=left;i<Temp1;i++)
                        {
                            matIn_Out->ptr_Vec3b[j*nnWidth+i].data1=color;
                            matIn_Out->ptr_Vec3b[j*nnWidth+i].data2=color;
                            matIn_Out->ptr_Vec3b[j*nnWidth+i].data3=color;
                        }
                        for(i=Temp2+1;i<=right;i++)
                        {
                            matIn_Out->ptr_Vec3b[j*nnWidth+i].data1=color;
                            matIn_Out->ptr_Vec3b[j*nnWidth+i].data2=color;
                            matIn_Out->ptr_Vec3b[j*nnWidth+i].data3=color;
                        }
                    }
                    Temp1=top+thickness;
                    if(Temp1>nStartY+nHeight)
                        Temp1=nStartY+nHeight;
                    if(Temp1>deep+1)
                        Temp1=deep+1;
                    Temp2=deep-thickness;
                    if(Temp2<-1)
                        Temp2=-1;
                    if(Temp2<top-1)
                        Temp2=top-1;
                    for(i=left;i<=right;i++)
                    {
                        for(j=top;j<Temp1;j++)
                        {
                            matIn_Out->ptr_Vec3b[j*nnWidth+i].data1=color;
                            matIn_Out->ptr_Vec3b[j*nnWidth+i].data2=color;
                            matIn_Out->ptr_Vec3b[j*nnWidth+i].data3=color;
                        }
                        for(j=Temp2+1;j<=deep;j++)
                        {
                            matIn_Out->ptr_Vec3b[j*nnWidth+i].data1=color;
                            matIn_Out->ptr_Vec3b[j*nnWidth+i].data2=color;
                            matIn_Out->ptr_Vec3b[j*nnWidth+i].data3=color;
                        }
                    }
                break;
                default:
                    return 1;
                break;
            }
        }
        return 0;
    }

    Int8 Myrectangle3col(Mat *matIn_Out,Int32 left,Int32 right,Int32 top,Int32 deep,Int32 color1,Int32 color2,Int32 color3,Int32 thickness)
    {
        Int32 nHeight=matIn_Out->height;
        Int32 nWidth=matIn_Out->width;
        Int32 nStartY=matIn_Out->starty;
        Int32 nStartX=matIn_Out->startx;
        Int32 nnWidth=matIn_Out->nWidth;
        Int32 i,j;
        Int32 Temp1,Temp2;
        Int32 color=(color1+color2+color3)/3;

        if(left<nStartX)
            left=nStartX;
        if(right>nStartX+nWidth-1)
            right=nStartX+nWidth-1;
        if(top<nStartY)
            top=nStartY;
        if(deep>nStartY+nHeight-1)
            deep=nStartY+nHeight-1;

        if(thickness<0)
        {
            switch(matIn_Out->_type)
            {
                case CCV_8UC1:
                    for(j=top;j<=deep;j++)
                    {
                        memset(&matIn_Out->ptr_uchar[j*nnWidth+left],color,(right-left+1)*getsizeof(matIn_Out->_type));
                    }
                break;
                case CCV_8UC3:
                    for(j=top;j<=deep;j++)
                    {
                        for(i=left;i<=right;i++)
                        {
                            matIn_Out->ptr_Vec3b[j*nnWidth+i].data1=color1;
                            matIn_Out->ptr_Vec3b[j*nnWidth+i].data2=color2;
                            matIn_Out->ptr_Vec3b[j*nnWidth+i].data3=color3;
                        }
                    }
                break;
                default:
                    return 1;
                break;
            }
        }
        else if(thickness>0)
        {
            switch(matIn_Out->_type)
            {
                case CCV_8UC1:
                    Temp1=left+thickness;
                    if(Temp1>nStartX+nWidth)
                        Temp1=nStartX+nWidth;
                    if(Temp1>right+1)
                        Temp1=right+1;
                    Temp2=right-thickness;
                    if(Temp2<-1)
                        Temp2=-1;
                    if(Temp2<left-1)
                        Temp2=left-1;
                    for(j=top;j<=deep;j++)
                    {
                        memset(&matIn_Out->ptr_uchar[j*nnWidth+left],color,(Temp1-left)*getsizeof(matIn_Out->_type));
                        memset(&matIn_Out->ptr_uchar[j*nnWidth+Temp2+1],color,(right-Temp2)*getsizeof(matIn_Out->_type));
                    }
                    Temp1=top+thickness;
                    if(Temp1>nStartY+nHeight)
                        Temp1=nStartY+nHeight;
                    if(Temp1>deep+1)
                        Temp1=deep+1;
                    Temp2=deep-thickness;
                    if(Temp2<-1)
                        Temp2=-1;
                    if(Temp2<top-1)
                        Temp2=top-1;
                    for(i=left;i<=right;i++)
                    {
                        for(j=top;j<Temp1;j++)
                        {
                            matIn_Out->ptr_uchar[j*nnWidth+i]=color;
                        }
                        for(j=Temp2+1;j<=deep;j++)
                        {
                            matIn_Out->ptr_uchar[j*nnWidth+i]=color;
                        }
                    }
                break;
                case CCV_8UC3:
                    Temp1=left+thickness;
                    if(Temp1>nStartX+nWidth)
                        Temp1=nStartX+nWidth;
                    if(Temp1>right+1)
                        Temp1=right+1;
                    Temp2=right-thickness;
                    if(Temp2<-1)
                        Temp2=-1;
                    if(Temp2<left-1)
                        Temp2=left-1;
                    for(j=top;j<=deep;j++)
                    {
                        for(i=left;i<Temp1;i++)
                        {
                            matIn_Out->ptr_Vec3b[j*nnWidth+i].data1=color1;
                            matIn_Out->ptr_Vec3b[j*nnWidth+i].data2=color2;
                            matIn_Out->ptr_Vec3b[j*nnWidth+i].data3=color3;
                        }
                        for(i=Temp2+1;i<=right;i++)
                        {
                            matIn_Out->ptr_Vec3b[j*nnWidth+i].data1=color1;
                            matIn_Out->ptr_Vec3b[j*nnWidth+i].data2=color2;
                            matIn_Out->ptr_Vec3b[j*nnWidth+i].data3=color3;
                        }
                    }
                    Temp1=top+thickness;
                    if(Temp1>nStartY+nHeight)
                        Temp1=nStartY+nHeight;
                    if(Temp1>deep+1)
                        Temp1=deep+1;
                    Temp2=deep-thickness;
                    if(Temp2<-1)
                        Temp2=-1;
                    if(Temp2<top-1)
                        Temp2=top-1;
                    for(i=left;i<=right;i++)
                    {
                        for(j=top;j<Temp1;j++)
                        {
                            matIn_Out->ptr_Vec3b[j*nnWidth+i].data1=color1;
                            matIn_Out->ptr_Vec3b[j*nnWidth+i].data2=color2;
                            matIn_Out->ptr_Vec3b[j*nnWidth+i].data3=color3;
                        }
                        for(j=Temp2+1;j<=deep;j++)
                        {
                            matIn_Out->ptr_Vec3b[j*nnWidth+i].data1=color1;
                            matIn_Out->ptr_Vec3b[j*nnWidth+i].data2=color2;
                            matIn_Out->ptr_Vec3b[j*nnWidth+i].data3=color3;
                        }
                    }
                break;
                default:
                    return 1;
                break;
            }
        }
        return 0;
    }

    Int8 clipLine(Uint32 width,Uint32 height, L_Point32 *pt1, L_Point32 *pt2)
    {
        Int32 x1, y1, x2, y2;
        Int32 c1, c2;
        Int32 right = width-1, bottom = height-1;

        if( width <= 0 || height <= 0 )
            return 0;

        x1 = pt1->x; y1 = pt1->y; x2 = pt2->x; y2 = pt2->y;
        c1 = (x1 < 0) + (x1 > right) * 2 + (y1 < 0) * 4 + (y1 > bottom) * 8;
        c2 = (x2 < 0) + (x2 > right) * 2 + (y2 < 0) * 4 + (y2 > bottom) * 8;

        if( (c1 & c2) == 0 && (c1 | c2) != 0 )
        {
            Int32 a;
            if( c1 & 12 )
            {
                a = c1 < 8 ? 0 : bottom;
                x1 +=  (a - y1) * (x2 - x1) / (y2 - y1);
                y1 = a;
                c1 = (x1 < 0) + (x1 > right) * 2;
            }
            if( c2 & 12 )
            {
                a = c2 < 8 ? 0 : bottom;
                x2 += (a - y2) * (x2 - x1) / (y2 - y1);
                y2 = a;
                c2 = (x2 < 0) + (x2 > right) * 2;
            }
            if( (c1 & c2) == 0 && (c1 | c2) != 0 )
            {
                if( c1 )
                {
                    a = c1 == 1 ? 0 : right;
                    y1 += (a - x1) * (y2 - y1) / (x2 - x1);
                    x1 = a;
                    c1 = 0;
                }
                if( c2 )
                {
                    a = c2 == 1 ? 0 : right;
                    y2 += (a - x2) * (y2 - y1) / (x2 - x1);
                    x2 = a;
                    c2 = 0;
                }
            }

            pt1->x = (Int32)x1;
            pt1->y = (Int32)y1;
            pt2->x = (Int32)x2;
            pt2->y = (Int32)y2;
        }

        return (c1 | c2) == 0;
    }

    void Changelinehead(L_Point32 *stpt,L_Point32 *edpt,Int32 realstx,Int32 realsty,Int32 realedx,Int32 realedy)
    {
        if(realedy>realsty)
        {
            stpt->x=realstx;
            stpt->y=realsty;
            edpt->x=realedx;
            edpt->y=realedy;
        }
        else if(realedy<realsty)
        {
            stpt->x=realedx;
            stpt->y=realedy;
            edpt->x=realstx;
            edpt->y=realsty;
        }
        else
        {
            if(realstx<realedx)
            {
                stpt->x=realstx;
                stpt->y=realsty;
                edpt->x=realedx;
                edpt->y=realedy;
            }
            else
            {
                stpt->x=realedx;
                stpt->y=realedy;
                edpt->x=realstx;
                edpt->y=realsty;
            }
        }
    }

    void addtiterator()
    {
        Int32 mask = titer_err < 0 ? -1 : 0;
        titer_err += titer_minusDelta + (titer_plusDelta & mask);
        titer_ptr += titer_minusStep + (titer_plusStep & mask);
    }

    void Inititerator(Mat*img, L_Point32 pt1, L_Point32 pt2,Int32 connectivity, Uint8 left_to_right)
    {
        Int32 bt_pix0,bt_pix;
        Int32 istep;
        Int32 dx,dy,s;
        Int32 mask;

        titer_count = -1;

        if( (unsigned)pt1.x >= (unsigned)(img->nWidth) ||
            (unsigned)pt2.x >= (unsigned)(img->nWidth) ||
            (unsigned)pt1.y >= (unsigned)(img->nHeight) ||
            (unsigned)pt2.y >= (unsigned)(img->nHeight) )
        {
            if( !clipLine( img->nWidth,img->nHeight, &pt1, &pt2 ) )
            {
                titer_ptr = img->data;
                titer_err = titer_plusDelta = titer_minusDelta = titer_plusStep = titer_minusStep = titer_count = 0;
                return;
            }
        }

        bt_pix0 = (Int32)getsizeof(img->_type), bt_pix = bt_pix0;
        istep = getsizeof(img->_type)*img->nWidth;

        dx = pt2.x - pt1.x;
        dy = pt2.y - pt1.y;
        s = dx < 0 ? -1 : 0;

        if(left_to_right)
        {
            dx = (dx ^ s) - s;
            dy = (dy ^ s) - s;
            pt1.x ^= (pt1.x ^ pt2.x) & s;
            pt1.y ^= (pt1.y ^ pt2.y) & s;
        }
        else
        {
            dx = (dx ^ s) - s;
            bt_pix = (bt_pix ^ s) - s;
        }

        titer_ptr = (Uint8*)(img->data + pt1.y * istep + pt1.x * bt_pix0);

        s = dy < 0 ? -1 : 0;
        dy = (dy ^ s) - s;
        istep = (istep ^ s) - s;

        s = dy > dx ? -1 : 0;

        dx ^= dy & s;
        dy ^= dx & s;
        dx ^= dy & s;

        bt_pix ^= istep & s;
        istep ^= bt_pix & s;
        bt_pix ^= istep & s;

        if( connectivity == 8 )
        {
            titer_err = dx - (dy + dy);
            titer_plusDelta = dx + dx;
            titer_minusDelta = -(dy + dy);
            titer_plusStep = (Int32)istep;
            titer_minusStep = bt_pix;
            titer_count = dx + 1;

            mask = titer_err < 0 ? -1 : 0;
            titer_totalStep=titer_minusStep + (titer_plusStep & mask);
        }
        else
        {
            titer_err = 0;
            titer_plusDelta = (dx + dx) + (dy + dy);
            titer_minusDelta = -(dy + dy);
            titer_plusStep = (Int32)istep - bt_pix;
            titer_minusStep = bt_pix;
            titer_count = dx + dy + 1;

            mask = titer_err < 0 ? -1 : 0;
            titer_totalStep=titer_minusStep + (titer_plusStep & mask);
        }

        titer_ptr0 = img->data;
        titer_step = (Int32)getsizeof(img->_type)*img->nWidth;
        titer_elemSize = bt_pix0;
    }

    Int8 Line( Mat *img, L_Point32 pt1, L_Point32 pt2,Int32 color, linetype connectivity)
    {
        Int32 i, count;
        switch(img->_type)
        {
            case CCV_8UC1:
                Inititerator(img, pt1, pt2, connectivity, 1);
                count = titer_count;
                for( i = 0; i < count; i++)
                {
                    Uint8* ptr = titer_ptr;
                    ptr[0] = (Uint8)color;
                    addtiterator();
                }
            break;
            case CCV_8UC3:
                Inititerator(img, pt1, pt2, connectivity, 1);
                count = titer_count;
                for( i = 0; i < count; i++)
                {
                    Uint8* ptr = titer_ptr;
                    ptr[0] = (Uint8)color;
                    ptr[1] = (Uint8)color;
                    ptr[2] = (Uint8)color;
                    addtiterator();
                }
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 LineComperMat( Mat *img, L_Point32 pt1, L_Point32 pt2, linetype connectivity,Int32 Gapmax,Int32 *longsize)
    {
        Int32 i, count;
        Int32 i32_longsize=0,no_longsize=0,max_longsize=0;

        *longsize=0;
        switch(img->_type)
        {
            case CCV_8UC1:
                Inititerator(img, pt1, pt2, connectivity, 1);
                count = titer_count;
                for( i = 0; i < count; i++)
                {
                    Uint8* ptr = titer_ptr;
                    if(ptr[0]!=0)
                    {
                        i32_longsize++;
                        if(max_longsize<i32_longsize)
                        {
                            max_longsize=i32_longsize;
                        }
                        no_longsize=0;
                    }
                    else if(i32_longsize!=0)
                    {
                        no_longsize++;
                        if(no_longsize>Gapmax)
                        {
                            if(max_longsize<i32_longsize)
                            {
                                max_longsize=i32_longsize;
                            }
                            i32_longsize=0;
                        }
                    }
                    addtiterator();
                }

            break;
            default:
                return 1;
            break;
        }
        *longsize=max_longsize;
        return 0;
    }

    Int8 LineComperMat2( Mat *img, L_Point32 pt1, L_Point32 pt2, linetype connectivity,Int32 Gapmax,L_Point32 *stpt, L_Point32 *edpt)
    {
        Int32 i, count;
        Int32 i32_longsize=0,no_longsize=0,max_longsize=0;
        Int32 nnWidth=img->nWidth;
        Int32 stx;
        Int32 sty;
        Int32 edx;
        Int32 edy;
        Int32 realstx;
        Int32 realsty;
        Int32 realedx;
        Int32 realedy;
        Uint8 temp=0;

        switch(img->_type)
        {
            case CCV_8UC1:
                Inititerator(img, pt1, pt2, connectivity, 1);
                count = titer_count;
                for( i = 0; i < count; i++)
                {
                    Uint8* ptr = titer_ptr;
                    if(ptr[0]!=0)
                    {
                        Int32 wsize=titer_ptr-img->data;
                        Int32 y=wsize/nnWidth;
                        Int32 x=wsize-nnWidth*y;

                        i32_longsize++;
                        no_longsize=0;
                        if(temp==0)
                        {
                            temp=1;
                            stx=x;
                            sty=y;
                            edx=x;
                            edy=y;
                        }
                        else
                        {
                            edx=x;
                            edy=y;
                        }
                        if(max_longsize<i32_longsize)
                        {
                            max_longsize=i32_longsize;
                            realstx=stx;
                            realsty=sty;
                            realedx=edx;
                            realedy=edy;
                        }
                    }
                    else if(i32_longsize>0)
                    {
                        no_longsize++;
                        if(no_longsize>Gapmax)
                        {
                            temp=0;
                            if(max_longsize<i32_longsize)
                            {
                                max_longsize=i32_longsize;
                                realstx=stx;
                                realsty=sty;
                                realedx=edx;
                                realedy=edy;
                            }
                            i32_longsize=0;
                        }
                    }
                    addtiterator();
                }
            break;
            default:
                return 1;
            break;
        }
        if(max_longsize==0)
            return 1;
        Changelinehead(stpt,edpt,realstx,realsty,realedx,realedy);
        return 0;
    }

    Int8 LineComperMat3( Mat *img, L_Point32 pt1, L_Point32 pt2, linetype connectivity,Int32 Gapmax,Int32 *Max_longsize,L_Point32 *stpt, L_Point32 *edpt)
    {
        Int32 i, count;
        Int32 i32_longsize=0,no_longsize=0,max_longsize=0;
        Int32 nnWidth=img->nWidth;
        Int32 stx;
        Int32 sty;
        Int32 edx;
        Int32 edy;
        Int32 realstx;
        Int32 realsty;
        Int32 realedx;
        Int32 realedy;
        Uint8 temp=0;
        *Max_longsize=0;

        switch(img->_type)
        {
            case CCV_8UC1:
                Inititerator(img, pt1, pt2, connectivity, 1);
                count = titer_count;
                for( i = 0; i < count; i++)
                {
                    Uint8* ptr = titer_ptr;
                    if(ptr[0]!=0)
                    {
                        Int32 wsize=titer_ptr-img->data;
                        Int32 y=wsize/nnWidth;
                        Int32 x=wsize-nnWidth*y;

                        i32_longsize++;
                        no_longsize=0;
                        if(temp==0)
                        {
                            temp=1;
                            stx=x;
                            sty=y;
                            edx=x;
                            edy=y;
                        }
                        else
                        {
                            edx=x;
                            edy=y;
                        }
                    }
                    else
                    {
                        no_longsize++;
                        if(no_longsize>Gapmax)
                        {
                            temp=0;
                            if(max_longsize<i32_longsize)
                            {
                                max_longsize=i32_longsize;
                                realstx=stx;
                                realsty=sty;
                                realedx=edx;
                                realedy=edy;
                            }
                            i32_longsize=0;
                        }
                    }
                    addtiterator();
                }
            break;
            default:
                return 1;
            break;
        }
        if(max_longsize!=0)
            Changelinehead(stpt,edpt,realstx,realsty,realedx,realedy);

        *Max_longsize=max_longsize;
        return 0;
    }

    Int8 LineComperMat4( Mat *img, L_Point32 pt1, L_Point32 pt2, linetype connectivity,L_Point32 *stpt, L_Point32 *edpt)
    {
        Int32 i, count;
        Int32 nnWidth=img->nWidth;
        Int32 realstx=-1;
        Int32 realsty=-1;
        Int32 realedx=-1;
        Int32 realedy=-1;

        switch(img->_type)
        {
            case CCV_8UC1:
                Inititerator(img, pt1, pt2, connectivity, 1);
                count = titer_count;
                for( i = 0; i < count; i++)
                {
                    if(i==0)
                    {
                        Int32 wsize=titer_ptr-img->data;
                        Int32 y=wsize/nnWidth;
                        Int32 x=wsize-nnWidth*y;
                        realstx=x;
                        realsty=y;
                    }
                    if(i==count-1)
                    {
                        Int32 wsize=titer_ptr-img->data;
                        Int32 y=wsize/nnWidth;
                        Int32 x=wsize-nnWidth*y;
                        realedx=x;
                        realedy=y;
                    }
                    addtiterator();
                }
            break;
            default:
                return 1;
            break;
        }
        if(realstx==-1||
           realsty==-1||
           realedx==-1||
           realedy==-1)
           return 1;
        Changelinehead(stpt,edpt,realstx,realsty,realedx,realedy);
        return 0;
    }

    Int8 LinePoint( Mat *img, L_Point32 pt1, L_Point32 pt2, linetype connectivity,L_Point* buffer,Int32 *buffernum)
    {
        Int32 i, count;
        Int32 nnWidth=img->nWidth;
        Uint8 mod=0;
        switch(img->_type)
        {
            case CCV_8UC1:
                Inititerator(img, pt1, pt2, connectivity, 1);
                count = titer_count;
                if(titer_totalStep<0)//y值从大到小
                {
                    if(pt1.y>pt2.y)
                    {
                        mod=0;			//顺序赋值
                    }
                    else if(pt1.y<pt2.y)
                    {
                        mod=1;			//逆序赋值
                    }
                    else
                    {
                        if(pt1.x>pt2.x)
                        {
                            mod=0;			//顺序赋值
                        }
                        else
                        {
                            mod=1;			//逆序赋值
                        }
                    }
                }
                else//y值从小到大
                {
                    if(pt1.y>pt2.y)
                    {
                        mod=1;			//顺序赋值
                    }
                    else if(pt1.y<pt2.y)
                    {
                        mod=0;			//逆序赋值
                    }
                    else
                    {
                        if(pt1.x>pt2.x)
                        {
                            mod=1;			//顺序赋值
                        }
                        else
                        {
                            mod=0;			//逆序赋值
                        }
                    }
                }
                if(mod==0)
                {
                    for( i = 0; i < count; i++)
                    {
                        Int32 wsize=titer_ptr-img->data;
                        Int32 y=wsize/nnWidth;
                        Int32 x=wsize-nnWidth*y;
                        buffer[i].x=x;
                        buffer[i].y=y;
                        addtiterator();
                    }
                }
                else
                {
                    for( i = 0; i < count; i++)
                    {
                        Int32 wsize=titer_ptr-img->data;
                        Int32 y=wsize/nnWidth;
                        Int32 x=wsize-nnWidth*y;
                        buffer[count-i-1].x=x;
                        buffer[count-i-1].y=y;
                        addtiterator();
                    }
                }
            break;
            default:
                return 1;
            break;
        }
        *buffernum=titer_count;
        return 0;
    }

    Int8 LinePoint2( Mat *img, L_Point32 pt1, L_Point32 pt2, linetype connectivity,L_Point* buffer,Int32 *buffernum)
    {
        Int32 i, count;
        Int32 nnWidth=img->nWidth;
        switch(img->_type)
        {
            case CCV_8UC1:
                Inititerator(img, pt1, pt2, connectivity, 1);
                count = titer_count;
                for( i = 0; i < count; i++)
                {
                    Int32 wsize=titer_ptr-img->data;
                    Int32 y=wsize/nnWidth;
                    Int32 x=wsize-nnWidth*y;
                    buffer[*buffernum+i].x=x;
                    buffer[*buffernum+i].y=y;
                    addtiterator();
                }
            break;
            default:
                return 1;
            break;
        }
        *buffernum=titer_count+(*buffernum);
        return 0;
    }

    Int8 Line3col( Mat *img, L_Point32 pt1, L_Point32 pt2,Int32 color1,Int32 color2,Int32 color3,linetype connectivity)
    {
        Int32 i, count;
        Int32 color=(color1+color2+color3)/3;
        switch(img->_type)
        {
            case CCV_8UC1:
                Inititerator(img, pt1, pt2, connectivity, 1);
                count = titer_count;
                for( i = 0; i < count; i++)
                {
                    Uint8* ptr = titer_ptr;
                    ptr[0] = (Uint8)color;
                    addtiterator();
                }
            break;
            case CCV_8UC3:
                Inititerator(img, pt1, pt2, connectivity, 1);
                count = titer_count;
                for( i = 0; i < count; i++)
                {
                    Uint8* ptr = titer_ptr;
                    ptr[0] = (Uint8)color1;
                    ptr[1] = (Uint8)color2;
                    ptr[2] = (Uint8)color3;
                    addtiterator();
                }
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 FillConvexPoly( Mat* img,L_Point32* v,Int32 npts,Int32 color,linetype connectivity,Int32 shift)
    {
        struct
        {
            Int32 idx, di;
            Int32 x, dx, ye;
        }
        edge[2];

        Int32 delta = shift ? 1 << (shift - 1) : 0;
        Int32 i, y, imin = 0, left = 0, right = 1, x1, x2;
        Int32 edges = npts;
        Int32 xmin, xmax, ymin, ymax;
        Uint8* ptr = img->data;
        Int32 nHeight=img->nHeight;
        Int32 nWidth=img->nWidth;
        Int32 pix_size = getsizeof(img->_type);
        L_Point32 p0;
        Int32 step=getsizeof(img->_type)*img->nWidth;
        Int32 delta1, delta2;


        delta1 = delta2 = XY_ONE >> 1;

        p0 = v[npts - 1];
        p0.x <<= XY_SHIFT - shift;
        p0.y <<= XY_SHIFT - shift;

        xmin = xmax = v[0].x;
        ymin = ymax = v[0].y;

        for( i = 0; i < npts; i++ )
        {
            L_Point32 p = v[i];
            if( p.y < ymin )
            {
                ymin = p.y;
                imin = i;
            }

            ymax = MAX( ymax, p.y );
            xmax = MAX( xmax, p.x );
            xmin = MIN( xmin, p.x );

            p.x <<= XY_SHIFT - shift;
            p.y <<= XY_SHIFT - shift;

            p0 = p;
        }

        xmin = (xmin + delta) >> shift;
        xmax = (xmax + delta) >> shift;
        ymin = (ymin + delta) >> shift;
        ymax = (ymax + delta) >> shift;

        if( npts < 3 || xmax < 0 || ymax < 0 || xmin >= nWidth || ymin >= nHeight )
            return 0;

        ymax = MIN( ymax, nHeight - 1 );
        edge[0].idx = edge[1].idx = imin;

        edge[0].ye = edge[1].ye = y = ymin;
        edge[0].di = 1;
        edge[1].di = npts - 1;

        ptr += step*y;

        do
        {
            for( i = 0; i < 2; i++ )
            {
                if( y >= edge[i].ye )
                {
                    Int32 idx = edge[i].idx, di = edge[i].di;
                    Int32 xs = 0, xe, ye, ty = 0;

                    for(;;)
                    {
                        ty = (v[idx].y + delta) >> shift;
                        if( ty > y || edges == 0 )
                            break;
                        xs = v[idx].x;
                        idx += di;
                        idx -= ((idx < npts) - 1) & npts;
                        edges--;
                    }

                    ye = ty;
                    xs <<= XY_SHIFT - shift;
                    xe = v[idx].x << (XY_SHIFT - shift);


                    if( y >= ye )
                        return 0;

                    edge[i].ye = ye;
                    edge[i].dx = ((xe - xs)*2 + (ye - y)) / (2 * (ye - y));
                    edge[i].x = xs;
                    edge[i].idx = idx;
                }
            }

            if( edge[left].x > edge[right].x )
            {
                left ^= 1;
                right ^= 1;
            }

            x1 = edge[left].x;
            x2 = edge[right].x;

            if( y >= 0 )
            {
                Int32 xx1 = (x1 + delta1) >> XY_SHIFT;
                Int32 xx2 = (x2 + delta2) >> XY_SHIFT;

                if( xx2 >= 0 && xx1 < nWidth )
                {
                    if( xx1 < 0 )
                        xx1 = 0;
                    if( xx2 >= nWidth )
                        xx2 = nWidth - 1;
                    ICV_HLINE( ptr, xx1, xx2, color, pix_size );
                }
            }

            x1 += edge[left].dx;
            x2 += edge[right].dx;

            edge[left].x = x1;
            edge[right].x = x2;
            ptr += step;
        }
        while( ++y <= ymax );
        return 0;
    }

    Int32 FillConvexPolyPoint( Mat* img,L_Point32* v,Int32 npts,linetype connectivity,Int32 shift,L_Point *buffer,Int32 *buffernum)
    {
        struct
        {
            Int32 idx, di;
            Int32 x, dx, ye;
        }
        edge[2];

        Int32 delta = shift ? 1 << (shift - 1) : 0;
        Int32 i, y, imin = 0, left = 0, right = 1, x1, x2;
        Int32 edges = npts;
        Int32 xmin, xmax, ymin, ymax;
        Uint8* ptr = img->data;
        Int32 nHeight=img->nHeight;
        Int32 nWidth=img->nWidth;
        Int32 pix_size = getsizeof(img->_type);
        L_Point32 p0;
        Int32 step=getsizeof(img->_type)*img->nWidth;
        Int32 delta1, delta2;


        delta1 = delta2 = XY_ONE >> 1;

        p0 = v[npts - 1];
        p0.x <<= XY_SHIFT - shift;
        p0.y <<= XY_SHIFT - shift;

        xmin = xmax = v[0].x;
        ymin = ymax = v[0].y;

        for( i = 0; i < npts; i++ )
        {
            L_Point32 p = v[i];
            if( p.y < ymin )
            {
                ymin = p.y;
                imin = i;
            }

            ymax = MAX( ymax, p.y );
            xmax = MAX( xmax, p.x );
            xmin = MIN( xmin, p.x );

            p.x <<= XY_SHIFT - shift;
            p.y <<= XY_SHIFT - shift;

            p0 = p;
        }

        xmin = (xmin + delta) >> shift;
        xmax = (xmax + delta) >> shift;
        ymin = (ymin + delta) >> shift;
        ymax = (ymax + delta) >> shift;

        if( npts < 3 || xmax < 0 || ymax < 0 || xmin >= nWidth || ymin >= nHeight )
            return 0;

        ymax = MIN( ymax, nHeight - 1 );
        edge[0].idx = edge[1].idx = imin;

        edge[0].ye = edge[1].ye = y = ymin;
        edge[0].di = 1;
        edge[1].di = npts - 1;

        ptr += step*y;

        do
        {
            for( i = 0; i < 2; i++ )
            {
                if( y >= edge[i].ye )
                {
                    Int32 idx = edge[i].idx, di = edge[i].di;
                    Int32 xs = 0, xe, ye, ty = 0;

                    for(;;)
                    {
                        ty = (v[idx].y + delta) >> shift;
                        if( ty > y || edges == 0 )
                            break;
                        xs = v[idx].x;
                        idx += di;
                        idx -= ((idx < npts) - 1) & npts;
                        edges--;
                    }

                    ye = ty;
                    xs <<= XY_SHIFT - shift;
                    xe = v[idx].x << (XY_SHIFT - shift);


                    if( y >= ye )
                        return 0;

                    edge[i].ye = ye;
                    edge[i].dx = ((xe - xs)*2 + (ye - y)) / (2 * (ye - y));
                    edge[i].x = xs;
                    edge[i].idx = idx;
                }
            }

            if( edge[left].x > edge[right].x )
            {
                left ^= 1;
                right ^= 1;
            }

            x1 = edge[left].x;
            x2 = edge[right].x;

            if( y >= 0 )
            {
                Int32 xx1 = (x1 + delta1) >> XY_SHIFT;
                Int32 xx2 = (x2 + delta2) >> XY_SHIFT;

                if( xx2 >= 0 && xx1 < nWidth )
                {
                    Int32 mpointx;
                    if( xx1 < 0 )
                        xx1 = 0;
                    if( xx2 >= nWidth )
                        xx2 = nWidth - 1;
                  //  ICV_HLINE( ptr, xx1, xx2, color, pix_size );
                    for(mpointx=xx1;mpointx<xx2;mpointx++)
                    {
                        buffer[*buffernum].x=mpointx;
                        buffer[*buffernum].y=y;
                        (*buffernum)++;
                    }
                }
            }

            x1 += edge[left].dx;
            x2 += edge[right].dx;

            edge[left].x = x1;
            edge[right].x = x2;
            ptr += step;
        }
        while( ++y <= ymax );
        return 0;
    }

    Int8 FillConvexPoly3col( Mat* img,L_Point32* v,Int32 npts,Int32 color1,Int32 color2,Int32 color3,linetype connectivity,Int32 shift)
    {
        struct
        {
            Int32 idx, di;
            Int32 x, dx, ye;
        }
        edge[2];

        Int32 delta = shift ? 1 << (shift - 1) : 0;
        Int32 i, y, imin = 0, left = 0, right = 1, x1, x2;
        Int32 edges = npts;
        Int32 xmin, xmax, ymin, ymax;
        Uint8* ptr = img->data;
        Int32 nHeight=img->nHeight;
        Int32 nWidth=img->nWidth;
        Int32 pix_size = getsizeof(img->_type);
        L_Point32 p0;
        Int32 step=getsizeof(img->_type)*img->nWidth;
        Int32 delta1, delta2;

        delta1 = delta2 = XY_ONE >> 1;

        p0 = v[npts - 1];
        p0.x <<= XY_SHIFT - shift;
        p0.y <<= XY_SHIFT - shift;

        xmin = xmax = v[0].x;
        ymin = ymax = v[0].y;

        for( i = 0; i < npts; i++ )
        {
            L_Point32 p = v[i];
            if( p.y < ymin )
            {
                ymin = p.y;
                imin = i;
            }

            ymax = MAX( ymax, p.y );
            xmax = MAX( xmax, p.x );
            xmin = MIN( xmin, p.x );

            p.x <<= XY_SHIFT - shift;
            p.y <<= XY_SHIFT - shift;

            p0 = p;
        }

        xmin = (xmin + delta) >> shift;
        xmax = (xmax + delta) >> shift;
        ymin = (ymin + delta) >> shift;
        ymax = (ymax + delta) >> shift;

        if( npts < 3 || xmax < 0 || ymax < 0 || xmin >= nWidth || ymin >= nHeight )
            return 0;

        ymax = MIN( ymax, nHeight - 1 );
        edge[0].idx = edge[1].idx = imin;

        edge[0].ye = edge[1].ye = y = ymin;
        edge[0].di = 1;
        edge[1].di = npts - 1;

        ptr += step*y;

        do
        {
            for( i = 0; i < 2; i++ )
            {
                if( y >= edge[i].ye )
                {
                    Int32 idx = edge[i].idx, di = edge[i].di;
                    Int32 xs = 0, xe, ye, ty = 0;

                    for(;;)
                    {
                        ty = (v[idx].y + delta) >> shift;
                        if( ty > y || edges == 0 )
                            break;
                        xs = v[idx].x;
                        idx += di;
                        idx -= ((idx < npts) - 1) & npts;
                        edges--;
                    }

                    ye = ty;
                    xs <<= XY_SHIFT - shift;
                    xe = v[idx].x << (XY_SHIFT - shift);


                    if( y >= ye )
                        return 0;

                    edge[i].ye = ye;
                    edge[i].dx = ((xe - xs)*2 + (ye - y)) / (2 * (ye - y));
                    edge[i].x = xs;
                    edge[i].idx = idx;
                }
            }

            if( edge[left].x > edge[right].x )
            {
                left ^= 1;
                right ^= 1;
            }

            x1 = edge[left].x;
            x2 = edge[right].x;

            if( y >= 0 )
            {
                Int32 xx1 = (x1 + delta1) >> XY_SHIFT;
                Int32 xx2 = (x2 + delta2) >> XY_SHIFT;

                if( xx2 >= 0 && xx1 < nWidth )
                {
                    if( xx1 < 0 )
                        xx1 = 0;
                    if( xx2 >= nWidth )
                        xx2 = nWidth - 1;
                    ICV_HLINE3COL( ptr, xx1, xx2, color1,color2,color3, pix_size );
                }
            }

            x1 += edge[left].dx;
            x2 += edge[right].dx;

            edge[left].x = x1;
            edge[right].x = x2;
            ptr += step;
        }
        while( ++y <= ymax );
        return 0;
    }


    Int8 MyLine( Mat *matIn_Out, L_Point32 st, L_Point32 ed,Int32 color, linetype connectivity,Int32 thickness)
    {
        Int8 returnnum=0;
        Int32 i;
        Int32 flags=3;
        if(thickness<=1)
        {
            returnnum=Line(matIn_Out,st,ed,color,connectivity);
        }
        else if(thickness>1)
        {
            static const double INV_XY_ONE = 1./XY_ONE;
            L_Point32 pt[4], dp;
            double dx,dy;
            double r;
            Int32 oddThickness = thickness & 1;

            st.x<<=XY_SHIFT;
            st.y<<=XY_SHIFT;
            ed.x<<=XY_SHIFT;
            ed.y<<=XY_SHIFT;

            dx = (st.x - ed.x)*INV_XY_ONE;
            dy = (ed.y - st.y)*INV_XY_ONE;
            r = dx * dx + dy * dy;

            thickness <<= XY_SHIFT - 1;

            dp.x=0;
            dp.y=0;

            if( fabs(r) > DBL_EPSILON )
            {
                r = (thickness + oddThickness*XY_ONE*0.5)/sqrt(r);
                dp.x = ( dy * r );
                dp.y = ( dx * r );

                pt[0].x = st.x + dp.x;
                pt[0].y = st.y + dp.y;
                pt[1].x = st.x - dp.x;
                pt[1].y = st.y - dp.y;
                pt[2].x = ed.x - dp.x;
                pt[2].y = ed.y - dp.y;
                pt[3].x = ed.x + dp.x;
                pt[3].y = ed.y + dp.y;

                FillConvexPoly( matIn_Out, pt, 4, color, connectivity, XY_SHIFT );
            }
            for( i = 0; i < 2; i++ )
            {
                if( flags & (i+1) )
                {
                    L_Point32 center;
                    center.x = (st.x + (XY_ONE>>1)) >> XY_SHIFT;
                    center.y = (st.y + (XY_ONE>>1)) >> XY_SHIFT;
                    Circle( matIn_Out, center, (thickness + (XY_ONE>>1)) >> XY_SHIFT, color, 1 );
                }
                st.x = ed.x;
                st.y = ed.y;
            }
        }
        else
        {
            returnnum=3;
        }
        return returnnum;
    }

    Int8 MyLineComperMat( Mat *img, L_Point32 pt1, L_Point32 pt2, linetype connectivity,Int32 thickness,Int32 Gapmax,Int32 *longsize)
    {
        Int8 returnnum=0;
        if(thickness<=1)
        {
            returnnum=LineComperMat(img,pt1,pt2,connectivity,Gapmax,longsize);
        }
        else
        {
            returnnum=2;
        }
        return returnnum;
    }

    Int8 MyLineComperMat2( Mat *img, L_Point32 pt1, L_Point32 pt2, linetype connectivity,Int32 thickness,Int32 Gapmax,L_Point32 *stpt,L_Point32 *edpt)
    {
        Int8 returnnum=0;
        if(thickness<=1)
        {
            returnnum=LineComperMat2(img,pt1,pt2,connectivity,Gapmax,stpt,edpt);
        }
        else
        {
            returnnum=2;
        }
        return returnnum;
    }

    Int8 MyLineComperMat3( Mat *img, L_Point32 pt1, L_Point32 pt2, linetype connectivity,Int32 thickness,Int32 Gapmax,Int32 *maxlong,L_Point32 *stpt,L_Point32 *edpt)
    {
        Int8 returnnum=0;
        if(thickness<=1)
        {
            returnnum=LineComperMat3(img,pt1,pt2,connectivity,Gapmax,maxlong,stpt,edpt);
        }
        else
        {
            returnnum=2;
        }
        return returnnum;
    }

    Int8 MyLineComperMat4( Mat *img, L_Point32 pt1, L_Point32 pt2, linetype connectivity,L_Point32 *stpt,L_Point32 *edpt)
    {
        Int8 returnnum=0;
        returnnum=LineComperMat4(img,pt1,pt2,connectivity,stpt,edpt);

        return returnnum;
    }

    Int8 MyLinePoint( Mat *img, L_Point32 pt1, L_Point32 pt2, linetype connectivity,Int32 thickness,L_Point *buffer,Int32 *buffernum)
    {
        Int8 returnnum=0;
        *buffernum=0;
        if(thickness<=1)
        {
            returnnum=LinePoint(img,pt1,pt2,connectivity,buffer,buffernum);
        }
        else if(thickness>1)
        {
            static const double INV_XY_ONE = 1./XY_ONE;
            L_Point32 pt[4], dp;
            double dx,dy;
            double r;
            Int32 oddThickness = thickness & 1;

            pt1.x<<=XY_SHIFT;
            pt1.y<<=XY_SHIFT;
            pt2.x<<=XY_SHIFT;
            pt2.y<<=XY_SHIFT;

            dx = (pt1.x - pt2.x)*INV_XY_ONE;
            dy = (pt2.y - pt1.y)*INV_XY_ONE;
            r = dx * dx + dy * dy;
            thickness <<= XY_SHIFT - 1;

            dp.x=0;
            dp.y=0;

            if( fabs(r) > DBL_EPSILON )
            {
                r = (thickness + oddThickness*XY_ONE*0.5)/sqrt(r);
                dp.x = ( dy * r );
                dp.y = ( dx * r );

                pt[0].x = pt1.x + dp.x;
                pt[0].y = pt1.y + dp.y;
                pt[1].x = pt1.x - dp.x;
                pt[1].y = pt1.y - dp.y;
                pt[2].x = pt2.x - dp.x;
                pt[2].y = pt2.y - dp.y;
                pt[3].x = pt2.x + dp.x;
                pt[3].y = pt2.y + dp.y;
                FillConvexPolyPoint( img, pt, 4, connectivity, XY_SHIFT,buffer,buffernum );
            }
        }
        else
        {
            returnnum=3;
        }
        return returnnum;
    }

    Int8 MyCirclePoint( Mat *img, L_Point32 center,Int32 radio, circletype connectivity,L_Point *buffer,Int32 *buffernum)
    {
        *buffernum=0;
        CirclePoint(img,center,radio,connectivity<0,buffer,buffernum,0);
        return 0;
    }

    Int8 MyLine3col( Mat *matIn_Out, L_Point32 st, L_Point32 ed,Int32 color1,Int32 color2,Int32 color3,linetype connectivity,Int32 thickness)
    {
        Int8 returnnum=0;
        Int32 flags=3;
        Int32 i;
        if(thickness<=1)
        {
            returnnum=Line3col(matIn_Out,st,ed,color1,color2,color3,connectivity);
        }
        else if(thickness>1)
        {
            static const double INV_XY_ONE = 1./XY_ONE;
            L_Point32 pt[4], dp;
            double dx,dy;
            double r;
            Int32 oddThickness = thickness & 1;

            st.x<<=XY_SHIFT;
            st.y<<=XY_SHIFT;
            ed.x<<=XY_SHIFT;
            ed.y<<=XY_SHIFT;

            dx = (st.x - ed.x)*INV_XY_ONE;
            dy = (ed.y - st.y)*INV_XY_ONE;
            r = dx * dx + dy * dy;
            thickness <<= XY_SHIFT - 1;

            dp.x=0;
            dp.y=0;

            if( fabs(r) > DBL_EPSILON )
            {
                r = (thickness + oddThickness*XY_ONE*0.5)/sqrt(r);
                dp.x = ( dy * r );
                dp.y = ( dx * r );

                pt[0].x = st.x + dp.x;
                pt[0].y = st.y + dp.y;
                pt[1].x = st.x - dp.x;
                pt[1].y = st.y - dp.y;
                pt[2].x = ed.x - dp.x;
                pt[2].y = ed.y - dp.y;
                pt[3].x = ed.x + dp.x;
                pt[3].y = ed.y + dp.y;

                FillConvexPoly3col( matIn_Out, pt, 4, color1,color2,color3, connectivity, XY_SHIFT );
            }
            for( i = 0; i < 2; i++ )
            {
                if( flags & (i+1) )
                {
                    L_Point32 center;
                    center.x = (st.x + (XY_ONE>>1)) >> XY_SHIFT;
                    center.y = (st.y + (XY_ONE>>1)) >> XY_SHIFT;
                    Circle3col( matIn_Out, center, (thickness + (XY_ONE>>1)) >> XY_SHIFT, color1,color2,color3, 1 );
                }
                st.x = ed.x;
                st.y = ed.y;
            }
        }
        else
        {
            returnnum=3;
        }
        return returnnum;
    }

    Int8 MyDottedLine(Mat *matIn_Out,L_Point32 st,L_Point32 ed,Int32 color,	Int32 dis, dottedtype Mod,linetype connectivity,Int32 thickness)
    {
        switch (Mod)
        {
            case CV_DOTTEDLINE_LINE:
            {
                float n = dis; //线长度
                float w = ed.x - st.x, h = ed.y - st.y;
                float l = sqrtf(w * w + h * h);
                // 矫正线长度，使线个数为奇数
                int m = l / n;
                RotatedRect boxst,boxed;

                m = m % 2 ? m : m + 1;
                n = l / m;
                boxst.angle=0;
                boxst.center.x=st.x;
                boxst.center.y=st.y;
                boxst.size.width=1;
                boxst.size.height=1;
                boxed.angle=0;
                boxed.center.x=ed.x;
                boxed.center.y=ed.y;
                boxed.size.width=1;
                boxed.size.height=1;

                MyEllipse(matIn_Out, boxst, color,connectivity, thickness);
                MyEllipse(matIn_Out, boxed, color,connectivity, thickness);

                if (st.y == ed.y) //水平线：y = m
                {
                    float x1 = MIN(st.x, ed.x);
                    float x2 = MAX(st.x, ed.x);
                    float x,n1;
                    L_Point32 m_st,m_ed;
                    for (x = x1, n1 = 2 * n; x < x2; x = x + n1)
                    {
                        m_st.x=x+0.5;
                        m_st.y=st.y;
                        m_ed.x=x+n+0.5;
                        m_ed.y=st.y;
                        MyLine(matIn_Out,m_st,m_ed,color,connectivity,thickness);
                    }
                }
                else if (st.x == ed.x) //垂直线, x = m
                {
                    float y1 = MIN(st.y, ed.y);
                    float y2 = MAX(st.y, ed.y);
                    float y,n1;
                    L_Point32 m_st,m_ed;
                    for (y = y1, n1 = 2 * n; y < y2; y = y + n1)
                    {
                        m_st.x=st.x;
                        m_st.y=y+0.5;
                        m_ed.x=st.x;
                        m_ed.y=y+n+0.5;
                        MyLine(matIn_Out,m_st,m_ed,color,connectivity,thickness);
                    }
                }
                else // 倾斜线，与x轴、y轴都不垂直或平行
                {
                    // 直线方程的两点式：(y-y1)/(y2-y1)=(x-x1)/(x2-x1) -> y = (y2-y1)*(x-x1)/(x2-x1)+y1
                    float n1 = n * abs(w) / l;
                    float k = h / w;
                    float x1 = MIN(st.x, ed.x);
                    float x2 = MAX(st.x, ed.x);
                    float x,n2;
                    L_Point32 m_st,m_ed;
                    for (x = x1, n2 = 2 * n1; x < x2; x = x + n2)
                    {
                        m_st.x=x+0.5;
                        m_st.y=k * (x - st.x) + st.y + 0.5;
                        m_ed.x=x + n1 +0.5;
                        m_ed.y=k * (x + n1 - st.x) + st.y+0.5;
                        MyLine(matIn_Out,m_st,m_ed,color,connectivity,thickness);
                    }
                }
            }
            break;
            case CV_DOTTEDLINE_POINT:
            {
                float n = dis;
                float w = ed.x - st.x, h = ed.y - st.y;
                float l = sqrtf(w * w + h * h);
                int m = l / n;
                RotatedRect boxst,boxed;
                RotatedRect box;

                n = l / m;
                boxst.angle=0;
                boxst.center.x=st.x;
                boxst.center.y=st.y;
                boxst.size.width=1;
                boxst.size.height=1;
                boxed.angle=0;
                boxed.center.x=ed.x;
                boxed.center.y=ed.y;
                boxed.size.width=1;
                boxed.size.height=1;
                box.angle=0;
                box.size.width=1;
                box.size.height=1;
                MyEllipse(matIn_Out, boxst, color,connectivity, thickness);
                MyEllipse(matIn_Out, boxed, color,connectivity, thickness);

                if (st.y == ed.y)
                {
                    float x1 = MIN(st.x, ed.x);
                    float x2 = MAX(st.x, ed.x);
                    float x;
                    for (x = x1 + n; x < x2; x = x + n)
                    {
                        box.center.x=x;
                        box.center.y=st.y;
                        MyEllipse(matIn_Out, box, color, connectivity,thickness);
                    }
                }
                else if (st.x == ed.x)
                {
                    float y1 = MIN(st.y, ed.y);
                    float y2 = MAX(st.y, ed.y);
                    float y;
                    for (y = y1 + n; y < y2; y = y + n)
                    {
                        box.center.x=st.x;
                        box.center.y=y;
                        MyEllipse(matIn_Out, box, color, connectivity,thickness);
                    }
                }
                else // 倾斜线，与x轴、y轴都不垂直或平行
                {
                    // 直线方程的两点式：(y-y1)/(y2-y1)=(x-x1)/(x2-x1) -> y = (y2-y1)*(x-x1)/(x2-x1)+y1
                    float m = n * abs(w) / l;
                    float k = h / w;
                    float x1 = MIN(st.x, ed.x);
                    float x2 = MAX(st.x, ed.x);
                    float x;
                    for (x = x1 + m; x < x2; x = x + m)
                    {
                        box.center.x=x;
                        box.center.y=k * (x - st.x) + st.y;
                        MyEllipse(matIn_Out, box, color, connectivity,thickness);
                    }
                }
            }
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 MyDottedLine3col(Mat *matIn_Out,L_Point32 st,L_Point32 ed,Int32 color1,Int32 color2,Int32 color3,Int32 dis, dottedtype Mod,linetype connectivity,Int32 thickness)
    {
        switch (Mod)
        {
            case CV_DOTTEDLINE_LINE:
            {
                float n = dis; //线长度
                float w = ed.x - st.x, h = ed.y - st.y;
                float l = sqrtf(w * w + h * h);
                // 矫正线长度，使线个数为奇数
                int m = l / n;
                RotatedRect boxst,boxed;

                m = m % 2 ? m : m + 1;
                n = l / m;
                boxst.angle=0;
                boxst.center.x=st.x;
                boxst.center.y=st.y;
                boxst.size.width=1;
                boxst.size.height=1;
                boxed.angle=0;
                boxed.center.x=ed.x;
                boxed.center.y=ed.y;
                boxed.size.width=1;
                boxed.size.height=1;

                MyEllipse3col(matIn_Out, boxst, color1,color2,color3,connectivity, thickness);
                MyEllipse3col(matIn_Out, boxed, color1,color2,color3,connectivity, thickness);

                if (st.y == ed.y) //水平线：y = m
                {
                    float x1 = MIN(st.x, ed.x);
                    float x2 = MAX(st.x, ed.x);
                    float x,n1;
                    L_Point32 m_st,m_ed;
                    for (x = x1, n1 = 2 * n; x < x2; x = x + n1)
                    {
                        m_st.x=x+0.5;
                        m_st.y=st.y;
                        m_ed.x=x+n+0.5;
                        m_ed.y=st.y;
                        MyLine3col(matIn_Out,m_st,m_ed,color1,color2,color3,connectivity,thickness);
                    }
                }
                else if (st.x == ed.x) //垂直线, x = m
                {
                    float y1 = MIN(st.y, ed.y);
                    float y2 = MAX(st.y, ed.y);
                    float y,n1;
                    L_Point32 m_st,m_ed;
                    for (y = y1, n1 = 2 * n; y < y2; y = y + n1)
                    {
                        m_st.x=st.x;
                        m_st.y=y+0.5;
                        m_ed.x=st.x;
                        m_ed.y=y+n+0.5;
                        MyLine3col(matIn_Out,m_st,m_ed,color1,color2,color3,connectivity,thickness);
                    }
                }
                else // 倾斜线，与x轴、y轴都不垂直或平行
                {
                    // 直线方程的两点式：(y-y1)/(y2-y1)=(x-x1)/(x2-x1) -> y = (y2-y1)*(x-x1)/(x2-x1)+y1
                    float n1 = n * abs(w) / l;
                    float k = h / w;
                    float x1 = MIN(st.x, ed.x);
                    float x2 = MAX(st.x, ed.x);
                    float x,n2;
                    L_Point32 m_st,m_ed;
                    for (x = x1, n2 = 2 * n1; x < x2; x = x + n2)
                    {
                        m_st.x=x+0.5;
                        m_st.y=k * (x - st.x) + st.y + 0.5;
                        m_ed.x=x + n1 +0.5;
                        m_ed.y=k * (x + n1 - st.x) + st.y+0.5;
                        MyLine3col(matIn_Out,m_st,m_ed,color1,color2,color3,connectivity,thickness);
                    }
                }
            }
            break;
            case CV_DOTTEDLINE_POINT:
            {
                float n = dis;
                float w = ed.x - st.x, h = ed.y - st.y;
                float l = sqrtf(w * w + h * h);
                int m = l / n;
                RotatedRect boxst,boxed;
                RotatedRect box;

                n = l / m;
                boxst.angle=0;
                boxst.center.x=st.x;
                boxst.center.y=st.y;
                boxst.size.width=1;
                boxst.size.height=1;
                boxed.angle=0;
                boxed.center.x=ed.x;
                boxed.center.y=ed.y;
                boxed.size.width=1;
                boxed.size.height=1;
                box.angle=0;
                box.size.width=1;
                box.size.height=1;
                MyEllipse3col(matIn_Out, boxst, color1,color2,color3,connectivity, thickness);
                MyEllipse3col(matIn_Out, boxed, color1,color2,color3,connectivity, thickness);

                if (st.y == ed.y)
                {
                    float x1 = MIN(st.x, ed.x);
                    float x2 = MAX(st.x, ed.x);
                    float x;
                    for (x = x1 + n; x < x2; x = x + n)
                    {
                        box.center.x=x;
                        box.center.y=st.y;
                        MyEllipse3col(matIn_Out, box, color1,color2,color3, connectivity,thickness);
                    }
                }
                else if (st.x == ed.x)
                {
                    float y1 = MIN(st.y, ed.y);
                    float y2 = MAX(st.y, ed.y);
                    float y;
                    for (y = y1 + n; y < y2; y = y + n)
                    {
                        box.center.x=st.x;
                        box.center.y=y;
                        MyEllipse3col(matIn_Out, box, color1,color2,color3, connectivity,thickness);
                    }
                }
                else
                {
                    float m = n * abs(w) / l;
                    float k = h / w;
                    float x1 = MIN(st.x, ed.x);
                    float x2 = MAX(st.x, ed.x);
                    float x;
                    for (x = x1 + m; x < x2; x = x + m)
                    {
                        box.center.x=x;
                        box.center.y=k * (x - st.x) + st.y;
                        MyEllipse3col(matIn_Out, box, color1,color2,color3, connectivity,thickness);
                    }
                }
            }
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    void sincos( Int32 angle, float *cosval, float *sinval)
    {
        angle += (angle < 0 ? 360 : 0);
        *sinval = SinTable[angle];
        *cosval = SinTable[450 - angle];
    }

    void ellipse2Poly(L_Point32 center,L_Size32 axes,Int32 angle,Int32 arc_start,Int32 arc_end,Int32 delta,L_Point32 *pts, Int32 *pts_size)
    {
        float alpha, beta;
        double size_a = axes.width, size_b = axes.height;
        double cx = center.x, cy = center.y;
        L_Point32 prevPt;
        Int32 i;

        prevPt.x=INT_MIN;
        prevPt.y=INT_MIN;
        *pts_size = 0;

        while( angle < 0 )
            angle += 360;
        while( angle > 360 )
            angle -= 360;

        if( arc_start > arc_end )
        {
            i = arc_start;
            arc_start = arc_end;
            arc_end = i;
        }
        while( arc_start < 0 )
        {
            arc_start += 360;
            arc_end += 360;
        }
        while( arc_end > 360 )
        {
            arc_end -= 360;
            arc_start -= 360;
        }
        if( arc_end - arc_start > 360 )
        {
            arc_start = 0;
            arc_end = 360;
        }
        sincos( angle, &alpha, &beta );

        for( i = arc_start; i < arc_end + delta; i += delta )
        {
            double x, y;
            L_Point32 pt;

            angle = i;
            if( angle > arc_end )
                angle = arc_end;
            if( angle < 0 )
                angle += 360;

            x = size_a * SinTable[450-angle];
            y = size_b * SinTable[angle];

            pt.x = ( cx + x * alpha - y * beta +0.5);
            pt.y = ( cy + x * beta + y * alpha +0.5);
            if( pt.x!=prevPt.x&&pt.y!= prevPt.y){
                pts[*pts_size]=pt;
                prevPt = pt;
                (*pts_size)++;
            }
        }
    }

    void ThickLine( Mat *img, L_Point32 p0, L_Point32 p1, Int32 color,Int32 thickness, linetype line_type, Int32 flags, Int32 shift )
    {
        static const double INV_XY_ONE = 1./XY_ONE;

        p0.x <<= XY_SHIFT - shift;
        p0.y <<= XY_SHIFT - shift;
        p1.x <<= XY_SHIFT - shift;
        p1.y <<= XY_SHIFT - shift;

        if( thickness <= 1 )
        {
            p0.x = (p0.x + (XY_ONE>>1)) >> XY_SHIFT;
            p0.y = (p0.y + (XY_ONE>>1)) >> XY_SHIFT;
            p1.x = (p1.x + (XY_ONE>>1)) >> XY_SHIFT;
            p1.y = (p1.y + (XY_ONE>>1)) >> XY_SHIFT;
            Line( img, p0, p1, color, line_type );
        }
        else
        {
            L_Point32 pt[4], dp;
            double dx,dy,r;
            Int32 i, oddThickness;

            dp.x=0;
            dp.y=0;
            dx = (p0.x - p1.x)*INV_XY_ONE, dy = (p1.y - p0.y)*INV_XY_ONE;
            r = dx * dx + dy * dy;
            oddThickness = thickness & 1;
            thickness <<= XY_SHIFT - 1;

            if( fabs(r) > DBL_EPSILON )
            {
                r = (thickness + oddThickness*XY_ONE*0.5)/sqrt(r);
                dp.x = dy * r +0.5;
                dp.y = dx * r +0.5;

                pt[0].x = p0.x + dp.x;
                pt[0].y = p0.y + dp.y;
                pt[1].x = p0.x - dp.x;
                pt[1].y = p0.y - dp.y;
                pt[2].x = p1.x - dp.x;
                pt[2].y = p1.y - dp.y;
                pt[3].x = p1.x + dp.x;
                pt[3].y = p1.y + dp.y;

                FillConvexPoly( img, pt, 4, color, line_type, XY_SHIFT );
            }

            for( i = 0; i < 2; i++ )
            {
                if( flags & (i+1) )
                {
                    L_Point32 center;
                    center.x = (p0.x + (XY_ONE>>1)) >> XY_SHIFT;
                    center.y = (p0.y + (XY_ONE>>1)) >> XY_SHIFT;
                    Circle( img, center, (thickness + (XY_ONE>>1)) >> XY_SHIFT, color, 1 );
                }
                p0 = p1;
            }
        }
    }

    void ThickLine3col( Mat *img, L_Point32 p0, L_Point32 p1, Int32 color1,Int32 color2,Int32 color3,Int32 thickness, linetype line_type, Int32 flags, Int32 shift )
    {
        static const double INV_XY_ONE = 1./XY_ONE;

        p0.x <<= XY_SHIFT - shift;
        p0.y <<= XY_SHIFT - shift;
        p1.x <<= XY_SHIFT - shift;
        p1.y <<= XY_SHIFT - shift;

        if( thickness <= 1 )
        {
            p0.x = (p0.x + (XY_ONE>>1)) >> XY_SHIFT;
            p0.y = (p0.y + (XY_ONE>>1)) >> XY_SHIFT;
            p1.x = (p1.x + (XY_ONE>>1)) >> XY_SHIFT;
            p1.y = (p1.y + (XY_ONE>>1)) >> XY_SHIFT;
            Line3col( img, p0, p1, color1,color2,color3,line_type);
        }
        else
        {
            L_Point32 pt[4], dp;
            double dx,dy,r;
            Int32 i, oddThickness;

            dp.x=0;
            dp.y=0;
            dx = (p0.x - p1.x)*INV_XY_ONE, dy = (p1.y - p0.y)*INV_XY_ONE;
            r = dx * dx + dy * dy;
            oddThickness = thickness & 1;
            thickness <<= XY_SHIFT - 1;

            if( fabs(r) > DBL_EPSILON )
            {
                r = (thickness + oddThickness*XY_ONE*0.5)/sqrt(r);
                dp.x = dy * r +0.5;
                dp.y = dx * r +0.5;

                pt[0].x = p0.x + dp.x;
                pt[0].y = p0.y + dp.y;
                pt[1].x = p0.x - dp.x;
                pt[1].y = p0.y - dp.y;
                pt[2].x = p1.x - dp.x;
                pt[2].y = p1.y - dp.y;
                pt[3].x = p1.x + dp.x;
                pt[3].y = p1.y + dp.y;

                FillConvexPoly3col(img,pt,4,color1,color2,color3,line_type,XY_SHIFT);
            }

            for( i = 0; i < 2; i++ )
            {
                if( flags & (i+1) )
                {
                    L_Point32 center;
                    center.x = (p0.x + (XY_ONE>>1)) >> XY_SHIFT;
                    center.y = (p0.y + (XY_ONE>>1)) >> XY_SHIFT;
                    Circle3col(img,center,(thickness + (XY_ONE>>1)) >> XY_SHIFT,color1,color2,color3,1);
                }
                p0 = p1;
            }
        }
    }

    void ThickLinePoint( Mat *img, L_Point32 p0, L_Point32 p1,Int32 thickness, linetype line_type, Int32 flags, Int32 shift,L_Point *buffer,Int32 *buffernum)
    {
        static const double INV_XY_ONE = 1./XY_ONE;

        p0.x <<= XY_SHIFT - shift;
        p0.y <<= XY_SHIFT - shift;
        p1.x <<= XY_SHIFT - shift;
        p1.y <<= XY_SHIFT - shift;

        if( thickness <= 1 )
        {
            p0.x = (p0.x + (XY_ONE>>1)) >> XY_SHIFT;
            p0.y = (p0.y + (XY_ONE>>1)) >> XY_SHIFT;
            p1.x = (p1.x + (XY_ONE>>1)) >> XY_SHIFT;
            p1.y = (p1.y + (XY_ONE>>1)) >> XY_SHIFT;
            LinePoint2( img, p0, p1, line_type,buffer,buffernum);
        }
        else
        {
            L_Point32 pt[4], dp;
            double dx,dy,r;
            Int32 i, oddThickness;

            dp.x=0;
            dp.y=0;
            dx = (p0.x - p1.x)*INV_XY_ONE, dy = (p1.y - p0.y)*INV_XY_ONE;
            r = dx * dx + dy * dy;
            oddThickness = thickness & 1;
            thickness <<= XY_SHIFT - 1;

            if( fabs(r) > DBL_EPSILON )
            {
                r = (thickness + oddThickness*XY_ONE*0.5)/sqrt(r);
                dp.x = dy * r +0.5;
                dp.y = dx * r +0.5;

                pt[0].x = p0.x + dp.x;
                pt[0].y = p0.y + dp.y;
                pt[1].x = p0.x - dp.x;
                pt[1].y = p0.y - dp.y;
                pt[2].x = p1.x - dp.x;
                pt[2].y = p1.y - dp.y;
                pt[3].x = p1.x + dp.x;
                pt[3].y = p1.y + dp.y;

                FillConvexPolyPoint(img,pt,4,line_type,XY_SHIFT,buffer,buffernum);
            }

            for( i = 0; i < 2; i++ )
            {
                if( flags & (i+1) )
                {
                    L_Point32 center;
                    center.x = (p0.x + (XY_ONE>>1)) >> XY_SHIFT;
                    center.y = (p0.y + (XY_ONE>>1)) >> XY_SHIFT;
                    CirclePoint(img,center,(thickness + (XY_ONE>>1)) >> XY_SHIFT,1,buffer,buffernum,1);
                }
                p0 = p1;
            }
        }
    }

    void PolyLine( Mat *img, L_Point32 *v,Int32 count,Uint8 is_closed,Int32 color,Int32 thickness,linetype line_type,Int32 shift)
    {
        Int32 i;
        Int32 flags = 2 + !is_closed;
        L_Point32 p0;

        if( !v || count <= 0 )
            return;

        i = is_closed ? count - 1 : 0;
        p0 = v[i];
        for( i = !is_closed; i < count; i++ )
        {
            L_Point32 p = v[i];
            ThickLine( img, p0, p, color, thickness, line_type, flags, shift );
            p0 = p;
            flags = 2;
        }
    }

    void PolyLine3col( Mat *img, L_Point32 *v,Int32 count,Uint8 is_closed,Int32 color1,Int32 color2,Int32 color3,Int32 thickness,linetype line_type,Int32 shift)
    {
        Int32 i;
        Int32 flags = 2 + !is_closed;
        L_Point32 p0;

        if( !v || count <= 0 )
            return;

        i = is_closed ? count - 1 : 0;
        p0 = v[i];
        for( i = !is_closed; i < count; i++ )
        {
            L_Point32 p = v[i];
            ThickLine3col(img,p0,p,color1,color2,color3,thickness,line_type,flags,shift);
            p0 = p;
            flags = 2;
        }
    }

    void PolyLinePoint( Mat *img, L_Point32 *v,Int32 count,Uint8 is_closed,Int32 thickness,linetype line_type,Int32 shift,L_Point *buffer,Int32 *buffernum)
    {
        Int32 i;
        Int32 flags = 2 + !is_closed;
        L_Point32 p0;

        if( !v || count <= 0 )
            return;

        i = is_closed ? count - 1 : 0;
        p0 = v[i];
        for( i = !is_closed; i < count; i++ )
        {
            L_Point32 p = v[i];
            ThickLinePoint( img, p0, p, thickness, line_type, flags, shift,buffer,buffernum);
            p0 = p;
            flags = 2;
        }
    }

    Int32 CmpEdges(const void * e1, const void * e2)
    {
        return (*(PolyEdge*)e1).y0 - (*(PolyEdge*)e2).y0 ? (*(PolyEdge*)e1).y0 < (*(PolyEdge*)e2).y0 :
                (*(PolyEdge*)e1).x - (*(PolyEdge*)e2).x ? (*(PolyEdge*)e1).x < (*(PolyEdge*)e2).x : (*(PolyEdge*)e1).dx < (*(PolyEdge*)e2).dx;
    }

    void FillEdgeCollection( Mat *img, PolyEdge* edges,Int32 edges_size, Int32 color )
    {
        PolyEdge tmp;
        Uint32 nnWidth=img->nWidth;
        Uint32 nnHeight=img->nHeight;
        Int32 i, y, total = edges_size;
        L_Size32 size;
        PolyEdge* e;
        Int32 y_max = INT_MIN, x_max = INT_MIN, y_min = INT_MAX, x_min = INT_MAX;
        Int32 pix_size = getsizeof(img->_type);
        Int32 step = getsizeof(img->_type)*nnWidth;

        size.height=nnHeight;
        size.width=nnWidth;
        if( total < 2 )
            return;
        for( i = 0; i < total; i++ )
        {
            PolyEdge *e1 = &(edges[i]);
            Int32 x1 = e1->x + (e1->y1 - e1->y0) * e1->dx;
            y_min = MIN( y_min, e1->y0 );
            y_max = MAX( y_max, e1->y1 );
            x_min = MIN( x_min, e1->x );
            x_max = MAX( x_max, e1->x );
            x_min = MIN( x_min, x1 );
            x_max = MAX( x_max, x1 );
        }
        if( y_max < 0 || y_min >= size.height || x_max < 0 || x_min >= (size.width<<XY_SHIFT) )
            return;

        qsort(edges,edges_size,sizeof(edges[0]),CmpEdges);
        tmp.y0 = INT_MAX;
        edges[edges_size]=tmp;
        edges_size++;

        i = 0;
        tmp.next = 0;
        e = &edges[i];
        y_max = MIN( y_max, size.height );

        for( y = e->y0; y < y_max; y++ )
        {
            PolyEdge *last, *prelast, *keep_prelast;
            Int32 sort_flag = 0;
            Int32 draw = 0;
            Int32 clipline = y < 0;

            prelast = &tmp;
            last = tmp.next;
            while( last || e->y0 == y )
            {
                if( last && last->y1 == y )
                {
                    prelast->next = last->next;
                    last = last->next;
                    continue;
                }
                keep_prelast = prelast;
                if( last && (e->y0 > y || last->x < e->x) )
                {
                    prelast = last;
                    last = last->next;
                }
                else if( i < total )
                {
                    prelast->next = e;
                    e->next = last;
                    prelast = e;
                    e = &edges[++i];
                }
                else
                    break;

                if( draw )
                {
                    if( !clipline )
                    {
                        Uint8 *timg = img->data + y * step;
                        Int32 x1 = keep_prelast->x;
                        Int32 x2 = prelast->x;

                        if( x1 > x2 )
                        {
                            Int32 t = x1;

                            x1 = x2;
                            x2 = t;
                        }

                        x1 = (x1 + XY_ONE - 1) >> XY_SHIFT;
                        x2 = x2 >> XY_SHIFT;

                        // clip and draw the line
                        if( x1 < size.width && x2 >= 0 )
                        {
                            if( x1 < 0 )
                                x1 = 0;
                            if( x2 >= size.width )
                                x2 = size.width - 1;
                            ICV_HLINE( timg, x1, x2, color, pix_size );
                        }
                    }
                    keep_prelast->x += keep_prelast->dx;
                    prelast->x += prelast->dx;
                }
                draw ^= 1;
            }

            // sort edges (using bubble sort)
            keep_prelast = 0;

            do
            {
                prelast = &tmp;
                last = tmp.next;

                while( last != keep_prelast && last->next != 0 )
                {
                    PolyEdge *te = last->next;

                    // swap edges
                    if( last->x > te->x )
                    {
                        prelast->next = te;
                        last->next = te->next;
                        te->next = last;
                        prelast = te;
                        sort_flag = 1;
                    }
                    else
                    {
                        prelast = last;
                        last = te;
                    }
                }
                keep_prelast = prelast;
            }
            while( sort_flag && keep_prelast != tmp.next && keep_prelast != &tmp );
        }
    }

    void FillEdgeCollection3col( Mat *img, PolyEdge* edges,Int32 edges_size, Int32 color1,Int32 color2,Int32 color3 )
    {
        PolyEdge tmp;
        Uint32 nnWidth=img->nWidth;
        Uint32 nnHeight=img->nHeight;
        Int32 i, y, total = edges_size;
        L_Size32 size;
        PolyEdge* e;
        Int32 y_max = INT_MIN, x_max = INT_MIN, y_min = INT_MAX, x_min = INT_MAX;
        Int32 pix_size = getsizeof(img->_type);
        Int32 step = getsizeof(img->_type)*nnWidth;

        size.height=nnHeight;
        size.width=nnWidth;
        if( total < 2 )
            return;
        for( i = 0; i < total; i++ )
        {
            PolyEdge *e1 = &(edges[i]);
            Int32 x1 = e1->x + (e1->y1 - e1->y0) * e1->dx;
            y_min = MIN( y_min, e1->y0 );
            y_max = MAX( y_max, e1->y1 );
            x_min = MIN( x_min, e1->x );
            x_max = MAX( x_max, e1->x );
            x_min = MIN( x_min, x1 );
            x_max = MAX( x_max, x1 );
        }
        if( y_max < 0 || y_min >= size.height || x_max < 0 || x_min >= (size.width<<XY_SHIFT) )
            return;

        qsort(edges,edges_size,sizeof(edges[0]),CmpEdges);
        tmp.y0 = INT_MAX;
        edges[edges_size]=tmp;
        edges_size++;

        i = 0;
        tmp.next = 0;
        e = &edges[i];
        y_max = MIN( y_max, size.height );

        for( y = e->y0; y < y_max; y++ )
        {
            PolyEdge *last, *prelast, *keep_prelast;
            Int32 sort_flag = 0;
            Int32 draw = 0;
            Int32 clipline = y < 0;

            prelast = &tmp;
            last = tmp.next;
            while( last || e->y0 == y )
            {
                if( last && last->y1 == y )
                {
                    // exclude edge if y reachs its lower point
                    prelast->next = last->next;
                    last = last->next;
                    continue;
                }
                keep_prelast = prelast;
                if( last && (e->y0 > y || last->x < e->x) )
                {
                    // go to the next edge in active list
                    prelast = last;
                    last = last->next;
                }
                else if( i < total )
                {
                    // insert new edge into active list if y reachs its upper point
                    prelast->next = e;
                    e->next = last;
                    prelast = e;
                    e = &edges[++i];
                }
                else
                    break;

                if( draw )
                {
                    if( !clipline )
                    {
                        Uint8 *timg = img->data + y * step;
                        Int32 x1 = keep_prelast->x;
                        Int32 x2 = prelast->x;

                        if( x1 > x2 )
                        {
                            Int32 t = x1;

                            x1 = x2;
                            x2 = t;
                        }

                        x1 = (x1 + XY_ONE - 1) >> XY_SHIFT;
                        x2 = x2 >> XY_SHIFT;

                        // clip and draw the line
                        if( x1 < size.width && x2 >= 0 )
                        {
                            if( x1 < 0 )
                                x1 = 0;
                            if( x2 >= size.width )
                                x2 = size.width - 1;
                            ICV_HLINE3COL( timg, x1, x2, color1,color2,color3, pix_size );
                        }
                    }
                    keep_prelast->x += keep_prelast->dx;
                    prelast->x += prelast->dx;
                }
                draw ^= 1;
            }

            // sort edges (using bubble sort)
            keep_prelast = 0;

            do
            {
                prelast = &tmp;
                last = tmp.next;

                while( last != keep_prelast && last->next != 0 )
                {
                    PolyEdge *te = last->next;

                    // swap edges
                    if( last->x > te->x )
                    {
                        prelast->next = te;
                        last->next = te->next;
                        te->next = last;
                        prelast = te;
                        sort_flag = 1;
                    }
                    else
                    {
                        prelast = last;
                        last = te;
                    }
                }
                keep_prelast = prelast;
            }
            while( sort_flag && keep_prelast != tmp.next && keep_prelast != &tmp );
        }
    }

    void FillEdgeCollectionPoint( Mat *img, PolyEdge* edges,Int32 edges_size,L_Point *buffer,Int32 *buffernum)
    {
        PolyEdge tmp;
        Uint32 nnWidth=img->nWidth;
        Uint32 nnHeight=img->nHeight;
        Int32 i, y, total = edges_size;
        L_Size32 size;
        PolyEdge* e;
        Int32 y_max = INT_MIN, x_max = INT_MIN, y_min = INT_MAX, x_min = INT_MAX;
        Int32 pix_size = getsizeof(img->_type);
        Int32 step = getsizeof(img->_type)*nnWidth;

        size.height=nnHeight;
        size.width=nnWidth;
        if( total < 2 )
            return;
        for( i = 0; i < total; i++ )
        {
            PolyEdge *e1 = &(edges[i]);
            Int32 x1 = e1->x + (e1->y1 - e1->y0) * e1->dx;
            y_min = MIN( y_min, e1->y0 );
            y_max = MAX( y_max, e1->y1 );
            x_min = MIN( x_min, e1->x );
            x_max = MAX( x_max, e1->x );
            x_min = MIN( x_min, x1 );
            x_max = MAX( x_max, x1 );
        }
        if( y_max < 0 || y_min >= size.height || x_max < 0 || x_min >= (size.width<<XY_SHIFT) )
            return;

        qsort(edges,edges_size,sizeof(edges[0]),CmpEdges);
        tmp.y0 = INT_MAX;
        edges[edges_size]=tmp;
        edges_size++;

        i = 0;
        tmp.next = 0;
        e = &edges[i];
        y_max = MIN( y_max, size.height );

        for( y = e->y0; y < y_max; y++ )
        {
            PolyEdge *last, *prelast, *keep_prelast;
            Int32 sort_flag = 0;
            Int32 draw = 0;
            Int32 clipline = y < 0;

            prelast = &tmp;
            last = tmp.next;
            while( last || e->y0 == y )
            {
                if( last && last->y1 == y )
                {
                    // exclude edge if y reachs its lower point
                    prelast->next = last->next;
                    last = last->next;
                    continue;
                }
                keep_prelast = prelast;
                if( last && (e->y0 > y || last->x < e->x) )
                {
                    // go to the next edge in active list
                    prelast = last;
                    last = last->next;
                }
                else if( i < total )
                {
                    // insert new edge into active list if y reachs its upper point
                    prelast->next = e;
                    e->next = last;
                    prelast = e;
                    e = &edges[++i];
                }
                else
                    break;

                if( draw )
                {
                    if( !clipline )
                    {
                        Int32 x1 = keep_prelast->x;
                        Int32 x2 = prelast->x;

                        if( x1 > x2 )
                        {
                            Int32 t = x1;

                            x1 = x2;
                            x2 = t;
                        }

                        x1 = (x1 + XY_ONE - 1) >> XY_SHIFT;
                        x2 = x2 >> XY_SHIFT;

                        // clip and draw the line
                        if( x1 < size.width && x2 >= 0 )
                        {
                            Int32 di;
                            if( x1 < 0 )
                                x1 = 0;
                            if( x2 >= size.width )
                                x2 = size.width - 1;
                            for(di=x1;di<=x1;di++)
                            {
                                buffer[(*buffernum)].x=(Uint16)di;
                                buffer[(*buffernum)++].y=(Uint16)y;
                            }
                        }
                    }
                    keep_prelast->x += keep_prelast->dx;
                    prelast->x += prelast->dx;
                }
                draw ^= 1;
            }

            // sort edges (using bubble sort)
            keep_prelast = 0;

            do
            {
                prelast = &tmp;
                last = tmp.next;

                while( last != keep_prelast && last->next != 0 )
                {
                    PolyEdge *te = last->next;

                    // swap edges
                    if( last->x > te->x )
                    {
                        prelast->next = te;
                        last->next = te->next;
                        te->next = last;
                        prelast = te;
                        sort_flag = 1;
                    }
                    else
                    {
                        prelast = last;
                        last = te;
                    }
                }
                keep_prelast = prelast;
            }
            while( sort_flag && keep_prelast != tmp.next && keep_prelast != &tmp );
        }
    }

    void CollectPolyEdges(Mat *img,L_Point32 *v,Int32 count,PolyEdge *edges,Int32 *edges_count,Int32 color,linetype line_type,Int32 shift,L_Point32 offset)
    {
        Int32 i, delta = offset.y + (shift ? 1 << (shift - 1) : 0);
        L_Point32 pt0 = v[count-1], pt1;
        pt0.x = (pt0.x + offset.x) << (XY_SHIFT - shift);
        pt0.y = (pt0.y + delta) >> shift;

        *edges_count=0;

        for( i = 0; i < count; i++, pt0 = pt1 )
        {
            L_Point32 t0, t1;
            PolyEdge edge;

            pt1 = v[i];
            pt1.x = (pt1.x + offset.x) << (XY_SHIFT - shift);
            pt1.y = (pt1.y + delta) >> shift;

            t0.y = pt0.y; t1.y = pt1.y;
            t0.x = (pt0.x + (XY_ONE >> 1)) >> XY_SHIFT;
            t1.x = (pt1.x + (XY_ONE >> 1)) >> XY_SHIFT;
            Line( img, t0, t1, color, line_type );

            if( pt0.y == pt1.y )
                continue;

            if( pt0.y < pt1.y )
            {
                edge.y0 = pt0.y;
                edge.y1 = pt1.y;
                edge.x = pt0.x;
            }
            else
            {
                edge.y0 = pt1.y;
                edge.y1 = pt0.y;
                edge.x = pt1.x;
            }
            edge.dx = (pt1.x - pt0.x) / (pt1.y - pt0.y);
            edges[*edges_count]=edge;
            *edges_count++;
        }
    }

    void CollectPolyEdgesPoint(Mat *img,L_Point32 *v,Int32 count,PolyEdge *edges,Int32 *edges_count,linetype line_type,Int32 shift,L_Point32 offset,L_Point *buffer,Int32 *buffernum)
    {
        Int32 i, delta = offset.y + (shift ? 1 << (shift - 1) : 0);
        L_Point32 pt0 = v[count-1], pt1;
        pt0.x = (pt0.x + offset.x) << (XY_SHIFT - shift);
        pt0.y = (pt0.y + delta) >> shift;

        *edges_count=0;

        for( i = 0; i < count; i++, pt0 = pt1 )
        {
            L_Point32 t0, t1;
            PolyEdge edge;

            pt1 = v[i];
            pt1.x = (pt1.x + offset.x) << (XY_SHIFT - shift);
            pt1.y = (pt1.y + delta) >> shift;

            t0.y = pt0.y; t1.y = pt1.y;
            t0.x = (pt0.x + (XY_ONE >> 1)) >> XY_SHIFT;
            t1.x = (pt1.x + (XY_ONE >> 1)) >> XY_SHIFT;
            LinePoint( img, t0, t1, line_type,buffer,buffernum);

            if( pt0.y == pt1.y )
                continue;

            if( pt0.y < pt1.y )
            {
                edge.y0 = pt0.y;
                edge.y1 = pt1.y;
                edge.x = pt0.x;
            }
            else
            {
                edge.y0 = pt1.y;
                edge.y1 = pt0.y;
                edge.x = pt1.x;
            }
            edge.dx = (pt1.x - pt0.x) / (pt1.y - pt0.y);
            edges[*edges_count]=edge;
            *edges_count++;
        }
    }

    void CollectPolyEdges3col(Mat *img,L_Point32 *v,Int32 count,PolyEdge *edges,Int32 *edges_count,Int32 color1,Int32 color2,Int32 color3,linetype line_type,Int32 shift,L_Point32 offset)
    {
        Int32 i, delta = offset.y + (shift ? 1 << (shift - 1) : 0);
        L_Point32 pt0 = v[count-1], pt1;
        pt0.x = (pt0.x + offset.x) << (XY_SHIFT - shift);
        pt0.y = (pt0.y + delta) >> shift;

        *edges_count=0;

        for( i = 0; i < count; i++, pt0 = pt1 )
        {
            L_Point32 t0, t1;
            PolyEdge edge;

            pt1 = v[i];
            pt1.x = (pt1.x + offset.x) << (XY_SHIFT - shift);
            pt1.y = (pt1.y + delta) >> shift;

            t0.y = pt0.y; t1.y = pt1.y;
            t0.x = (pt0.x + (XY_ONE >> 1)) >> XY_SHIFT;
            t1.x = (pt1.x + (XY_ONE >> 1)) >> XY_SHIFT;
            Line3col( img, t0, t1, color1,color2,color3, line_type );

            if( pt0.y == pt1.y )
                continue;

            if( pt0.y < pt1.y )
            {
                edge.y0 = pt0.y;
                edge.y1 = pt1.y;
                edge.x = pt0.x;
            }
            else
            {
                edge.y0 = pt1.y;
                edge.y1 = pt0.y;
                edge.x = pt1.x;
            }
            edge.dx = (pt1.x - pt0.x) / (pt1.y - pt0.y);
            edges[*edges_count]=edge;
            *edges_count++;
        }
    }

    void Ellipse(Mat *img,L_Point32 center,L_Size32 axes,Int32 angle,Int32 arc_start, Int32 arc_end,Int32 color,Int32 thickness,linetype line_type)
    {
        Int32 delta;
        L_Point32 *v=(L_Point32*)u8_buffer_x3Temp1;
        PolyEdge *edges=(PolyEdge*)u8_buffer_x1Temp2;
        Int32 v_size=0;
        Int32 edges_size=0;

        axes.width = abs(axes.width), axes.height = abs(axes.height);
        delta = (MAX(axes.width,axes.height)+(XY_ONE>>1))>>XY_SHIFT;
        delta = delta < 3 ? 90 : delta < 10 ? 30 : delta < 15 ? 18 : 5;

        ellipse2Poly( center, axes, angle, arc_start, arc_end, delta, v ,&v_size);

        if( thickness >= 0 )
            PolyLine( img, &v[0], v_size, FALSE, color, thickness, line_type, XY_SHIFT );
        else if( arc_end - arc_start >= 360 )
            FillConvexPoly( img, &v[0], v_size, color, line_type, XY_SHIFT );
        else
        {
            L_Point32 offset;
            offset.x=0;
            offset.y=0;
            v[v_size]=center;
            v_size++;
            CollectPolyEdges( img,  &v[0], v_size, edges,&edges_size, color, line_type, XY_SHIFT,offset);
            FillEdgeCollection( img, edges,edges_size, color );
        }
    }

    void Ellipse3col(Mat *img,L_Point32 center,L_Size32 axes,Int32 angle,Int32 arc_start, Int32 arc_end,Int32 color1,Int32 color2,Int32 color3,Int32 thickness,linetype line_type)
    {
        Int32 delta;
        L_Point32 *v=(L_Point32*)u8_buffer_x3Temp1;
        PolyEdge *edges=(PolyEdge*)u8_buffer_x1Temp2;
        Int32 v_size=0;
        Int32 edges_size=0;

        axes.width = abs(axes.width), axes.height = abs(axes.height);
        delta = (MAX(axes.width,axes.height)+(XY_ONE>>1))>>XY_SHIFT;
        delta = delta < 3 ? 90 : delta < 10 ? 30 : delta < 15 ? 18 : 5;

        ellipse2Poly( center, axes, angle, arc_start, arc_end, delta, v ,&v_size);

        if( thickness >= 0 )
            PolyLine3col(img,&v[0],v_size,FALSE,color1,color2,color3,thickness,line_type,XY_SHIFT);
        else if( arc_end - arc_start >= 360 )
            FillConvexPoly3col(img,&v[0],v_size,color1,color2,color3,line_type,XY_SHIFT);
        else
        {
            L_Point32 offset;
            offset.x=0;
            offset.y=0;
            v[v_size]=center;
            v_size++;
            CollectPolyEdges3col( img,  &v[0], v_size, edges,&edges_size,color1,color2,color3,line_type,XY_SHIFT,offset);
            FillEdgeCollection3col( img, edges,edges_size, color1,color2,color3 );
        }
    }

    Int8 MyEllipse(Mat *matIn_Out,RotatedRect box,Int32 color,linetype line_type,Int32 thickness)
    {
        L_Size32 size;
        L_Point32 center;
        Int32 _angle = box.angle+0.5;

        size.width=box.size.width*(1 << XY_SHIFT)+0.5;
        size.height=box.size.height*(1 << XY_SHIFT)+0.5;
        center.x=box.center.x*(1 << XY_SHIFT)+0.5;
        center.y=box.center.y*(1 << XY_SHIFT)+0.5;

        switch(matIn_Out->_type)
        {
            case CCV_8UC1:
                Ellipse( matIn_Out, center,size,_angle,0,360,color,thickness,line_type);
            break;
            case CCV_8UC3:
                Ellipse3col( matIn_Out, center,size,_angle,0,360,color,color,color,thickness,line_type);
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 MyEllipse3col(Mat *matIn_Out,RotatedRect box,Int32 color1,Int32 color2,Int32 color3,linetype line_type,Int32 thickness)
    {
        L_Size32 size;
        L_Point32 center;
        Int32 _angle = box.angle+0.5;
        Int32 color;

        size.width=box.size.width*(1 << XY_SHIFT)+0.5;
        size.height=box.size.height*(1 << XY_SHIFT)+0.5;
        center.x=box.center.x*(1 << XY_SHIFT)+0.5;
        center.y=box.center.y*(1 << XY_SHIFT)+0.5;

        switch(matIn_Out->_type)
        {
            case CCV_8UC1:
                color=(color1+color2+color3)/3;
                Ellipse( matIn_Out, center,size,_angle,0,360,color,thickness,line_type);
            break;
            case CCV_8UC3:
                Ellipse3col( matIn_Out, center,size,_angle,0,360,color1,color2,color3,thickness,line_type);
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    void EllipsePoint(Mat *img,L_Point32 center,L_Size32 axes,Int32 angle,Int32 arc_start, Int32 arc_end,Int32 thickness,linetype line_type,L_Point *buffer,Int32 *buffernum)
    {
        Int32 delta;
        L_Point32 *v=(L_Point32*)u8_buffer_x3Temp1;
        PolyEdge *edges=(PolyEdge*)u8_buffer_x1Temp2;
        Int32 v_size=0;
        Int32 edges_size=0;

        axes.width = abs(axes.width), axes.height = abs(axes.height);
        delta = (MAX(axes.width,axes.height)+(XY_ONE>>1))>>XY_SHIFT;
        delta = delta < 3 ? 90 : delta < 10 ? 30 : delta < 15 ? 18 : 5;

        ellipse2Poly( center, axes, angle, arc_start, arc_end, delta, v ,&v_size);

        if( thickness >= 0 )
            PolyLinePoint(img,&v[0],v_size,FALSE,thickness,line_type,XY_SHIFT,buffer,buffernum);
        else if( arc_end - arc_start >= 360 )
            FillConvexPolyPoint(img,&v[0],v_size,line_type,XY_SHIFT,buffer,buffernum);
        else
        {
            L_Point32 offset;
            offset.x=0;
            offset.y=0;
            v[v_size]=center;
            v_size++;
            CollectPolyEdgesPoint(img,&v[0],v_size,edges,&edges_size,line_type,XY_SHIFT,offset,buffer,buffernum);
            FillEdgeCollectionPoint( img, edges,edges_size,buffer,buffernum);
        }
    }

    Int8 MyEllipsePoint(Mat *img,RotatedRect box,linetype line_type,Int32 thickness,L_Point *buffer,Int32 *buffernum)
    {
        L_Size32 size;
        L_Point32 center;
        Int32 _angle = box.angle+0.5;

        *buffernum=0;
        size.width=box.size.width*(1 << XY_SHIFT)+0.5;
        size.height=box.size.height*(1 << XY_SHIFT)+0.5;
        center.x=box.center.x*(1 << XY_SHIFT)+0.5;
        center.y=box.center.y*(1 << XY_SHIFT)+0.5;

        EllipsePoint(img,center,size,_angle,0,360,thickness,line_type,buffer,buffernum);
        return 0;
    }

    //从大到小排序
    void QuickSortA(mhc_hou_lineinfo a[],Int32 numsize)
    {
        Int32 i=0,j=numsize-1;
        mhc_hou_lineinfo val=a[0];
        if(numsize>1)
        {
            while(i<j)
            {
                for(;j>i;j--)
                    if(a[j].maxlongsize>val.maxlongsize)
                {
                    a[i]=a[j];
                    break;
                }

                for(;i<j;i++)
                    if(a[i].maxlongsize<val.maxlongsize)
                {
                    a[j]=a[i];
                    break;
                }
            }
            a[i]=val;
            QuickSortA(a,i);
            QuickSortA(a+i+1,numsize-1-i);
        }
    }

    void QuickSortB(Mypaixu a[],Int32 numsize)
    {
        Int32 i=0,j=numsize-1;
        Mypaixu val=a[0];
        if(numsize>1)
        {
            while(i<j)
            {
                for(;j>i;j--)
                    if(a[j].value>val.value)
                {
                    a[i]=a[j];
                    break;
                }

                for(;i<j;i++)
                    if(a[i].value<val.value)
                {
                    a[j]=a[i];
                    break;
                }
            }
            a[i]=val;
            QuickSortB(a,i);
            QuickSortB(a+i+1,numsize-1-i);
        }
    }

    void QuickSortC(Mypaixu a[],Int32 numsize)
    {
        Int32 i=0,j=numsize-1;
        Mypaixu val=a[0];
        if(numsize>1)
        {
            while(i<j)
            {

                for(;j>i;j--)
                    if(a[j].value<val.value)
                {
                    a[i]=a[j];
                    break;
                }

                for(;i<j;i++)
                    if(a[i].value>val.value)
                {
                    a[j]=a[i];
                    break;
                }
            }
            a[i]=val;
            QuickSortC(a,i);
            QuickSortC(a+i+1,numsize-1-i);
        }
    }

    void u8_QuickSortC(Uint8 a[],Int32 numsize)
    {
        Int32 i=0,j=numsize-1;
        Uint8 val=a[0];
        if(numsize>1)
        {
            while(i<j)
            {

                for(;j>i;j--)
                    if(a[j]<val)
                {
                    a[i]=a[j];
                    break;
                }

                for(;i<j;i++)
                    if(a[i]>val)
                {
                    a[j]=a[i];
                    break;
                }
            }
            a[i]=val;
            u8_QuickSortC(a,i);
            u8_QuickSortC(a+i+1,numsize-1-i);
        }
    }

    void QuickSortVer2v_ver1X(Vec2v a[],Int32 numsize)
    {
        Int32 i=0,j=numsize-1;
        Vec2v val=a[0];
        if(numsize>1)
        {
            while(i<j)
            {
                for(;j>i;j--)
                    if(a[j].vec1.x>val.vec1.x)
                {
                    a[i]=a[j];
                    break;
                }

                for(;i<j;i++)
                    if(a[i].vec1.x<val.vec1.x)
                {
                    a[j]=a[i];
                    break;
                }
            }
            a[i]=val;
            QuickSortVer2v_ver1X(a,i);
            QuickSortVer2v_ver1X(a+i+1,numsize-1-i);
        }
    }

    void QuickSortVer2v_ver1Y(Vec2v a[],Int32 numsize)
    {
        Int32 i=0,j=numsize-1;
        Vec2v val=a[0];
        if(numsize>1)
        {
            while(i<j)
            {
                for(;j>i;j--)
                    if(a[j].vec1.y>val.vec1.y)
                {
                    a[i]=a[j];
                    break;
                }

                for(;i<j;i++)
                    if(a[i].vec1.y<val.vec1.y)
                {
                    a[j]=a[i];
                    break;
                }
            }
            a[i]=val;
            QuickSortVer2v_ver1Y(a,i);
            QuickSortVer2v_ver1Y(a+i+1,numsize-1-i);
        }
    }

    Int64 i64_calculatesumx_XT(Ver2v verIn)
    {
        Int32 i;
        Int64 sum=0;
        Int32 N=verIn.num;
        for (i=0;i<N;i++)
        sum=sum+verIn.point[i].vec1.x;
        return sum;
    }

    Int64 i64_calculatesumy_XT(Ver2v verIn)
    {
        Int32 i;
        Int64 sum=0;
        Int32 N=verIn.num;
        for (i=0;i<N;i++)
        sum=sum+verIn.point[i].vec2.x;
        return sum;
    }

    Int64 i64_calculatesquare_XT(Ver2v verIn)
    {
        Int32 i;
        Int64 sum=0;
        Int32 N=verIn.num;
        for (i=0;i<N;i++)
        sum=sum+verIn.point[i].vec1.x*verIn.point[i].vec1.x;
        return sum;
    }

    Int64 i64_calculatesumxy_XT(Ver2v verIn)
    {
        Int32 i;
        Int64 sum=0;
        Int32 N=verIn.num;
        for (i=0;i<N;i++)
        {
          sum=sum+verIn.point[i].vec1.x*verIn.point[i].vec2.x;
        }
        return sum;
    }

    Int64 i64_calculatesumx_YT(Ver2v verIn)
    {
        Int32 i;
        Int64 sum=0;
        Int32 N=verIn.num;
        for (i=0;i<N;i++)
        sum=sum+verIn.point[i].vec1.y;
        return sum;
    }

    Int64 i64_calculatesumy_YT(Ver2v verIn)
    {
        Int32 i;
        Int64 sum=0;
        Int32 N=verIn.num;
        for (i=0;i<N;i++)
        sum=sum+verIn.point[i].vec2.y;
        return sum;
    }

    Int64 i64_calculatesquare_YT(Ver2v verIn)
    {
        Int32 i;
        Int64 sum=0;
        Int32 N=verIn.num;
        for (i=0;i<N;i++)
        sum=sum+verIn.point[i].vec1.y*verIn.point[i].vec1.y;
        return sum;
    }

    Int64 i64_calculatesumxy_YT(Ver2v verIn)
    {
        Int32 i;
        Int64 sum=0;
        Int32 N=verIn.num;
        for (i=0;i<N;i++)
        {
          sum=sum+verIn.point[i].vec1.y*verIn.point[i].vec2.y;
        }
        return sum;
    }

    Int64 i64_calculatesumx(Int32 *x,Int32 N)
    {
        Int32 i;
        Int64 sum=0;
        for (i=0;i<N;i++)
        sum=sum+x[i];
        return sum;
    }

    Int64 i64_calculatesquare(Int32 *x,Int32 N)
    {
        Int32 i;
        Int64 sum=0;
        for (i=0;i<N;i++)
        sum=sum+x[i]*x[i];
        return sum;
    }

    Int64 i64_calculatesumxy(Int32 *x,Int32 *y,Int32 N)
    {
        Int32 i;
        Int64 sum=0;
        for (i=0;i<N;i++)
        {
          sum=sum+x[i]*y[i];
        }
        return sum;
    }

    Mat MatCreat(Uint32 nHeight,Uint32 nWidth,type Mod,void *bufferIn)
    {
        Mat image;
        Uint8 	*u8_1p;
        Int8 	*i8_1p;
        Uint16  *u16_1p;
        Int16   *i16_1p;
        Int32	*i32_1p;
        float	*f_1p;
        double	*d_1p;
        Vec3b	*u8_3p;
        Vec3ib  *i8_3p;
        Vec3s	*u16_3p;
        Vec3w	*i16_3p;
        Vec3i	*i32_3p;
        Vec3f	*f_3p;
        Vec3d	*d_3p;

        image.nWidth=nWidth;
        image.nHeight=nHeight;
        image.startx=0;
        image.starty=0;
        image.width=nWidth;
        image.height=nHeight;
        image.data=(Uint8*)bufferIn;
        image._type=Mod;
        switch(Mod)
        {
            case CCV_8UC1:
                u8_1p = (Uint8*)bufferIn;
                image.ptr_uchar=u8_1p;
            break;
            case CCV_8UC3:
                u8_3p = (Vec3b*)bufferIn;
                image.ptr_Vec3b=u8_3p;
            break;
            case CCV_8SC1:
                i8_1p = (Int8*)bufferIn;
                image.ptr_char=i8_1p;
            break;
            case CCV_8SC3:
                i8_3p = (Vec3ib*)bufferIn;
                image.ptr_Vec3ib=i8_3p;
            break;
            case CCV_16UC1:
                u16_1p = (Uint16*)bufferIn;
                image.ptr_ushort=u16_1p;
            break;
            case CCV_16UC3:
                u16_3p = (Vec3s*)bufferIn;
                image.ptr_Vec3s=u16_3p;
            break;
            case CCV_16SC1:
                i16_1p = (Int16*)bufferIn;
                image.ptr_short=i16_1p;
            break;
            case CCV_16SC3:
                i16_3p = (Vec3w*)bufferIn;
                image.ptr_Vec3w=i16_3p;
            break;
            case CCV_32SC1:
                i32_1p = (Int32*)bufferIn;
                image.ptr_int=i32_1p;
            break;
            case CCV_32SC3:
                i32_3p = (Vec3i*)bufferIn;
                image.ptr_Vec3i=i32_3p;
            break;
            case CCV_32FC1:
                f_1p = (float*)bufferIn;
                image.ptr_float=f_1p;
            break;
            case CCV_32FC3:
                f_3p = (Vec3f*)bufferIn;
                image.ptr_Vec3f=f_3p;
            break;
            case CCV_64FC1:
                d_1p = (double*)bufferIn;
                image.ptr_double=d_1p;
            break;
            case CCV_64FC3:
                d_3p = (Vec3d*)bufferIn;
                image.ptr_Vec3d=d_3p;
            break;
        }
        return image;
    }

    Mat MatCreat1col(Uint32 nHeight,Uint32 nWidth,type Mod,void *bufferIn,double color)
    {
        Mat image;
        Uint8 	*u8_1p;
        Int8 	*i8_1p;
        Uint16  *u16_1p;
        Int16   *i16_1p;
        Int32	*i32_1p;
        float	*f_1p;
        double	*d_1p;
        Vec3b	*u8_3p;
        Vec3ib  *i8_3p;
        Vec3s	*u16_3p;
        Vec3w	*i16_3p;
        Vec3i	*i32_3p;
        Vec3f	*f_3p;
        Vec3d	*d_3p;
        Int32 size=nHeight*nWidth;
        Int32 i;

        Uint8 u8_data,u8_data1,u8_data2,u8_data3;
        Uint16 u16_data,u16_data1,u16_data2,u16_data3;
        Int8 i8_data,i8_data1,i8_data2,i8_data3;
        Int16 i16_data,i16_data1,i16_data2,i16_data3;
        Int32 i32_data,i32_data1,i32_data2,i32_data3;
        float f_data,f_data1,f_data2,f_data3;
        double d_data,d_data1,d_data2,d_data3;

        image.nWidth=nWidth;
        image.nHeight=nHeight;
        image.data=(Uint8*)bufferIn;
        image.startx=0;
        image.starty=0;
        image.width=nWidth;
        image.height=nHeight;
        image._type=Mod;
        switch(Mod)
        {
            case CCV_8UC1:
                u8_1p = (Uint8*)bufferIn;
                image.ptr_uchar=u8_1p;
                u8_data=(Uint8)(color+0.5);
                memset(image.ptr_uchar,u8_data,sizeof(Uint8)*size);
            break;
            case CCV_8UC3:
                u8_3p = (Vec3b*)bufferIn;
                image.ptr_Vec3b=u8_3p;
                u8_data1=(Uint8)(color+0.5);
                u8_data2=(Uint8)(color+0.5);
                u8_data3=(Uint8)(color+0.5);
                for(i=0;i<size;i++)
                {
                    image.ptr_Vec3b[i].data1=u8_data1;
                    image.ptr_Vec3b[i].data2=u8_data2;
                    image.ptr_Vec3b[i].data3=u8_data3;
                }
            break;
            case CCV_8SC1:
                i8_1p = (Int8*)bufferIn;
                image.ptr_char=i8_1p;
                i8_data=(Int8)(color+0.5);
                memset(image.ptr_char,i8_data,sizeof(Int8)*size);
            break;
            case CCV_8SC3:
                i8_3p = (Vec3ib*)bufferIn;
                image.ptr_Vec3ib=i8_3p;
                i8_data1=(Int8)(color+0.5);
                i8_data2=(Int8)(color+0.5);
                i8_data3=(Int8)(color+0.5);
                for(i=0;i<size;i++)
                {
                    image.ptr_Vec3ib[i].data1=i8_data1;
                    image.ptr_Vec3ib[i].data2=i8_data2;
                    image.ptr_Vec3ib[i].data3=i8_data3;
                }
            break;
            case CCV_16UC1:
                u16_1p = (Uint16*)bufferIn;
                image.ptr_ushort=u16_1p;
                u16_data=(Uint16)(color+0.5);
                memset(image.ptr_ushort,u16_data,sizeof(Uint16)*size);
            break;
            case CCV_16UC3:
                u16_3p = (Vec3s*)bufferIn;
                image.ptr_Vec3s=u16_3p;
                u16_data1=(Uint16)(color+0.5);
                u16_data2=(Uint16)(color+0.5);
                u16_data3=(Uint16)(color+0.5);
                for(i=0;i<size;i++)
                {
                    image.ptr_Vec3s[i].data1=u16_data1;
                    image.ptr_Vec3s[i].data2=u16_data2;
                    image.ptr_Vec3s[i].data3=u16_data3;
                }
            break;
            case CCV_16SC1:
                i16_1p = (Int16*)bufferIn;
                image.ptr_short=i16_1p;
                i16_data=(Int16)(color+0.5);
                memset(image.ptr_short,i16_data,sizeof(Int16)*size);
            break;
            case CCV_16SC3:
                i16_3p = (Vec3w*)bufferIn;
                image.ptr_Vec3w=i16_3p;
                i16_data1=(Int16)(color+0.5);
                i16_data2=(Int16)(color+0.5);
                i16_data3=(Int16)(color+0.5);
                for(i=0;i<size;i++)
                {
                    image.ptr_Vec3w[i].data1=i16_data1;
                    image.ptr_Vec3w[i].data2=i16_data2;
                    image.ptr_Vec3w[i].data3=i16_data3;
                }
            break;
            case CCV_32SC1:
                i32_1p = (Int32*)bufferIn;
                image.ptr_int=i32_1p;
                i32_data=(Int32)(color+0.5);
                memset(image.ptr_int,i32_data,sizeof(Int32)*size);
            break;
            case CCV_32SC3:
                i32_3p = (Vec3i*)bufferIn;
                image.ptr_Vec3i=i32_3p;
                i32_data1=(Int32)(color+0.5);
                i32_data2=(Int32)(color+0.5);
                i32_data3=(Int32)(color+0.5);
                for(i=0;i<size;i++)
                {
                    image.ptr_Vec3i[i].data1=i32_data1;
                    image.ptr_Vec3i[i].data2=i32_data2;
                    image.ptr_Vec3i[i].data3=i32_data3;
                }
            break;
            case CCV_32FC1:
                f_1p = (float*)bufferIn;
                image.ptr_float=f_1p;
                f_data=(float)color;
                memset(image.ptr_float,f_data,sizeof(float)*size);
            break;
            case CCV_32FC3:
                f_3p = (Vec3f*)bufferIn;
                image.ptr_Vec3f=f_3p;
                f_data1=(float)color;
                f_data2=(float)color;
                f_data3=(float)color;
                for(i=0;i<size;i++)
                {
                    image.ptr_Vec3f[i].data1=f_data1;
                    image.ptr_Vec3f[i].data2=f_data2;
                    image.ptr_Vec3f[i].data3=f_data3;
                }
            break;
            case CCV_64FC1:
                d_1p = (double*)bufferIn;
                image.ptr_double=d_1p;
                d_data=(double)color;
                memset(image.ptr_double,d_data,sizeof(double)*size);
            break;
            case CCV_64FC3:
                d_3p = (Vec3d*)bufferIn;
                image.ptr_Vec3d=d_3p;
                d_data1=(double)color;
                d_data2=(double)color;
                d_data3=(double)color;
                for(i=0;i<size;i++)
                {
                    image.ptr_Vec3d[i].data1=d_data1;
                    image.ptr_Vec3d[i].data2=d_data2;
                    image.ptr_Vec3d[i].data3=d_data3;
                }
            break;
        }
        return image;
    }

    Mat MatCreat3col(Uint32 nHeight,Uint32 nWidth,type Mod,void *bufferIn,double color1,double color2,double color3)
    {
        Mat image;
        Uint8 	*u8_1p;
        Int8 	*i8_1p;
        Uint16  *u16_1p;
        Int16   *i16_1p;
        Int32	*i32_1p;
        float	*f_1p;
        double	*d_1p;
        Vec3b	*u8_3p;
        Vec3ib  *i8_3p;
        Vec3s	*u16_3p;
        Vec3w	*i16_3p;
        Vec3i	*i32_3p;
        Vec3f	*f_3p;
        Vec3d	*d_3p;
        Int32 size=nHeight*nWidth;
        Int32 i;

        Uint8 u8_data,u8_data1,u8_data2,u8_data3;
        Uint16 u16_data,u16_data1,u16_data2,u16_data3;
        Int8 i8_data,i8_data1,i8_data2,i8_data3;
        Int16 i16_data,i16_data1,i16_data2,i16_data3;
        Int32 i32_data,i32_data1,i32_data2,i32_data3;
        float f_data,f_data1,f_data2,f_data3;
        double d_data,d_data1,d_data2,d_data3;

        image.nWidth=nWidth;
        image.nHeight=nHeight;
        image.startx=0;
        image.starty=0;
        image.width=nWidth;
        image.height=nHeight;
        image.data=(Uint8*)bufferIn;
        image._type=Mod;
        switch(Mod)
        {
            case CCV_8UC1:
                u8_1p = (Uint8*)bufferIn;
                image.ptr_uchar=u8_1p;
                u8_data=(Uint8)((color1+color2+color3)/3+0.5);
                memset(image.ptr_uchar,u8_data,sizeof(Uint8)*size);
            break;
            case CCV_8UC3:
                u8_3p = (Vec3b*)bufferIn;
                image.ptr_Vec3b=u8_3p;
                u8_data1=(Uint8)(color1+0.5);
                u8_data2=(Uint8)(color2+0.5);
                u8_data3=(Uint8)(color3+0.5);
                for(i=0;i<size;i++)
                {
                    image.ptr_Vec3b[i].data1=u8_data1;
                    image.ptr_Vec3b[i].data2=u8_data2;
                    image.ptr_Vec3b[i].data3=u8_data3;
                }
            break;
            case CCV_8SC1:
                i8_1p = (Int8*)bufferIn;
                image.ptr_char=i8_1p;
                i8_data=(Int8)((color1+color2+color3)/3+0.5);
                memset(image.ptr_char,i8_data,sizeof(Int8)*size);
            break;
            case CCV_8SC3:
                i8_3p = (Vec3ib*)bufferIn;
                image.ptr_Vec3ib=i8_3p;
                i8_data1=(Int8)(color1+0.5);
                i8_data2=(Int8)(color2+0.5);
                i8_data3=(Int8)(color3+0.5);
                for(i=0;i<size;i++)
                {
                    image.ptr_Vec3ib[i].data1=i8_data1;
                    image.ptr_Vec3ib[i].data2=i8_data2;
                    image.ptr_Vec3ib[i].data3=i8_data3;
                }
            break;
            case CCV_16UC1:
                u16_1p = (Uint16*)bufferIn;
                image.ptr_ushort=u16_1p;
                u16_data=(Uint16)((color1+color2+color3)/3+0.5);
                memset(image.ptr_ushort,u16_data,sizeof(Uint16)*size);
            break;
            case CCV_16UC3:
                u16_3p = (Vec3s*)bufferIn;
                image.ptr_Vec3s=u16_3p;
                u16_data1=(Uint16)(color1+0.5);
                u16_data2=(Uint16)(color2+0.5);
                u16_data3=(Uint16)(color3+0.5);
                for(i=0;i<size;i++)
                {
                    image.ptr_Vec3s[i].data1=u16_data1;
                    image.ptr_Vec3s[i].data2=u16_data2;
                    image.ptr_Vec3s[i].data3=u16_data3;
                }
            break;
            case CCV_16SC1:
                i16_1p = (Int16*)bufferIn;
                image.ptr_short=i16_1p;
                i16_data=(Int16)((color1+color2+color3)/3+0.5);
                memset(image.ptr_short,i16_data,sizeof(Int16)*size);
            break;
            case CCV_16SC3:
                i16_3p = (Vec3w*)bufferIn;
                image.ptr_Vec3w=i16_3p;
                i16_data1=(Int16)(color1+0.5);
                i16_data2=(Int16)(color2+0.5);
                i16_data3=(Int16)(color3+0.5);
                for(i=0;i<size;i++)
                {
                    image.ptr_Vec3w[i].data1=i16_data1;
                    image.ptr_Vec3w[i].data2=i16_data2;
                    image.ptr_Vec3w[i].data3=i16_data3;
                }
            break;
            case CCV_32SC1:
                i32_1p = (Int32*)bufferIn;
                image.ptr_int=i32_1p;
                i32_data=(Int32)((color1+color2+color3)/3+0.5);
                memset(image.ptr_int,i32_data,sizeof(Int32)*size);
            break;
            case CCV_32SC3:
                i32_3p = (Vec3i*)bufferIn;
                image.ptr_Vec3i=i32_3p;
                i32_data1=(Int32)(color1+0.5);
                i32_data2=(Int32)(color2+0.5);
                i32_data3=(Int32)(color3+0.5);
                for(i=0;i<size;i++)
                {
                    image.ptr_Vec3i[i].data1=i32_data1;
                    image.ptr_Vec3i[i].data2=i32_data2;
                    image.ptr_Vec3i[i].data3=i32_data3;
                }
            break;
            case CCV_32FC1:
                f_1p = (float*)bufferIn;
                image.ptr_float=f_1p;
                f_data=(float)((color1+color2+color3)/3);
                memset(image.ptr_float,f_data,sizeof(float)*size);
            break;
            case CCV_32FC3:
                f_3p = (Vec3f*)bufferIn;
                image.ptr_Vec3f=f_3p;
                f_data1=(float)color1;
                f_data2=(float)color2;
                f_data3=(float)color3;
                for(i=0;i<size;i++)
                {
                    image.ptr_Vec3f[i].data1=f_data1;
                    image.ptr_Vec3f[i].data2=f_data2;
                    image.ptr_Vec3f[i].data3=f_data3;
                }
            break;
            case CCV_64FC1:
                d_1p = (double*)bufferIn;
                image.ptr_double=d_1p;
                d_data=(double)((color1+color2+color3)/3);
                memset(image.ptr_double,d_data,sizeof(double)*size);
            break;
            case CCV_64FC3:
                d_3p = (Vec3d*)bufferIn;
                image.ptr_Vec3d=d_3p;
                d_data1=(double)color1;
                d_data2=(double)color2;
                d_data3=(double)color3;
                for(i=0;i<size;i++)
                {
                    image.ptr_Vec3d[i].data1=d_data1;
                    image.ptr_Vec3d[i].data2=d_data2;
                    image.ptr_Vec3d[i].data3=d_data3;
                }
            break;
        }
        return image;
    }

    Mat MatCreatzero(Uint32 nHeight,Uint32 nWidth,type Mod,void *bufferIn)
    {
        Mat image;
        Uint8 	*u8_1p;
        Int8 	*i8_1p;
        Uint16  *u16_1p;
        Int16   *i16_1p;
        Int32	*i32_1p;
        float	*f_1p;
        double	*d_1p;
        Vec3b	*u8_3p;
        Vec3ib  *i8_3p;
        Vec3s	*u16_3p;
        Vec3w	*i16_3p;
        Vec3i	*i32_3p;
        Vec3f	*f_3p;
        Vec3d	*d_3p;
        Int32 size=nHeight*nWidth;

        image.nWidth=nWidth;
        image.nHeight=nHeight;
        image.startx=0;
        image.starty=0;
        image.width=nWidth;
        image.height=nHeight;
        image.data=(Uint8*)bufferIn;
        image._type=Mod;
        switch(Mod)
        {
            case CCV_8UC1:
                u8_1p = (Uint8*)bufferIn;
                image.ptr_uchar=u8_1p;
                memset(image.ptr_uchar,0,sizeof(Uint8)*size);
            break;
            case CCV_8UC3:
                u8_3p = (Vec3b*)bufferIn;
                image.ptr_Vec3b=u8_3p;
                memset(image.ptr_Vec3b,0,sizeof(Vec3b)*size);
            break;
            case CCV_8SC1:
                i8_1p = (Int8*)bufferIn;
                image.ptr_char=i8_1p;
                memset(image.ptr_char,0,sizeof(Int8)*size);
            break;
            case CCV_8SC3:
                i8_3p = (Vec3ib*)bufferIn;
                image.ptr_Vec3ib=i8_3p;
                memset(image.ptr_Vec3ib,0,sizeof(Vec3ib)*size);
            break;
            case CCV_16UC1:
                u16_1p = (Uint16*)bufferIn;
                image.ptr_ushort=u16_1p;
                memset(image.ptr_ushort,0,sizeof(Uint16)*size);
            break;
            case CCV_16UC3:
                u16_3p = (Vec3s*)bufferIn;
                image.ptr_Vec3s=u16_3p;
                memset(image.ptr_Vec3s,0,sizeof(Vec3s)*size);
            break;
            case CCV_16SC1:
                i16_1p = (Int16*)bufferIn;
                image.ptr_short=i16_1p;
                memset(image.ptr_short,0,sizeof(Int16)*size);
            break;
            case CCV_16SC3:
                i16_3p = (Vec3w*)bufferIn;
                image.ptr_Vec3w=i16_3p;
                memset(image.ptr_Vec3w,0,sizeof(Vec3w)*size);
            break;
            case CCV_32SC1:
                i32_1p = (Int32*)bufferIn;
                image.ptr_int=i32_1p;
                memset(image.ptr_int,0,sizeof(Int32)*size);
            break;
            case CCV_32SC3:
                i32_3p = (Vec3i*)bufferIn;
                image.ptr_Vec3i=i32_3p;
                memset(image.ptr_Vec3i,0,sizeof(Vec3i)*size);
            break;
            case CCV_32FC1:
                f_1p = (float*)bufferIn;
                image.ptr_float=f_1p;
                memset(image.ptr_float,0,sizeof(float)*size);
            break;
            case CCV_32FC3:
                f_3p = (Vec3f*)bufferIn;
                image.ptr_Vec3f=f_3p;
                memset(image.ptr_Vec3f,0,sizeof(Vec3f)*size);
            break;
            case CCV_64FC1:
                d_1p = (double*)bufferIn;
                image.ptr_double=d_1p;
                memset(image.ptr_double,0,sizeof(double)*size);
            break;
            case CCV_64FC3:
                d_3p = (Vec3d*)bufferIn;
                image.ptr_Vec3d=d_3p;
                memset(image.ptr_Vec3d,0,sizeof(Vec3d)*size);
            break;
        }
        return image;
    }

    Mat MatCreatClone(Mat matIn,void *bufferIn)
    {
        Mat image;
        Int32 nWidth=matIn.nWidth;
        Int32 nHeight=matIn.nHeight;
        image.nWidth=matIn.nWidth;
        image.nHeight=matIn.nHeight;
        image.startx=matIn.startx;
        image.starty=matIn.starty;
        image.width=matIn.width;
        image.height=matIn.height;
        image.data=(Uint8*)bufferIn;
        MyconvertTo(&image,matIn._type);
        memcpy(image.data,matIn.data,getsizeof(matIn._type)*nWidth*nHeight);
        return image;
    }

    Mat MatPointto(Mat *matIn)
    {
        Mat *image;
        image=matIn;
        return *image;
    }

    Mat HoughCreat(void *bufferIn)
    {
        Uint16 thetaRange=MHC_TETARANGE;
        Uint16 rhoMaxLength=MHC_ROLENGTH;
        Mat image;

        image.nHeight=thetaRange;
        image.nWidth=rhoMaxLength;
        image.startx=0;
        image.width=rhoMaxLength;
        image.starty=MHC_TETARANGE_MID;
        image.height=thetaRange-2*MHC_TETARANGE_MID;
        image.data=(Uint8*)bufferIn;
        MyconvertTo(&image,CCV_16UC1);
        return image;
    }

    Int8 MyMat_to_Hough(Mat matIn,Mat *HoughOut)
    {
        Uint16 thetaRange=MHC_TETARANGE;
        Uint16 rhoMaxLength=MHC_ROLENGTH;
        Uint16 pEdgeMapListNum=0;
        Int32 i,j;
        Int32 nnWidth=matIn.nWidth;
        Int32 nnHeight=matIn.nHeight;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        Int32 theta;
        Int32 diameter=SQRTof2_Q8 * MAX(nnWidth, nnHeight);
        Int32 normLength=(MHC_ROLENGTH << 16)/(SQRTof2_Q8 * MAX(nnWidth, nnHeight))/2;

        MyconvertTo(HoughOut,CCV_16UC1);
        HoughOut->nHeight=thetaRange;
        HoughOut->nWidth=rhoMaxLength;
        HoughOut->startx=0;
        HoughOut->width=rhoMaxLength;
        HoughOut->starty=MHC_TETARANGE_MID;
        HoughOut->height=thetaRange-2*MHC_TETARANGE_MID;
        MatSet1col(HoughOut,0);

        switch(matIn._type)
        {
            case CCV_8UC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(matIn.data[j*nnWidth+i]!=0)
                        {
                            for(theta=0;theta<HoughOut->nHeight;theta++)
                            {
                                Int32 rho=i*CV_Cos[theta]+j*CV_Sin[theta];
                                Int16 i16_rho;
                                i16_rho=(Int16)(((rho+diameter)*normLength+32768)>>16);
                                HoughOut->ptr_ushort[theta*HoughOut->nWidth+i16_rho]++;
                                pEdgeMapListNum++;
                            }
                        }
                    }
                }
            break;
            default:
                return 1;
            break;
        }
        if(pEdgeMapListNum==0)
        {
            return 1;
        }
        return 0;
    }

    Int8 Myregion_to_Hough(MyConect *ImageConectIn,	Mat *HoughOut)
    {
        Uint16 thetaRange=MHC_TETARANGE;
        Uint16 rhoMaxLength=MHC_ROLENGTH;
        Uint16 *pEdgeMapList=(Uint16*)u8_buffer_x1Temp2;
        Uint16 pEdgeMapListNum=0;
        Int32 n,m;
        Int32 nnWidth=ImageConectIn->nWidth;
        Int32 nnHeight=ImageConectIn->nHeight;
        Int32 theta;
        Int32 diameter=SQRTof2_Q8 * MAX(nnWidth, nnHeight);
        Int32 normLength=(MHC_ROLENGTH << 16)/(SQRTof2_Q8 * MAX(nnWidth, nnHeight))/2;

        MyconvertTo(HoughOut,CCV_16UC1);
        HoughOut->nHeight=thetaRange;
        HoughOut->nWidth=rhoMaxLength;
        HoughOut->startx=0;
        HoughOut->width=rhoMaxLength;
        HoughOut->starty=MHC_TETARANGE_MID;
        HoughOut->height=thetaRange-2*MHC_TETARANGE_MID;
        MatSet1col(HoughOut,0);
        for(n=0;n<ImageConectIn->AllMarkPointCount;n++)
        {
            for(m=0;m<ImageConectIn->AllMarkPoint[n].PointArea;m++)
            {
                for(theta=0;theta<HoughOut->nHeight;theta++)
                {
                    Int32 rho=(Int32)ImageConectIn->AllMarkPoint[n].point[m].x*CV_Cos[theta]+(Int32)ImageConectIn->AllMarkPoint[n].point[m].y*CV_Sin[theta];
                    Int16 i16_rho;
                    i16_rho=(Int16)(((rho+diameter)*normLength+32768)>>16);
                    HoughOut->ptr_ushort[theta*HoughOut->nWidth+i16_rho]++;
                }
            }
        }
        if(ImageConectIn->mianji==0)
        {
            return 1;
        }
        return 0;
    }

    Int8 MyPoint_to_Hough(Uint16 *pEdgeMapList,Uint16 nWidth,Uint16 nHeight,Uint16 pEdgeMapListNum,Mat *HoughOut)
    {
        Uint16 thetaRange=MHC_TETARANGE;
        Uint16 rhoMaxLength=MHC_ROLENGTH;
        Int32 n;
        Int32 theta;
        Int32 diameter=SQRTof2_Q8 * MAX(nWidth, nHeight);
        Int32 normLength=(MHC_ROLENGTH << 16)/(SQRTof2_Q8 * MAX(nWidth, nHeight))/2;

        MyconvertTo(HoughOut,CCV_16UC1);
        HoughOut->nHeight=thetaRange;
        HoughOut->nWidth=rhoMaxLength;
        HoughOut->startx=0;
        HoughOut->width=rhoMaxLength;
        HoughOut->starty=MHC_TETARANGE_MID;
        HoughOut->height=thetaRange-2*MHC_TETARANGE_MID;
        MatSet1col(HoughOut,0);

        for(n=0;n<pEdgeMapListNum;n++)
        {
            for(theta=0;theta<HoughOut->nHeight;theta++)
            {
                Int32 rho=(Int32)pEdgeMapList[n*2]*CV_Cos[theta]+(Int32)pEdgeMapList[n*2+1]*CV_Sin[theta];
                Int16 i16_rho;
                i16_rho=(Int16)(((rho+diameter)*normLength+32768)>>16);
                HoughOut->ptr_ushort[theta*HoughOut->nWidth+i16_rho]++;
            }
        }
        return 0;
    }

    Int8 MyHough_to_line(Mat HoughIn,Mat matIn,MyCountLine *LineOut,Int32 lineTotal,Int32 lineLongmin,Int32 lineGapmax,Int32 neighbordictance,Int32 value,non_max Mod)
    {
        Uint8 *u8_Non_max=(Uint8*)u8_buffer_x3Temp1;
        Mat imnon_max;

        Uint8 nowlineTotal=0;
        Int32 nnWidth=matIn.nWidth;
        Int32 nnHeight=matIn.nHeight;

        Int16 pointduibistx[MHC_SEARCH_LINENUM];
        Int16 pointduibisty[MHC_SEARCH_LINENUM];
        Int16 pointduibiedx[MHC_SEARCH_LINENUM];
        Int16 pointduibiedy[MHC_SEARCH_LINENUM];


        Int32 i,j;
        Int32 n;

        mhc_hou_lineinfo edge[MHC_SEARCH_LINENUM];
        Int32 edgenum=0;

        LineOut->nHeight=matIn.nHeight;
        LineOut->nWidth=matIn.nWidth;
        LineOut->startx=matIn.startx;
        LineOut->starty=matIn.starty;
        LineOut->width=matIn.width;
        LineOut->height=matIn.height;


        imnon_max=MatCreat(MHC_TETARANGE,MHC_ROLENGTH,CCV_8UC1,u8_Non_max);
        MyNon_Maximal(HoughIn,&imnon_max,value,Mod);

        if(matIn._type!=CCV_8UC1
        ||HoughIn._type!=CCV_16UC1
        ||HoughIn.nHeight!=MHC_TETARANGE
        ||HoughIn.nWidth!=MHC_ROLENGTH)
            return 1;


        if(lineTotal>MHC_SEARCH_LINENUM)
            return 2;

        memset(pointduibistx,0,sizeof(Int16)*MHC_SEARCH_LINENUM);
        memset(pointduibisty,0,sizeof(Int16)*MHC_SEARCH_LINENUM);
        memset(pointduibiedx,0,sizeof(Int16)*MHC_SEARCH_LINENUM);
        memset(pointduibiedy,0,sizeof(Int16)*MHC_SEARCH_LINENUM);

        for(j=imnon_max.starty;j<imnon_max.starty+imnon_max.height;j++)
        {
            for(i=imnon_max.startx;i<imnon_max.startx+imnon_max.width;i++)
            {
                if(imnon_max.data[j*imnon_max.nWidth+i]!=0)
                {
                    L_Point32 pt1,pt2;
                    Int32 rho=i;
                    Int32 theta=j;
                    Int32 a,b;
                    Int32 x0,y0;
                    Int32 startrho;
                    Int32 endrho;
                    Int32 drho;
                    Int32 maxlongsize=0;
                    Int32 maxlongsizerho=0;
                    Int32 maxlongsizenum=0;

                    rho=draw_houghrho_to_xyrho(rho,nnWidth,nnHeight);

                    startrho=-(MHC_SEARCH_SIZE>>1);
                    endrho=(MHC_SEARCH_SIZE>>1);

                    for(drho=startrho;drho<=endrho;drho++)
                    {
                        Int32 longsize;
                        a=CV_Cos[theta];
                        b=CV_Sin[theta];
                        x0=((a*rho)>>16)+((drho*a)>>8);
                        y0=((b*rho)>>16)+((drho*b)>>8);
                        pt1.x=x0-(b<<3);
                        pt1.y=y0+(a<<3);
                        pt2.x=x0+(b<<3);
                        pt2.y=y0-(a<<3);
                        MyLineComperMat(&matIn,pt1,pt2,CV_LINE_8LT,1,lineGapmax,&longsize);
                        if(maxlongsize<longsize)
                        {
                            maxlongsize=longsize;
                            maxlongsizerho=drho;
                            maxlongsizenum=1;
                        }
                        else if(maxlongsize==longsize)
                        {
                            maxlongsizerho=maxlongsizerho+drho;
                            maxlongsizenum++;
                        }
                    }
                    if(maxlongsize>lineLongmin&&maxlongsizenum!=0)
                    {
                        Int32 drho=maxlongsizerho/maxlongsizenum;
                        edge[edgenum].drho=drho;
                        edge[edgenum].maxlongsize=maxlongsize;
                        edge[edgenum].rho=rho;
                        edge[edgenum].theta=theta;
                        edgenum++;
                        if(edgenum==MHC_SEARCH_LINENUM)
                        {
                            break;
                        }
                    }
                }
            }
            if(edgenum==MHC_SEARCH_LINENUM)
            {
                break;
            }
        }

        QuickSortA(edge,edgenum);
        for(n=0;n<edgenum;n++)
        {
            Int32 theta=edge[n].theta;
            Int32 rho=edge[n].rho;
            Int32 drho=edge[n].drho;
            Int32 a,b,x0,y0;
            Uint8 newone=0;
            Uint8 m;

            L_Point32 pt1,pt2;
            L_Point32 realpt1,realpt2;
            Int16 stx,sty,edx,edy;

            a=CV_Cos[theta];
            b=CV_Sin[theta];
            x0=((a*rho)>>16)+((drho*a)>>8);
            y0=((b*rho)>>16)+((drho*b)>>8);
            pt1.x=x0-(b<<3);
            pt1.y=y0+(a<<3);
            pt2.x=x0+(b<<3);
            pt2.y=y0-(a<<3);
            MyLineComperMat2(&matIn,pt1,pt2,CV_LINE_8LT,1,lineGapmax,&realpt1,&realpt2);
            stx=realpt1.x;
            sty=realpt1.y;
            edx=realpt2.x;
            edy=realpt2.y;
            for(m=0;m<nowlineTotal;m++)
            {
                if(abs(pointduibistx[m]-stx)<neighbordictance
                 &&abs(pointduibisty[m]-sty)<neighbordictance
                 &&abs(pointduibiedx[m]-edx)<neighbordictance
                 &&abs(pointduibiedy[m]-edy)<neighbordictance)
                 {
                    newone=1;
                    break;
                 }
            }
            if(newone==0)
            {
                LineOut->line[nowlineTotal].st.x=(Uint16)stx;
                LineOut->line[nowlineTotal].st.y=(Uint16)sty;
                LineOut->line[nowlineTotal].ed.x=(Uint16)edx;
                LineOut->line[nowlineTotal].ed.y=(Uint16)edy;
                LineOut->houghinfo[nowlineTotal].theta=(Uint16)theta;
                LineOut->houghinfo[nowlineTotal].rho=draw_xyrho_to_houghrho(rho,nnWidth,nnHeight);

                pointduibistx[nowlineTotal]=stx;
                pointduibisty[nowlineTotal]=sty;
                pointduibiedx[nowlineTotal]=edx;
                pointduibiedy[nowlineTotal]=edy;
                nowlineTotal++;
                if(nowlineTotal==lineTotal)
                {
                    break;
                }
            }
        }
        LineOut->linenum=nowlineTotal;
        return 0;
    }

    Int8 MyHough_to_2sideline(Mat HoughIn,Mat matIn,MyCountLine *LineOut,Int32 lineLongmin,Int32 lineGapmax,Int32 abssidevalue)
    {
        Int32 halfnWidth;
        Int32 halfnHeight;
        Uint8 nowlineTotal=0;
        Int32 nnWidth=matIn.nWidth;
        Int32 nnHeight=matIn.nHeight;
        Uint16 MAXtemp[2]={0,0};
        Int32 MAXtheta[2],MAXrho[2];

        Int32 i,j;
        Int32 n=0;

        LineOut->nHeight=matIn.nHeight;
        LineOut->nWidth=matIn.nWidth;
        LineOut->startx=matIn.startx;
        LineOut->starty=matIn.starty;
        LineOut->width=matIn.width;
        LineOut->height=matIn.height;
        LineOut->linenum=nowlineTotal;

        if(matIn._type!=CCV_8UC1
        ||HoughIn._type!=CCV_16UC1
        ||HoughIn.nHeight!=MHC_TETARANGE
        ||HoughIn.nWidth!=MHC_ROLENGTH)
            return 1;

        halfnWidth=(HoughIn.nWidth>>1)-2;
        halfnHeight=(HoughIn.nHeight>>1);

        for(j=halfnHeight;j<HoughIn.starty+HoughIn.height-abssidevalue;j++)
        {
            for(i=halfnWidth;i<HoughIn.startx+HoughIn.width;i++)
            {
                if(MAXtemp[0]<HoughIn.ptr_ushort[j*HoughIn.nWidth+i])
                {
                    MAXtemp[0]=HoughIn.ptr_ushort[j*HoughIn.nWidth+i];
                    MAXtheta[0]=j;
                    MAXrho[0]=i;
                }
            }
        }
        for(j=HoughIn.starty+abssidevalue;j<halfnHeight;j++)
        {
            for(i=HoughIn.startx;i<HoughIn.startx+HoughIn.width;i++)
            {
                if(MAXtemp[1]<HoughIn.ptr_ushort[j*HoughIn.nWidth+i])
                {
                    MAXtemp[1]=HoughIn.ptr_ushort[j*HoughIn.nWidth+i];
                    MAXtheta[1]=j;
                    MAXrho[1]=i;
                }
            }
        }
        for(n=0;n<2;n++)
        {
            if(MAXtemp[n]>0)
            {
                L_Point32 pt1,pt2;
                Int32 rho=MAXrho[n];
                Int32 theta=MAXtheta[n];
                Int32 a,b;
                Int32 x0,y0;
                Int32 startrho;
                Int32 endrho;
                Int32 drho;
                Int32 maxlongsize=0;
                Int32 maxlongsizerho=0;
                Int32 maxlongsizenum=0;

                rho=draw_houghrho_to_xyrho(rho,nnWidth,nnHeight);

                startrho=-(MHC_SEARCH_SIZE>>1);
                endrho=(MHC_SEARCH_SIZE>>1);

                for(drho=startrho;drho<=endrho;drho++)
                {
                    Int32 longsize;
                    a=CV_Cos[theta];
                    b=CV_Sin[theta];
                    x0=((a*rho)>>16)+((drho*a)>>8);
                    y0=((b*rho)>>16)+((drho*b)>>8);
                    pt1.x=x0-(b<<3);
                    pt1.y=y0+(a<<3);
                    pt2.x=x0+(b<<3);
                    pt2.y=y0-(a<<3);
                    MyLineComperMat(&matIn,pt1,pt2,CV_LINE_8LT,1,lineGapmax,&longsize);
                    if(maxlongsize<longsize)
                    {
                        maxlongsize=longsize;
                        maxlongsizerho=drho;
                        maxlongsizenum=1;
                    }
                    else if(maxlongsize==longsize)
                    {
                        maxlongsizerho=maxlongsizerho+drho;
                        maxlongsizenum++;
                    }
                }
                if(maxlongsize>lineLongmin&&maxlongsizenum!=0)
                {
                    Int32 drho=maxlongsizerho/maxlongsizenum;
                    L_Point32 pt1,pt2;
                    L_Point32 realpt1,realpt2;
                    Int16 stx,sty,edx,edy;

                    a=CV_Cos[theta];
                    b=CV_Sin[theta];
                    x0=((a*rho)>>16)+((drho*a)>>8);
                    y0=((b*rho)>>16)+((drho*b)>>8);
                    pt1.x=x0-(b<<3);
                    pt1.y=y0+(a<<3);
                    pt2.x=x0+(b<<3);
                    pt2.y=y0-(a<<3);
                    MyLineComperMat2(&matIn,pt1,pt2,CV_LINE_8LT,1,lineGapmax,&realpt1,&realpt2);
                    stx=realpt1.x;
                    sty=realpt1.y;
                    edx=realpt2.x;
                    edy=realpt2.y;
                    LineOut->line[nowlineTotal].st.x=(Uint16)stx;
                    LineOut->line[nowlineTotal].st.y=(Uint16)sty;
                    LineOut->line[nowlineTotal].ed.x=(Uint16)edx;
                    LineOut->line[nowlineTotal].ed.y=(Uint16)edy;
                    LineOut->houghinfo[nowlineTotal].theta=(Uint16)theta;

                    LineOut->houghinfo[nowlineTotal].rho=draw_xyrho_to_houghrho(rho,nnWidth,nnHeight);
                    nowlineTotal++;
                }
            }
            else
            {
                return 1;
            }
        }
        LineOut->linenum=nowlineTotal;
        return 0;
    }

    Int8 MyHough_to_2sideline_area(Mat HoughIn,Mat matIn,MyCountLine *LineOut,Int32 abssidevalue)
    {
        Int32 halfnWidth;
        Int32 halfnHeight;
        Uint8 nowlineTotal=0;
        Int32 nnWidth=matIn.nWidth;
        Int32 nnHeight=matIn.nHeight;
        Uint16 MAXtemp[2]={0,0};
        Int32 MAXtheta[2],MAXrho[2];
        Int32 i,j;
        Int32 n=0;

        LineOut->nHeight=matIn.nHeight;
        LineOut->nWidth=matIn.nWidth;
        LineOut->startx=matIn.startx;
        LineOut->starty=matIn.starty;
        LineOut->width=matIn.width;
        LineOut->height=matIn.height;
        LineOut->linenum=nowlineTotal;

        if(matIn._type!=CCV_8UC1
        ||HoughIn._type!=CCV_16UC1
        ||HoughIn.nHeight!=MHC_TETARANGE
        ||HoughIn.nWidth!=MHC_ROLENGTH)
            return 1;

        halfnWidth=(HoughIn.nWidth>>1)-2;
        halfnHeight=(HoughIn.nHeight>>1);

        for(j=halfnHeight;j<HoughIn.starty+HoughIn.height-abssidevalue;j++)
        {
            for(i=halfnWidth;i<HoughIn.startx+HoughIn.width;i++)
            {
                if(MAXtemp[0]<HoughIn.ptr_ushort[j*HoughIn.nWidth+i])
                {
                    MAXtemp[0]=HoughIn.ptr_ushort[j*HoughIn.nWidth+i];
                    MAXtheta[0]=j;
                    MAXrho[0]=i;
                }
            }
        }
        for(j=HoughIn.starty+abssidevalue;j<halfnHeight;j++)
        {
            for(i=HoughIn.startx;i<HoughIn.startx+HoughIn.width;i++)
            {
                if(MAXtemp[1]<HoughIn.ptr_ushort[j*HoughIn.nWidth+i])
                {
                    MAXtemp[1]=HoughIn.ptr_ushort[j*HoughIn.nWidth+i];
                    MAXtheta[1]=j;
                    MAXrho[1]=i;
                }
            }
        }
        for(n=0;n<2;n++)
        {
            if(MAXtemp[n]>0)
            {
                L_Point32 pt1,pt2;
                Int32 rho=MAXrho[n];
                Int32 theta=MAXtheta[n];
                Int32 a,b;
                Int32 x0,y0;
                L_Point32 realpt1,realpt2;
                Int16 stx,sty,edx,edy;

                rho=draw_houghrho_to_xyrho(rho,nnWidth,nnHeight);
                a=CV_Cos[theta];
                b=CV_Sin[theta];
                x0=((a*rho)>>16);
                y0=((b*rho)>>16);
                pt1.x=x0-(b<<3);
                pt1.y=y0+(a<<3);
                pt2.x=x0+(b<<3);
                pt2.y=y0-(a<<3);
                if(pt1.y<pt2.y)
                {
                    realpt1=pt1;
                    realpt2=pt2;
                }
                else if(pt1.y>pt2.y)
                {
                    realpt1=pt2;
                    realpt2=pt1;
                }
                else
                {
                    if(pt1.x<=pt2.x)
                    {
                        realpt1=pt1;
                        realpt2=pt2;
                    }
                    else
                    {
                        realpt1=pt2;
                        realpt2=pt1;
                    }
                }
                MyLinetoPoint(nnHeight,nnWidth,realpt1,realpt2,CV_LINE_8LT,1,&conect_buffer3,u8_buffer_x1Temp3);
                if(conect_buffer3.AllMarkPoint[0].PointArea==0)
                {
                    return 1;
                }
                stx=conect_buffer3.AllMarkPoint[0].point[0].x;
                sty=conect_buffer3.AllMarkPoint[0].point[0].y;
                edx=conect_buffer3.AllMarkPoint[0].point[conect_buffer3.AllMarkPoint[0].PointArea-1].x;
                edy=conect_buffer3.AllMarkPoint[0].point[conect_buffer3.AllMarkPoint[0].PointArea-1].y;
                LineOut->line[nowlineTotal].st.x=(Uint16)stx;
                LineOut->line[nowlineTotal].st.y=(Uint16)sty;
                LineOut->line[nowlineTotal].ed.x=(Uint16)edx;
                LineOut->line[nowlineTotal].ed.y=(Uint16)edy;
                LineOut->houghinfo[nowlineTotal].theta=(Uint16)theta;

                LineOut->houghinfo[nowlineTotal].rho=draw_xyrho_to_houghrho(rho,nnWidth,nnHeight);
                nowlineTotal++;
            }
            else
            {
                return 1;
            }
        }
        LineOut->linenum=nowlineTotal;
        return 0;
    }

    Int8 MyHough_to_2sidenonmaxline(Mat HoughIn,Mat matIn,MyCountLine *LineOut,Int32 lineLongmin,Int32 lineGapmax,Int32 value,non_max Mod,Int32 abssidevalue)
    {
        Uint32 halfnWidth;
        Uint32 halfnHeight;
        Uint8 nowlineTotal=0;
        Int32 nnWidth=matIn.nWidth;
        Int32 nnHeight=matIn.nHeight;
        Uint8 *u8_Non_max=(Uint8*)u8_buffer_x3Temp1;
        Mat imnon_max;
        Int32 sidelineLongmax=0;

        Int32 i,j;
        Int32 n=0;
        mhc_hou_lineinfo edge[2];
        memset(edge,0,sizeof(mhc_hou_lineinfo)*2);

        LineOut->nHeight=matIn.nHeight;
        LineOut->nWidth=matIn.nWidth;
        LineOut->startx=matIn.startx;
        LineOut->starty=matIn.starty;
        LineOut->width=matIn.width;
        LineOut->height=matIn.height;
        LineOut->linenum=nowlineTotal;

        imnon_max=MatCreat(MHC_TETARANGE,MHC_ROLENGTH,CCV_8UC1,u8_Non_max);
        MyNon_Maximal(HoughIn,&imnon_max,value,Mod);

        if(matIn._type!=CCV_8UC1
        ||HoughIn._type!=CCV_16UC1
        ||HoughIn.nHeight!=MHC_TETARANGE
        ||HoughIn.nWidth!=MHC_ROLENGTH)
            return 1;

        halfnWidth=(HoughIn.nWidth>>1)-2;
        halfnHeight=(HoughIn.nHeight>>1);


        for(j=halfnHeight;j<imnon_max.starty+imnon_max.height-abssidevalue;j++)
        {
            for(i=halfnWidth;i<imnon_max.startx+imnon_max.width;i++)
            {
                if(imnon_max.data[j*imnon_max.nWidth+i]!=0)
                {
                    L_Point32 pt1,pt2;
                    Int32 rho=i;
                    Int32 theta=j;
                    Int32 a,b;
                    Int32 x0,y0;
                    Int32 startrho;
                    Int32 endrho;
                    Int32 drho;
                    Int32 maxlongsize=0;
                    Int32 maxlongsizerho=0;
                    Int32 maxlongsizenum=0;
                    rho=draw_houghrho_to_xyrho(rho,nnWidth,nnHeight);
                    startrho=-(MHC_SEARCH_SIZE>>1);
                    endrho=(MHC_SEARCH_SIZE>>1);

                    for(drho=startrho;drho<=endrho;drho++)
                    {
                        Int32 longsize;
                        a=CV_Cos[theta];
                        b=CV_Sin[theta];
                        x0=((a*rho)>>16)+((drho*a)>>8);
                        y0=((b*rho)>>16)+((drho*b)>>8);
                        pt1.x=x0-(b<<3);
                        pt1.y=y0+(a<<3);
                        pt2.x=x0+(b<<3);
                        pt2.y=y0-(a<<3);
                        MyLineComperMat(&matIn,pt1,pt2,CV_LINE_8LT,1,lineGapmax,&longsize);
                        if(maxlongsize<longsize)
                        {
                            maxlongsize=longsize;
                            maxlongsizerho=drho;
                            maxlongsizenum=1;
                        }
                        else if(maxlongsize==longsize)
                        {
                            maxlongsizerho=maxlongsizerho+drho;
                            maxlongsizenum++;
                        }
                    }
                    if(maxlongsize>lineLongmin&&maxlongsizenum!=0&&maxlongsize>sidelineLongmax)
                    {
                        Int32 drho=maxlongsizerho/maxlongsizenum;
                        sidelineLongmax=maxlongsize;
                        edge[0].drho=drho;
                        edge[0].maxlongsize=maxlongsize;
                        edge[0].rho=rho;
                        edge[0].theta=theta;
                    }
                }
            }
        }
        sidelineLongmax=0;
        for(j=imnon_max.starty+abssidevalue;j<halfnHeight;j++)
        {
            for(i=imnon_max.startx;i<imnon_max.startx+imnon_max.width;i++)
            {
                if(imnon_max.data[j*imnon_max.nWidth+i]!=0)
                {
                    L_Point32 pt1,pt2;
                    Int32 rho=i;
                    Int32 theta=j;
                    Int32 a,b;
                    Int32 x0,y0;
                    Int32 startrho;
                    Int32 endrho;
                    Int32 drho;
                    Int32 maxlongsize=0;
                    Int32 maxlongsizerho=0;
                    Int32 maxlongsizenum=0;

                    rho=draw_houghrho_to_xyrho(rho,nnWidth,nnHeight);
                    startrho=-(MHC_SEARCH_SIZE>>1);
                    endrho=(MHC_SEARCH_SIZE>>1);

                    for(drho=startrho;drho<=endrho;drho++)
                    {
                        Int32 longsize;
                        a=CV_Cos[theta];
                        b=CV_Sin[theta];
                        x0=((a*rho)>>16)+((drho*a)>>8);
                        y0=((b*rho)>>16)+((drho*b)>>8);
                        pt1.x=x0-(b<<3);
                        pt1.y=y0+(a<<3);
                        pt2.x=x0+(b<<3);
                        pt2.y=y0-(a<<3);
                        MyLineComperMat(&matIn,pt1,pt2,CV_LINE_8LT,1,lineGapmax,&longsize);
                        if(maxlongsize<longsize)
                        {
                            maxlongsize=longsize;
                            maxlongsizerho=drho;
                            maxlongsizenum=1;
                        }
                        else if(maxlongsize==longsize)
                        {
                            maxlongsizerho=maxlongsizerho+drho;
                            maxlongsizenum++;
                        }
                    }
                    if(maxlongsize>lineLongmin&&maxlongsizenum!=0&&maxlongsize>sidelineLongmax)
                    {
                        Int32 drho=maxlongsizerho/maxlongsizenum;
                        sidelineLongmax=maxlongsize;
                        edge[1].drho=drho;
                        edge[1].maxlongsize=maxlongsize;
                        edge[1].rho=rho;
                        edge[1].theta=theta;
                    }
                }
            }
        }
        for(n=0;n<2;n++)
        {
            if(edge[n].maxlongsize!=0)
            {
                Int32 theta=edge[n].theta;
                Int32 rho=edge[n].rho;
                Int32 drho=edge[n].drho;
                Int32 a,b,x0,y0;


                L_Point32 pt1,pt2;
                L_Point32 realpt1,realpt2;
                Int16 stx,sty,edx,edy;

                a=CV_Cos[theta];
                b=CV_Sin[theta];
                x0=((a*rho)>>16)+((drho*a)>>8);
                y0=((b*rho)>>16)+((drho*b)>>8);
                pt1.x=x0-(b<<3);
                pt1.y=y0+(a<<3);
                pt2.x=x0+(b<<3);
                pt2.y=y0-(a<<3);
                MyLineComperMat2(&matIn,pt1,pt2,CV_LINE_8LT,1,lineGapmax,&realpt1,&realpt2);
                stx=realpt1.x;
                sty=realpt1.y;
                edx=realpt2.x;
                edy=realpt2.y;
                LineOut->line[nowlineTotal].st.x=(Uint16)stx;
                LineOut->line[nowlineTotal].st.y=(Uint16)sty;
                LineOut->line[nowlineTotal].ed.x=(Uint16)edx;
                LineOut->line[nowlineTotal].ed.y=(Uint16)edy;
                LineOut->houghinfo[nowlineTotal].theta=(Uint16)theta;
                LineOut->houghinfo[nowlineTotal].rho=draw_xyrho_to_houghrho(rho,nnWidth,nnHeight);
                nowlineTotal++;
            }
        }
        LineOut->linenum=nowlineTotal;
        return 0;
    }

    Int8 MyconvertDataTo(Mat matIn,Mat *matOut,type Mod)
    {
        Int32 nnHeight=matIn.nHeight;
        Int32 nnWidth=matIn.nWidth;
        Int32 size=nnHeight*nnWidth;
        Int32 i;
        Int32 i32_value;
        Int32 i32_value1,i32_value2,i32_value3;
        float f_value;
        double d_value;
        matOut->nWidth=matIn.nWidth;
        matOut->nHeight=matIn.nHeight;
        matOut->nWidth=matIn.nWidth;
        matOut->nHeight=matIn.nHeight;
        matOut->startx=matIn.startx;
        matOut->starty=matIn.starty;
        matOut->width=matIn.width;
        matOut->height=matIn.height;
        MyconvertTo(matOut,Mod);
        switch(matIn._type)
        {
            case CCV_8UC1:
                switch(matOut->_type)
                {
                    case CCV_8UC1:
                        memcpy(matOut->ptr_uchar,matIn.ptr_uchar,size*getsizeof(CCV_8UC1));
                    break;
                    case CCV_8UC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3b[i].data1=matIn.ptr_uchar[i];
                            matOut->ptr_Vec3b[i].data2=matIn.ptr_uchar[i];
                            matOut->ptr_Vec3b[i].data3=matIn.ptr_uchar[i];
                        }
                    break;
                    case CCV_8SC1:
                        memcpy(matOut->ptr_char,matIn.ptr_uchar,size*getsizeof(CCV_8SC1));
                    break;
                    case CCV_8SC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3ib[i].data1=matIn.ptr_uchar[i];
                            matOut->ptr_Vec3ib[i].data2=matIn.ptr_uchar[i];
                            matOut->ptr_Vec3ib[i].data3=matIn.ptr_uchar[i];
                        }
                    break;
                    case CCV_16UC1:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_ushort[i]=matIn.ptr_uchar[i];
                        }
                    break;
                    case CCV_16UC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3s[i].data1=matIn.ptr_uchar[i];
                            matOut->ptr_Vec3s[i].data2=matIn.ptr_uchar[i];
                            matOut->ptr_Vec3s[i].data3=matIn.ptr_uchar[i];
                        }
                    break;
                    case CCV_16SC1:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_short[i]=matIn.ptr_uchar[i];
                        }
                    break;
                    case CCV_16SC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3w[i].data1=matIn.ptr_uchar[i];
                            matOut->ptr_Vec3w[i].data2=matIn.ptr_uchar[i];
                            matOut->ptr_Vec3w[i].data3=matIn.ptr_uchar[i];
                        }
                    break;
                    case CCV_32SC1:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_int[i]=matIn.ptr_uchar[i];
                        }
                    break;
                    case CCV_32SC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3i[i].data1=matIn.ptr_uchar[i];
                            matOut->ptr_Vec3i[i].data2=matIn.ptr_uchar[i];
                            matOut->ptr_Vec3i[i].data3=matIn.ptr_uchar[i];
                        }
                    break;
                    case CCV_32FC1:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_float[i]=matIn.ptr_uchar[i];
                        }
                    break;
                    case CCV_32FC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3f[i].data1=matIn.ptr_uchar[i];
                            matOut->ptr_Vec3f[i].data2=matIn.ptr_uchar[i];
                            matOut->ptr_Vec3f[i].data3=matIn.ptr_uchar[i];
                        }
                    break;
                    case CCV_64FC1:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_double[i]=matIn.ptr_uchar[i];
                        }
                    break;
                    case CCV_64FC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3d[i].data1=matIn.ptr_uchar[i];
                            matOut->ptr_Vec3d[i].data2=matIn.ptr_uchar[i];
                            matOut->ptr_Vec3d[i].data3=matIn.ptr_uchar[i];
                        }
                    break;
                    default:
                        return 1;
                    break;
                }
            break;
            case CCV_8UC3:
                switch(matOut->_type)
                {
                    case CCV_8UC1:
                        for(i=0;i<size;i++)
                        {
                            i32_value=(Int32)((matIn.ptr_Vec3b[i].data1+matIn.ptr_Vec3b[i].data2+matIn.ptr_Vec3b[i].data3)/3.0+0.5);
                            matOut->ptr_uchar[i]=(Uint8)i32_value;
                        }
                    break;
                    case CCV_8UC3:
                        memcpy(matOut->ptr_Vec3b,matIn.ptr_Vec3b,size*getsizeof(CCV_8UC3));
                    break;
                    case CCV_8SC1:
                        for(i=0;i<size;i++)
                        {
                            i32_value=(Int32)((matIn.ptr_Vec3b[i].data1+matIn.ptr_Vec3b[i].data2+matIn.ptr_Vec3b[i].data3)/3.0+0.5);
                            matOut->ptr_char[i]=(Int8)i32_value;
                        }
                    break;
                    case CCV_8SC3:
                        memcpy(matOut->ptr_Vec3ib,matIn.ptr_Vec3b,size*getsizeof(CCV_8SC3));
                    break;
                    case CCV_16UC1:
                        for(i=0;i<size;i++)
                        {
                            i32_value=(Int32)((matIn.ptr_Vec3b[i].data1+matIn.ptr_Vec3b[i].data2+matIn.ptr_Vec3b[i].data3)/3.0+0.5);
                            matOut->ptr_ushort[i]=(Uint16)i32_value;
                        }
                    break;
                    case CCV_16UC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3s[i].data1=matIn.ptr_Vec3b[i].data1;
                            matOut->ptr_Vec3s[i].data2=matIn.ptr_Vec3b[i].data2;
                            matOut->ptr_Vec3s[i].data3=matIn.ptr_Vec3b[i].data3;
                        }
                    break;
                    case CCV_16SC1:
                        for(i=0;i<size;i++)
                        {
                            i32_value=(Int32)((matIn.ptr_Vec3b[i].data1+matIn.ptr_Vec3b[i].data2+matIn.ptr_Vec3b[i].data3)/3.0+0.5);
                            matOut->ptr_short[i]=(Int16)i32_value;
                        }
                    break;
                    case CCV_16SC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3w[i].data1=matIn.ptr_Vec3b[i].data1;
                            matOut->ptr_Vec3w[i].data2=matIn.ptr_Vec3b[i].data2;
                            matOut->ptr_Vec3w[i].data3=matIn.ptr_Vec3b[i].data3;
                        }
                    break;
                    case CCV_32SC1:
                        for(i=0;i<size;i++)
                        {
                            i32_value=(Int32)((matIn.ptr_Vec3b[i].data1+matIn.ptr_Vec3b[i].data2+matIn.ptr_Vec3b[i].data3)/3.0+0.5);
                            matOut->ptr_int[i]=i32_value;
                        }
                    break;
                    case CCV_32SC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3i[i].data1=matIn.ptr_Vec3b[i].data1;
                            matOut->ptr_Vec3i[i].data2=matIn.ptr_Vec3b[i].data2;
                            matOut->ptr_Vec3i[i].data3=matIn.ptr_Vec3b[i].data3;
                        }
                    break;
                    case CCV_32FC1:
                        for(i=0;i<size;i++)
                        {
                            f_value=(matIn.ptr_Vec3b[i].data1+matIn.ptr_Vec3b[i].data2+matIn.ptr_Vec3b[i].data3)/3.0;
                            matOut->ptr_float[i]=f_value;
                        }
                    break;
                    case CCV_32FC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3f[i].data1=matIn.ptr_Vec3b[i].data1;
                            matOut->ptr_Vec3f[i].data2=matIn.ptr_Vec3b[i].data2;
                            matOut->ptr_Vec3f[i].data3=matIn.ptr_Vec3b[i].data3;
                        }
                    break;
                    case CCV_64FC1:
                        for(i=0;i<size;i++)
                        {
                            d_value=(matIn.ptr_Vec3b[i].data1+matIn.ptr_Vec3b[i].data2+matIn.ptr_Vec3b[i].data3)/3.0;
                            matOut->ptr_double[i]=d_value;
                        }
                    break;
                    case CCV_64FC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3d[i].data1=matIn.ptr_Vec3b[i].data1;
                            matOut->ptr_Vec3d[i].data2=matIn.ptr_Vec3b[i].data2;
                            matOut->ptr_Vec3d[i].data3=matIn.ptr_Vec3b[i].data3;
                        }
                    break;
                    default:
                        return 1;
                    break;
                }
            break;
            case CCV_8SC1:
                switch(matOut->_type)
                {
                    case CCV_8UC1:
                        memcpy(matOut->ptr_uchar,matIn.ptr_char,size*getsizeof(CCV_8UC1));
                    break;
                    case CCV_8UC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3b[i].data1=(Uint8)matIn.ptr_char[i];
                            matOut->ptr_Vec3b[i].data2=(Uint8)matIn.ptr_char[i];
                            matOut->ptr_Vec3b[i].data3=(Uint8)matIn.ptr_char[i];
                        }
                    break;
                    case CCV_8SC1:
                        memcpy(matOut->ptr_char,matIn.ptr_char,size*getsizeof(CCV_8SC1));
                    break;
                    case CCV_8SC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3ib[i].data1=matIn.ptr_char[i];
                            matOut->ptr_Vec3ib[i].data2=matIn.ptr_char[i];
                            matOut->ptr_Vec3ib[i].data3=matIn.ptr_char[i];
                        }
                    break;
                    case CCV_16UC1:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_ushort[i]=matIn.ptr_char[i];
                        }
                    break;
                    case CCV_16UC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3s[i].data1=matIn.ptr_char[i];
                            matOut->ptr_Vec3s[i].data2=matIn.ptr_char[i];
                            matOut->ptr_Vec3s[i].data3=matIn.ptr_char[i];
                        }
                    break;
                    case CCV_16SC1:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_short[i]=matIn.ptr_char[i];
                        }
                    break;
                    case CCV_16SC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3w[i].data1=matIn.ptr_char[i];
                            matOut->ptr_Vec3w[i].data2=matIn.ptr_char[i];
                            matOut->ptr_Vec3w[i].data3=matIn.ptr_char[i];
                        }
                    break;
                    case CCV_32SC1:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_int[i]=matIn.ptr_char[i];
                        }
                    break;
                    case CCV_32SC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3i[i].data1=matIn.ptr_char[i];
                            matOut->ptr_Vec3i[i].data2=matIn.ptr_char[i];
                            matOut->ptr_Vec3i[i].data3=matIn.ptr_char[i];
                        }
                    break;
                    case CCV_32FC1:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_float[i]=matIn.ptr_char[i];
                        }
                    break;
                    case CCV_32FC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3f[i].data1=matIn.ptr_char[i];
                            matOut->ptr_Vec3f[i].data2=matIn.ptr_char[i];
                            matOut->ptr_Vec3f[i].data3=matIn.ptr_char[i];
                        }
                    break;
                    case CCV_64FC1:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_double[i]=matIn.ptr_char[i];
                        }
                    break;
                    case CCV_64FC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3d[i].data1=matIn.ptr_char[i];
                            matOut->ptr_Vec3d[i].data2=matIn.ptr_char[i];
                            matOut->ptr_Vec3d[i].data3=matIn.ptr_char[i];
                        }
                    break;
                    default:
                        return 1;
                    break;
                }
            break;
            case CCV_8SC3:
                switch(matOut->_type)
                {
                    case CCV_8UC1:
                        for(i=0;i<size;i++)
                        {
                            i32_value=(Int32)((matIn.ptr_Vec3ib[i].data1+matIn.ptr_Vec3ib[i].data2+matIn.ptr_Vec3ib[i].data3)/3.0+0.5);
                            matOut->ptr_uchar[i]=(Uint8)i32_value;
                        }
                    break;
                    case CCV_8UC3:
                        memcpy(matOut->ptr_Vec3b,matIn.ptr_Vec3ib,size*getsizeof(CCV_8UC3));
                    break;
                    case CCV_8SC1:
                        for(i=0;i<size;i++)
                        {
                            i32_value=(Int32)((matIn.ptr_Vec3ib[i].data1+matIn.ptr_Vec3ib[i].data2+matIn.ptr_Vec3ib[i].data3)/3.0+0.5);
                            matOut->ptr_char[i]=(Int8)i32_value;
                        }
                    break;
                    case CCV_8SC3:
                        memcpy(matOut->ptr_Vec3ib,matIn.ptr_Vec3ib,size*getsizeof(CCV_8SC3));
                    break;
                    case CCV_16UC1:
                        for(i=0;i<size;i++)
                        {
                            i32_value=(Int32)((matIn.ptr_Vec3ib[i].data1+matIn.ptr_Vec3ib[i].data2+matIn.ptr_Vec3ib[i].data3)/3.0+0.5);
                            matOut->ptr_ushort[i]=(Uint16)i32_value;
                        }
                    break;
                    case CCV_16UC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3s[i].data1=matIn.ptr_Vec3ib[i].data1;
                            matOut->ptr_Vec3s[i].data2=matIn.ptr_Vec3ib[i].data2;
                            matOut->ptr_Vec3s[i].data3=matIn.ptr_Vec3ib[i].data3;
                        }
                    break;
                    case CCV_16SC1:
                        for(i=0;i<size;i++)
                        {
                            i32_value=(Int32)((matIn.ptr_Vec3ib[i].data1+matIn.ptr_Vec3ib[i].data2+matIn.ptr_Vec3ib[i].data3)/3.0+0.5);
                            matOut->ptr_short[i]=(Int16)i32_value;
                        }
                    break;
                    case CCV_16SC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3w[i].data1=matIn.ptr_Vec3ib[i].data1;
                            matOut->ptr_Vec3w[i].data2=matIn.ptr_Vec3ib[i].data2;
                            matOut->ptr_Vec3w[i].data3=matIn.ptr_Vec3ib[i].data3;
                        }
                    break;
                    case CCV_32SC1:
                        for(i=0;i<size;i++)
                        {
                            i32_value=(Int32)((matIn.ptr_Vec3ib[i].data1+matIn.ptr_Vec3ib[i].data2+matIn.ptr_Vec3ib[i].data3)/3.0+0.5);
                            matOut->ptr_int[i]=i32_value;
                        }
                    break;
                    case CCV_32SC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3i[i].data1=matIn.ptr_Vec3ib[i].data1;
                            matOut->ptr_Vec3i[i].data2=matIn.ptr_Vec3ib[i].data2;
                            matOut->ptr_Vec3i[i].data3=matIn.ptr_Vec3ib[i].data3;
                        }
                    break;
                    case CCV_32FC1:
                        for(i=0;i<size;i++)
                        {
                            f_value=(matIn.ptr_Vec3ib[i].data1+matIn.ptr_Vec3ib[i].data2+matIn.ptr_Vec3ib[i].data3)/3.0;
                            matOut->ptr_float[i]=f_value;
                        }
                    break;
                    case CCV_32FC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3f[i].data1=matIn.ptr_Vec3ib[i].data1;
                            matOut->ptr_Vec3f[i].data2=matIn.ptr_Vec3ib[i].data2;
                            matOut->ptr_Vec3f[i].data3=matIn.ptr_Vec3ib[i].data3;
                        }
                    break;
                    case CCV_64FC1:
                        for(i=0;i<size;i++)
                        {
                            d_value=(matIn.ptr_Vec3ib[i].data1+matIn.ptr_Vec3ib[i].data2+matIn.ptr_Vec3ib[i].data3)/3.0;
                            matOut->ptr_double[i]=d_value;
                        }
                    break;
                    case CCV_64FC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3d[i].data1=matIn.ptr_Vec3ib[i].data1;
                            matOut->ptr_Vec3d[i].data2=matIn.ptr_Vec3ib[i].data2;
                            matOut->ptr_Vec3d[i].data3=matIn.ptr_Vec3ib[i].data3;
                        }
                    break;
                    default:
                        return 1;
                    break;
                }
            break;
            case CCV_16UC1:
                switch(matOut->_type)
                {
                    case CCV_8UC1:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_uchar[i]=(Uint8)matIn.ptr_ushort[i];
                        }
                    break;
                    case CCV_8UC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3b[i].data1=(Uint8)matIn.ptr_ushort[i];
                            matOut->ptr_Vec3b[i].data2=(Uint8)matIn.ptr_ushort[i];
                            matOut->ptr_Vec3b[i].data3=(Uint8)matIn.ptr_ushort[i];
                        }
                    break;
                    case CCV_8SC1:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_char[i]=(Int8)matIn.ptr_ushort[i];
                        }
                    break;
                    case CCV_8SC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3ib[i].data1=(Int8)matIn.ptr_ushort[i];
                            matOut->ptr_Vec3ib[i].data2=(Int8)matIn.ptr_ushort[i];
                            matOut->ptr_Vec3ib[i].data3=(Int8)matIn.ptr_ushort[i];
                        }
                    break;
                    case CCV_16UC1:
                        memcpy(matOut->ptr_ushort,matIn.ptr_ushort,size*getsizeof(CCV_16UC1));
                    break;
                    case CCV_16UC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3s[i].data1=matIn.ptr_ushort[i];
                            matOut->ptr_Vec3s[i].data2=matIn.ptr_ushort[i];
                            matOut->ptr_Vec3s[i].data3=matIn.ptr_ushort[i];
                        }
                    break;
                    case CCV_16SC1:
                        memcpy(matOut->ptr_short,matIn.ptr_ushort,size*getsizeof(CCV_16SC1));
                    break;
                    case CCV_16SC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3w[i].data1=matIn.ptr_ushort[i];
                            matOut->ptr_Vec3w[i].data2=matIn.ptr_ushort[i];
                            matOut->ptr_Vec3w[i].data3=matIn.ptr_ushort[i];
                        }
                    break;
                    case CCV_32SC1:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_int[i]=matIn.ptr_ushort[i];
                        }
                    break;
                    case CCV_32SC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3i[i].data1=matIn.ptr_ushort[i];
                            matOut->ptr_Vec3i[i].data2=matIn.ptr_ushort[i];
                            matOut->ptr_Vec3i[i].data3=matIn.ptr_ushort[i];
                        }
                    break;
                    case CCV_32FC1:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_float[i]=matIn.ptr_ushort[i];
                        }
                    break;
                    case CCV_32FC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3f[i].data1=matIn.ptr_ushort[i];
                            matOut->ptr_Vec3f[i].data2=matIn.ptr_ushort[i];
                            matOut->ptr_Vec3f[i].data3=matIn.ptr_ushort[i];
                        }
                    break;
                    case CCV_64FC1:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_double[i]=matIn.ptr_ushort[i];
                        }
                    break;
                    case CCV_64FC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3d[i].data1=matIn.ptr_ushort[i];
                            matOut->ptr_Vec3d[i].data2=matIn.ptr_ushort[i];
                            matOut->ptr_Vec3d[i].data3=matIn.ptr_ushort[i];
                        }
                    break;
                    default:
                        return 1;
                    break;
                }
            break;
            case CCV_16UC3:
                switch(matOut->_type)
                {
                    case CCV_8UC1:
                        for(i=0;i<size;i++)
                        {
                            i32_value=(Int32)((matIn.ptr_Vec3s[i].data1+matIn.ptr_Vec3s[i].data2+matIn.ptr_Vec3s[i].data3)/3.0+0.5);
                            matOut->ptr_uchar[i]=(Uint8)i32_value;
                        }
                    break;
                    case CCV_8UC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3b[i].data1=(Uint8)matIn.ptr_Vec3s[i].data1;
                            matOut->ptr_Vec3b[i].data2=(Uint8)matIn.ptr_Vec3s[i].data2;
                            matOut->ptr_Vec3b[i].data3=(Uint8)matIn.ptr_Vec3s[i].data3;
                        }
                    break;
                    case CCV_8SC1:
                        for(i=0;i<size;i++)
                        {
                            i32_value=(Int32)((matIn.ptr_Vec3s[i].data1+matIn.ptr_Vec3s[i].data2+matIn.ptr_Vec3s[i].data3)/3.0+0.5);
                            matOut->ptr_char[i]=(Int8)i32_value;
                        }
                    break;
                    case CCV_8SC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3ib[i].data1=(Int8)matIn.ptr_Vec3s[i].data1;
                            matOut->ptr_Vec3ib[i].data2=(Int8)matIn.ptr_Vec3s[i].data2;
                            matOut->ptr_Vec3ib[i].data3=(Int8)matIn.ptr_Vec3s[i].data3;
                        }
                    break;
                    case CCV_16UC1:
                        for(i=0;i<size;i++)
                        {
                            i32_value=(Int32)((matIn.ptr_Vec3s[i].data1+matIn.ptr_Vec3s[i].data2+matIn.ptr_Vec3s[i].data3)/3.0+0.5);
                            matOut->ptr_ushort[i]=(Uint16)i32_value;
                        }
                    break;
                    case CCV_16UC3:
                        memcpy(matOut->ptr_Vec3s,matIn.ptr_Vec3s,size*getsizeof(CCV_16UC3));
                    break;
                    case CCV_16SC1:
                        for(i=0;i<size;i++)
                        {
                            i32_value=(Int32)((matIn.ptr_Vec3s[i].data1+matIn.ptr_Vec3s[i].data2+matIn.ptr_Vec3s[i].data3)/3.0+0.5);
                            matOut->ptr_short[i]=(Int16)i32_value;
                        }
                    break;
                    case CCV_16SC3:
                        memcpy(matOut->ptr_Vec3w,matIn.ptr_Vec3s,size*getsizeof(CCV_16SC3));
                    break;
                    case CCV_32SC1:
                        for(i=0;i<size;i++)
                        {
                            i32_value=(Int32)((matIn.ptr_Vec3s[i].data1+matIn.ptr_Vec3s[i].data2+matIn.ptr_Vec3s[i].data3)/3.0+0.5);
                            matOut->ptr_int[i]=i32_value;
                        }
                    break;
                    case CCV_32SC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3i[i].data1=matIn.ptr_Vec3s[i].data1;
                            matOut->ptr_Vec3i[i].data2=matIn.ptr_Vec3s[i].data2;
                            matOut->ptr_Vec3i[i].data3=matIn.ptr_Vec3s[i].data3;
                        }
                    break;
                    case CCV_32FC1:
                        for(i=0;i<size;i++)
                        {
                            f_value=(matIn.ptr_Vec3s[i].data1+matIn.ptr_Vec3s[i].data2+matIn.ptr_Vec3s[i].data3)/3.0;
                            matOut->ptr_float[i]=f_value;
                        }
                    break;
                    case CCV_32FC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3f[i].data1=matIn.ptr_Vec3s[i].data1;
                            matOut->ptr_Vec3f[i].data2=matIn.ptr_Vec3s[i].data2;
                            matOut->ptr_Vec3f[i].data3=matIn.ptr_Vec3s[i].data3;
                        }
                    break;
                    case CCV_64FC1:
                        for(i=0;i<size;i++)
                        {
                            d_value=(matIn.ptr_Vec3s[i].data1+matIn.ptr_Vec3s[i].data2+matIn.ptr_Vec3s[i].data3)/3.0;
                            matOut->ptr_double[i]=d_value;
                        }
                    break;
                    case CCV_64FC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3d[i].data1=matIn.ptr_Vec3s[i].data1;
                            matOut->ptr_Vec3d[i].data2=matIn.ptr_Vec3s[i].data2;
                            matOut->ptr_Vec3d[i].data3=matIn.ptr_Vec3s[i].data3;
                        }
                    break;
                    default:
                        return 1;
                    break;
                }
            break;
            case CCV_16SC1:
                switch(matOut->_type)
                {
                    case CCV_8UC1:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_uchar[i]=(Uint8)matIn.ptr_short[i];
                        }
                    break;
                    case CCV_8UC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3b[i].data1=(Uint8)matIn.ptr_short[i];
                            matOut->ptr_Vec3b[i].data2=(Uint8)matIn.ptr_short[i];
                            matOut->ptr_Vec3b[i].data3=(Uint8)matIn.ptr_short[i];
                        }
                    break;
                    case CCV_8SC1:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_char[i]=(Int8)matIn.ptr_short[i];
                        }
                    break;
                    case CCV_8SC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3ib[i].data1=(Int8)matIn.ptr_short[i];
                            matOut->ptr_Vec3ib[i].data2=(Int8)matIn.ptr_short[i];
                            matOut->ptr_Vec3ib[i].data3=(Int8)matIn.ptr_short[i];
                        }
                    break;
                    case CCV_16UC1:
                        memcpy(matOut->ptr_ushort,matIn.ptr_short,size*getsizeof(CCV_16UC1));
                    break;
                    case CCV_16UC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3s[i].data1=matIn.ptr_short[i];
                            matOut->ptr_Vec3s[i].data2=matIn.ptr_short[i];
                            matOut->ptr_Vec3s[i].data3=matIn.ptr_short[i];
                        }
                    break;
                    case CCV_16SC1:
                        memcpy(matOut->ptr_short,matIn.ptr_short,size*getsizeof(CCV_16SC1));
                    break;
                    case CCV_16SC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3w[i].data1=matIn.ptr_short[i];
                            matOut->ptr_Vec3w[i].data2=matIn.ptr_short[i];
                            matOut->ptr_Vec3w[i].data3=matIn.ptr_short[i];
                        }
                    break;
                    case CCV_32SC1:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_int[i]=matIn.ptr_short[i];
                        }
                    break;
                    case CCV_32SC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3i[i].data1=matIn.ptr_short[i];
                            matOut->ptr_Vec3i[i].data2=matIn.ptr_short[i];
                            matOut->ptr_Vec3i[i].data3=matIn.ptr_short[i];
                        }
                    break;
                    case CCV_32FC1:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_float[i]=matIn.ptr_short[i];
                        }
                    break;
                    case CCV_32FC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3f[i].data1=matIn.ptr_short[i];
                            matOut->ptr_Vec3f[i].data2=matIn.ptr_short[i];
                            matOut->ptr_Vec3f[i].data3=matIn.ptr_short[i];
                        }
                    break;
                    case CCV_64FC1:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_double[i]=matIn.ptr_short[i];
                        }
                    break;
                    case CCV_64FC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3d[i].data1=matIn.ptr_short[i];
                            matOut->ptr_Vec3d[i].data2=matIn.ptr_short[i];
                            matOut->ptr_Vec3d[i].data3=matIn.ptr_short[i];
                        }
                    break;
                    default:
                        return 1;
                    break;
                }
            break;
            case CCV_16SC3:
                switch(matOut->_type)
                {
                    case CCV_8UC1:
                        for(i=0;i<size;i++)
                        {
                            i32_value=(Int32)((matIn.ptr_Vec3w[i].data1+matIn.ptr_Vec3w[i].data2+matIn.ptr_Vec3w[i].data3)/3.0+0.5);
                            matOut->ptr_uchar[i]=(Uint8)i32_value;
                        }
                    break;
                    case CCV_8UC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3b[i].data1=(Uint8)matIn.ptr_Vec3w[i].data1;
                            matOut->ptr_Vec3b[i].data2=(Uint8)matIn.ptr_Vec3w[i].data2;
                            matOut->ptr_Vec3b[i].data3=(Uint8)matIn.ptr_Vec3w[i].data3;
                        }
                    break;
                    case CCV_8SC1:
                        for(i=0;i<size;i++)
                        {
                            i32_value=(Int32)((matIn.ptr_Vec3w[i].data1+matIn.ptr_Vec3w[i].data2+matIn.ptr_Vec3w[i].data3)/3.0+0.5);
                            matOut->ptr_char[i]=(Int8)i32_value;
                        }
                    break;
                    case CCV_8SC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3ib[i].data1=(Int8)matIn.ptr_Vec3w[i].data1;
                            matOut->ptr_Vec3ib[i].data2=(Int8)matIn.ptr_Vec3w[i].data2;
                            matOut->ptr_Vec3ib[i].data3=(Int8)matIn.ptr_Vec3w[i].data3;
                        }
                    break;
                    case CCV_16UC1:
                        for(i=0;i<size;i++)
                        {
                            i32_value=(Int32)((matIn.ptr_Vec3w[i].data1+matIn.ptr_Vec3w[i].data2+matIn.ptr_Vec3w[i].data3)/3.0+0.5);
                            matOut->ptr_ushort[i]=(Uint16)i32_value;
                        }
                    break;
                    case CCV_16UC3:
                        memcpy(matOut->ptr_Vec3s,matIn.ptr_Vec3w,size*getsizeof(CCV_16UC3));
                    break;
                    case CCV_16SC1:
                        for(i=0;i<size;i++)
                        {
                            i32_value=(Int32)((matIn.ptr_Vec3w[i].data1+matIn.ptr_Vec3w[i].data2+matIn.ptr_Vec3w[i].data3)/3.0+0.5);
                            matOut->ptr_short[i]=(Int16)i32_value;
                        }
                    break;
                    case CCV_16SC3:
                        memcpy(matOut->ptr_Vec3w,matIn.ptr_Vec3w,size*getsizeof(CCV_16SC3));
                    break;
                    case CCV_32SC1:
                        for(i=0;i<size;i++)
                        {
                            i32_value=(Int32)((matIn.ptr_Vec3w[i].data1+matIn.ptr_Vec3w[i].data2+matIn.ptr_Vec3w[i].data3)/3.0+0.5);
                            matOut->ptr_int[i]=i32_value;
                        }
                    break;
                    case CCV_32SC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3i[i].data1=matIn.ptr_Vec3w[i].data1;
                            matOut->ptr_Vec3i[i].data2=matIn.ptr_Vec3w[i].data2;
                            matOut->ptr_Vec3i[i].data3=matIn.ptr_Vec3w[i].data3;
                        }
                    break;
                    case CCV_32FC1:
                        for(i=0;i<size;i++)
                        {
                            f_value=(matIn.ptr_Vec3w[i].data1+matIn.ptr_Vec3w[i].data2+matIn.ptr_Vec3w[i].data3)/3.0;
                            matOut->ptr_float[i]=f_value;
                        }
                    break;
                    case CCV_32FC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3f[i].data1=matIn.ptr_Vec3w[i].data1;
                            matOut->ptr_Vec3f[i].data2=matIn.ptr_Vec3w[i].data2;
                            matOut->ptr_Vec3f[i].data3=matIn.ptr_Vec3w[i].data3;
                        }
                    break;
                    case CCV_64FC1:
                        for(i=0;i<size;i++)
                        {
                            d_value=(matIn.ptr_Vec3w[i].data1+matIn.ptr_Vec3w[i].data2+matIn.ptr_Vec3w[i].data3)/3.0;
                            matOut->ptr_double[i]=d_value;
                        }
                    break;
                    case CCV_64FC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3d[i].data1=matIn.ptr_Vec3w[i].data1;
                            matOut->ptr_Vec3d[i].data2=matIn.ptr_Vec3w[i].data2;
                            matOut->ptr_Vec3d[i].data3=matIn.ptr_Vec3w[i].data3;
                        }
                    break;
                    default:
                        return 1;
                    break;
                }
            break;
            case CCV_32SC1:
                switch(matOut->_type)
                {
                    case CCV_8UC1:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_uchar[i]=(Uint8)matIn.ptr_int[i];
                        }
                    break;
                    case CCV_8UC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3b[i].data1=(Uint8)matIn.ptr_int[i];
                            matOut->ptr_Vec3b[i].data2=(Uint8)matIn.ptr_int[i];
                            matOut->ptr_Vec3b[i].data3=(Uint8)matIn.ptr_int[i];
                        }
                    break;
                    case CCV_8SC1:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_char[i]=(Int8)matIn.ptr_int[i];
                        }
                    break;
                    case CCV_8SC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3ib[i].data1=(Int8)matIn.ptr_int[i];
                            matOut->ptr_Vec3ib[i].data2=(Int8)matIn.ptr_int[i];
                            matOut->ptr_Vec3ib[i].data3=(Int8)matIn.ptr_int[i];
                        }
                    break;
                    case CCV_16UC1:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_ushort[i]=(Uint16)matIn.ptr_int[i];
                        }
                    break;
                    case CCV_16UC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3s[i].data1=(Uint16)matIn.ptr_int[i];
                            matOut->ptr_Vec3s[i].data2=(Uint16)matIn.ptr_int[i];
                            matOut->ptr_Vec3s[i].data3=(Uint16)matIn.ptr_int[i];
                        }
                    break;
                    case CCV_16SC1:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_short[i]=(Int16)matIn.ptr_int[i];
                        }
                    break;
                    case CCV_16SC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3w[i].data1=(Int16)matIn.ptr_int[i];
                            matOut->ptr_Vec3w[i].data2=(Int16)matIn.ptr_int[i];
                            matOut->ptr_Vec3w[i].data3=(Int16)matIn.ptr_int[i];
                        }
                    break;
                    case CCV_32SC1:
                        memcpy(matOut->ptr_int,matIn.ptr_int,size*getsizeof(CCV_32SC1));
                    break;
                    case CCV_32SC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3i[i].data1=matIn.ptr_int[i];
                            matOut->ptr_Vec3i[i].data2=matIn.ptr_int[i];
                            matOut->ptr_Vec3i[i].data3=matIn.ptr_int[i];
                        }
                    break;
                    case CCV_32FC1:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_float[i]=matIn.ptr_int[i];
                        }
                    break;
                    case CCV_32FC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3f[i].data1=matIn.ptr_int[i];
                            matOut->ptr_Vec3f[i].data2=matIn.ptr_int[i];
                            matOut->ptr_Vec3f[i].data3=matIn.ptr_int[i];
                        }
                    break;
                    case CCV_64FC1:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_double[i]=matIn.ptr_int[i];
                        }
                    break;
                    case CCV_64FC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3d[i].data1=matIn.ptr_int[i];
                            matOut->ptr_Vec3d[i].data2=matIn.ptr_int[i];
                            matOut->ptr_Vec3d[i].data3=matIn.ptr_int[i];
                        }
                    break;
                    default:
                        return 1;
                    break;
                }
            break;
            case CCV_32SC3:
                switch(matOut->_type)
                {
                    case CCV_8UC1:
                        for(i=0;i<size;i++)
                        {
                            i32_value=((matIn.ptr_Vec3i[i].data1+matIn.ptr_Vec3i[i].data2+matIn.ptr_Vec3i[i].data3)/3.0+0.5);
                            matOut->ptr_uchar[i]=(Uint8)i32_value;
                        }
                    break;
                    case CCV_8UC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3b[i].data1=(Uint8)matIn.ptr_Vec3i[i].data1;
                            matOut->ptr_Vec3b[i].data2=(Uint8)matIn.ptr_Vec3i[i].data2;
                            matOut->ptr_Vec3b[i].data3=(Uint8)matIn.ptr_Vec3i[i].data3;
                        }
                    break;
                    case CCV_8SC1:
                        for(i=0;i<size;i++)
                        {
                            i32_value=((matIn.ptr_Vec3i[i].data1+matIn.ptr_Vec3i[i].data2+matIn.ptr_Vec3i[i].data3)/3.0+0.5);
                            matOut->ptr_char[i]=(Int8)i32_value;
                        }
                    break;
                    case CCV_8SC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3ib[i].data1=(Int8)matIn.ptr_Vec3i[i].data1;
                            matOut->ptr_Vec3ib[i].data2=(Int8)matIn.ptr_Vec3i[i].data2;
                            matOut->ptr_Vec3ib[i].data3=(Int8)matIn.ptr_Vec3i[i].data3;
                        }
                    break;
                    case CCV_16UC1:
                        for(i=0;i<size;i++)
                        {
                            i32_value=((matIn.ptr_Vec3i[i].data1+matIn.ptr_Vec3i[i].data2+matIn.ptr_Vec3i[i].data3)/3.0+0.5);
                            matOut->ptr_ushort[i]=(Uint16)i32_value;
                        }
                    break;
                    case CCV_16UC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3s[i].data1=(Uint16)matIn.ptr_Vec3i[i].data1;
                            matOut->ptr_Vec3s[i].data2=(Uint16)matIn.ptr_Vec3i[i].data2;
                            matOut->ptr_Vec3s[i].data3=(Uint16)matIn.ptr_Vec3i[i].data3;
                        }
                    break;
                    case CCV_16SC1:
                        for(i=0;i<size;i++)
                        {
                            i32_value=((matIn.ptr_Vec3i[i].data1+matIn.ptr_Vec3i[i].data2+matIn.ptr_Vec3i[i].data3)/3.0+0.5);
                            matOut->ptr_short[i]=(Int16)i32_value;
                        }
                    break;
                    case CCV_16SC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3w[i].data1=(Int16)matIn.ptr_Vec3i[i].data1;
                            matOut->ptr_Vec3w[i].data2=(Int16)matIn.ptr_Vec3i[i].data2;
                            matOut->ptr_Vec3w[i].data3=(Int16)matIn.ptr_Vec3i[i].data3;
                        }
                    break;
                    case CCV_32SC1:
                        for(i=0;i<size;i++)
                        {
                            i32_value=((matIn.ptr_Vec3i[i].data1+matIn.ptr_Vec3i[i].data2+matIn.ptr_Vec3i[i].data3)/3.0+0.5);
                            matOut->ptr_int[i]=i32_value;
                        }
                    break;
                    case CCV_32SC3:
                        memcpy(matOut->ptr_Vec3i,matIn.ptr_Vec3i,size*getsizeof(CCV_32SC3));
                    break;
                    case CCV_32FC1:
                        for(i=0;i<size;i++)
                        {
                            f_value=(matIn.ptr_Vec3i[i].data1+matIn.ptr_Vec3i[i].data2+matIn.ptr_Vec3i[i].data3)/3.0;
                            matOut->ptr_float[i]=f_value;
                        }
                    break;
                    case CCV_32FC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3f[i].data1=matIn.ptr_Vec3i[i].data1;
                            matOut->ptr_Vec3f[i].data2=matIn.ptr_Vec3i[i].data2;
                            matOut->ptr_Vec3f[i].data3=matIn.ptr_Vec3i[i].data3;
                        }
                    break;
                    case CCV_64FC1:
                        for(i=0;i<size;i++)
                        {
                            d_value=(matIn.ptr_Vec3i[i].data1+matIn.ptr_Vec3i[i].data2+matIn.ptr_Vec3i[i].data3)/3.0;
                            matOut->ptr_double[i]=d_value;
                        }
                    break;
                    case CCV_64FC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3d[i].data1=matIn.ptr_Vec3i[i].data1;
                            matOut->ptr_Vec3d[i].data2=matIn.ptr_Vec3i[i].data2;
                            matOut->ptr_Vec3d[i].data3=matIn.ptr_Vec3i[i].data3;
                        }
                    break;
                    default:
                        return 1;
                    break;
                }
            break;
            case CCV_32FC1:
                switch(matOut->_type)
                {
                    case CCV_8UC1:
                        for(i=0;i<size;i++)
                        {
                            i32_value=matIn.ptr_float[i]+0.5;
                            matOut->ptr_uchar[i]=(Uint8)i32_value;
                        }
                    break;
                    case CCV_8UC3:
                        for(i=0;i<size;i++)
                        {
                            i32_value=matIn.ptr_float[i]+0.5;
                            matOut->ptr_Vec3b[i].data1=(Uint8)i32_value;
                            matOut->ptr_Vec3b[i].data2=(Uint8)i32_value;
                            matOut->ptr_Vec3b[i].data3=(Uint8)i32_value;
                        }
                    break;
                    case CCV_8SC1:
                        for(i=0;i<size;i++)
                        {
                            i32_value=matIn.ptr_float[i]+0.5;
                            matOut->ptr_char[i]=(Int8)i32_value;
                        }
                    break;
                    case CCV_8SC3:
                        for(i=0;i<size;i++)
                        {
                            i32_value=matIn.ptr_float[i]+0.5;
                            matOut->ptr_Vec3ib[i].data1=(Int8)i32_value;
                            matOut->ptr_Vec3ib[i].data2=(Int8)i32_value;
                            matOut->ptr_Vec3ib[i].data3=(Int8)i32_value;
                        }
                    break;
                    case CCV_16UC1:
                        for(i=0;i<size;i++)
                        {
                            i32_value=matIn.ptr_float[i]+0.5;
                            matOut->ptr_ushort[i]=(Uint16)i32_value;
                        }
                    break;
                    case CCV_16UC3:
                        for(i=0;i<size;i++)
                        {
                            i32_value=matIn.ptr_float[i]+0.5;
                            matOut->ptr_Vec3s[i].data1=(Uint16)i32_value;
                            matOut->ptr_Vec3s[i].data2=(Uint16)i32_value;
                            matOut->ptr_Vec3s[i].data3=(Uint16)i32_value;
                        }
                    break;
                    case CCV_16SC1:
                        for(i=0;i<size;i++)
                        {
                            i32_value=matIn.ptr_float[i]+0.5;
                            matOut->ptr_short[i]=(Int16)i32_value;
                        }
                    break;
                    case CCV_16SC3:
                        for(i=0;i<size;i++)
                        {
                            i32_value=matIn.ptr_float[i]+0.5;
                            matOut->ptr_Vec3w[i].data1=(Int16)i32_value;
                            matOut->ptr_Vec3w[i].data2=(Int16)i32_value;
                            matOut->ptr_Vec3w[i].data3=(Int16)i32_value;
                        }
                    break;
                    case CCV_32SC1:
                        for(i=0;i<size;i++)
                        {
                            i32_value=matIn.ptr_float[i]+0.5;
                            matOut->ptr_int[i]=i32_value;
                        }
                    break;
                    case CCV_32SC3:
                        for(i=0;i<size;i++)
                        {
                            i32_value=matIn.ptr_float[i]+0.5;
                            matOut->ptr_Vec3i[i].data1=i32_value;
                            matOut->ptr_Vec3i[i].data2=i32_value;
                            matOut->ptr_Vec3i[i].data3=i32_value;
                        }
                    break;
                    case CCV_32FC1:
                        memcpy(matOut->ptr_float,matIn.ptr_float,size*getsizeof(CCV_32FC1));
                    break;
                    case CCV_32FC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3f[i].data1=matIn.ptr_float[i];
                            matOut->ptr_Vec3f[i].data2=matIn.ptr_float[i];
                            matOut->ptr_Vec3f[i].data3=matIn.ptr_float[i];
                        }
                    break;
                    case CCV_64FC1:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_double[i]=matIn.ptr_float[i];
                        }
                    break;
                    case CCV_64FC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3d[i].data1=matIn.ptr_float[i];
                            matOut->ptr_Vec3d[i].data2=matIn.ptr_float[i];
                            matOut->ptr_Vec3d[i].data3=matIn.ptr_float[i];
                        }
                    break;
                    default:
                        return 1;
                    break;
                }
            break;
            case CCV_32FC3:
                switch(matOut->_type)
                {
                    case CCV_8UC1:
                        for(i=0;i<size;i++)
                        {
                            i32_value=((matIn.ptr_Vec3f[i].data1+matIn.ptr_Vec3f[i].data2+matIn.ptr_Vec3f[i].data3)/3.0+0.5);
                            matOut->ptr_uchar[i]=(Uint8)i32_value;
                        }
                    break;
                    case CCV_8UC3:
                        for(i=0;i<size;i++)
                        {
                            i32_value1=matIn.ptr_Vec3f[i].data1+0.5;
                            i32_value2=matIn.ptr_Vec3f[i].data2+0.5;
                            i32_value3=matIn.ptr_Vec3f[i].data3+0.5;

                            matOut->ptr_Vec3b[i].data1=(Uint8)i32_value1;
                            matOut->ptr_Vec3b[i].data2=(Uint8)i32_value2;
                            matOut->ptr_Vec3b[i].data3=(Uint8)i32_value3;
                        }
                    break;
                    case CCV_8SC1:
                        for(i=0;i<size;i++)
                        {
                            i32_value=((matIn.ptr_Vec3f[i].data1+matIn.ptr_Vec3f[i].data2+matIn.ptr_Vec3f[i].data3)/3.0+0.5);
                            matOut->ptr_char[i]=(Int8)i32_value;
                        }
                    break;
                    case CCV_8SC3:
                        for(i=0;i<size;i++)
                        {
                            i32_value1=matIn.ptr_Vec3f[i].data1+0.5;
                            i32_value2=matIn.ptr_Vec3f[i].data2+0.5;
                            i32_value3=matIn.ptr_Vec3f[i].data3+0.5;

                            matOut->ptr_Vec3ib[i].data1=(Int8)i32_value1;
                            matOut->ptr_Vec3ib[i].data2=(Int8)i32_value2;
                            matOut->ptr_Vec3ib[i].data3=(Int8)i32_value3;
                        }
                    break;
                    case CCV_16UC1:
                        for(i=0;i<size;i++)
                        {
                            i32_value=((matIn.ptr_Vec3f[i].data1+matIn.ptr_Vec3f[i].data2+matIn.ptr_Vec3f[i].data3)/3.0+0.5);
                            matOut->ptr_ushort[i]=(Uint16)i32_value;
                        }
                    break;
                    case CCV_16UC3:
                        for(i=0;i<size;i++)
                        {
                            i32_value1=matIn.ptr_Vec3f[i].data1+0.5;
                            i32_value2=matIn.ptr_Vec3f[i].data2+0.5;
                            i32_value3=matIn.ptr_Vec3f[i].data3+0.5;

                            matOut->ptr_Vec3s[i].data1=(Uint16)i32_value1;
                            matOut->ptr_Vec3s[i].data2=(Uint16)i32_value2;
                            matOut->ptr_Vec3s[i].data3=(Uint16)i32_value3;
                        }
                    break;
                    case CCV_16SC1:
                        for(i=0;i<size;i++)
                        {
                            i32_value=((matIn.ptr_Vec3f[i].data1+matIn.ptr_Vec3f[i].data2+matIn.ptr_Vec3f[i].data3)/3.0+0.5);
                            matOut->ptr_short[i]=(Int16)i32_value;
                        }
                    break;
                    case CCV_16SC3:
                        for(i=0;i<size;i++)
                        {
                            i32_value1=matIn.ptr_Vec3f[i].data1+0.5;
                            i32_value2=matIn.ptr_Vec3f[i].data2+0.5;
                            i32_value3=matIn.ptr_Vec3f[i].data3+0.5;

                            matOut->ptr_Vec3w[i].data1=(Int16)i32_value1;
                            matOut->ptr_Vec3w[i].data2=(Int16)i32_value2;
                            matOut->ptr_Vec3w[i].data3=(Int16)i32_value3;
                        }
                    break;
                    case CCV_32SC1:
                        for(i=0;i<size;i++)
                        {
                            i32_value=((matIn.ptr_Vec3f[i].data1+matIn.ptr_Vec3f[i].data2+matIn.ptr_Vec3f[i].data3)/3.0+0.5);
                            matOut->ptr_int[i]=i32_value;
                        }
                    break;
                    case CCV_32SC3:
                        for(i=0;i<size;i++)
                        {
                            i32_value1=matIn.ptr_Vec3f[i].data1+0.5;
                            i32_value2=matIn.ptr_Vec3f[i].data2+0.5;
                            i32_value3=matIn.ptr_Vec3f[i].data3+0.5;

                            matOut->ptr_Vec3i[i].data1=i32_value1;
                            matOut->ptr_Vec3i[i].data2=i32_value2;
                            matOut->ptr_Vec3i[i].data3=i32_value3;
                        }
                    break;
                    case CCV_32FC1:
                        for(i=0;i<size;i++)
                        {
                            f_value=(matIn.ptr_Vec3f[i].data1+matIn.ptr_Vec3f[i].data2+matIn.ptr_Vec3f[i].data3)/3.0;
                            matOut->ptr_float[i]=f_value;
                        }
                    break;
                    case CCV_32FC3:
                        memcpy(matOut->ptr_Vec3f,matIn.ptr_Vec3f,size*getsizeof(CCV_32FC3));
                    break;
                    case CCV_64FC1:
                        for(i=0;i<size;i++)
                        {
                            d_value=(matIn.ptr_Vec3f[i].data1+matIn.ptr_Vec3f[i].data2+matIn.ptr_Vec3f[i].data3)/3.0;
                            matOut->ptr_double[i]=d_value;
                        }
                    break;
                    case CCV_64FC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3d[i].data1=matIn.ptr_Vec3f[i].data1;
                            matOut->ptr_Vec3d[i].data2=matIn.ptr_Vec3f[i].data2;
                            matOut->ptr_Vec3d[i].data3=matIn.ptr_Vec3f[i].data3;
                        }
                    break;
                    default:
                        return 1;
                    break;
                }
            break;
            case CCV_64FC1:
                switch(matOut->_type)
                {
                    case CCV_8UC1:
                        for(i=0;i<size;i++)
                        {
                            i32_value=matIn.ptr_double[i]+0.5;
                            matOut->ptr_uchar[i]=(Uint8)i32_value;
                        }
                    break;
                    case CCV_8UC3:
                        for(i=0;i<size;i++)
                        {
                            i32_value=matIn.ptr_double[i]+0.5;
                            matOut->ptr_Vec3b[i].data1=(Uint8)i32_value;
                            matOut->ptr_Vec3b[i].data2=(Uint8)i32_value;
                            matOut->ptr_Vec3b[i].data3=(Uint8)i32_value;
                        }
                    break;
                    case CCV_8SC1:
                        for(i=0;i<size;i++)
                        {
                            i32_value=matIn.ptr_double[i]+0.5;
                            matOut->ptr_char[i]=(Int8)i32_value;
                        }
                    break;
                    case CCV_8SC3:
                        for(i=0;i<size;i++)
                        {
                            i32_value=matIn.ptr_double[i]+0.5;
                            matOut->ptr_Vec3ib[i].data1=(Int8)i32_value;
                            matOut->ptr_Vec3ib[i].data2=(Int8)i32_value;
                            matOut->ptr_Vec3ib[i].data3=(Int8)i32_value;
                        }
                    break;
                    case CCV_16UC1:
                        for(i=0;i<size;i++)
                        {
                            i32_value=matIn.ptr_double[i]+0.5;
                            matOut->ptr_ushort[i]=(Uint16)i32_value;
                        }
                    break;
                    case CCV_16UC3:
                        for(i=0;i<size;i++)
                        {
                            i32_value=matIn.ptr_double[i]+0.5;
                            matOut->ptr_Vec3s[i].data1=(Uint16)i32_value;
                            matOut->ptr_Vec3s[i].data2=(Uint16)i32_value;
                            matOut->ptr_Vec3s[i].data3=(Uint16)i32_value;
                        }
                    break;
                    case CCV_16SC1:
                        for(i=0;i<size;i++)
                        {
                            i32_value=matIn.ptr_double[i]+0.5;
                            matOut->ptr_short[i]=(Int16)i32_value;
                        }
                    break;
                    case CCV_16SC3:
                        for(i=0;i<size;i++)
                        {
                            i32_value=matIn.ptr_double[i]+0.5;
                            matOut->ptr_Vec3w[i].data1=(Int16)i32_value;
                            matOut->ptr_Vec3w[i].data2=(Int16)i32_value;
                            matOut->ptr_Vec3w[i].data3=(Int16)i32_value;
                        }
                    break;
                    case CCV_32SC1:
                        for(i=0;i<size;i++)
                        {
                            i32_value=matIn.ptr_double[i]+0.5;
                            matOut->ptr_int[i]=i32_value;
                        }
                    break;
                    case CCV_32SC3:
                        for(i=0;i<size;i++)
                        {
                            i32_value=matIn.ptr_double[i]+0.5;
                            matOut->ptr_Vec3i[i].data1=i32_value;
                            matOut->ptr_Vec3i[i].data2=i32_value;
                            matOut->ptr_Vec3i[i].data3=i32_value;
                        }
                    break;
                    case CCV_32FC1:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_float[i]=(float)matIn.ptr_double[i];
                        }
                    break;
                    case CCV_32FC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3f[i].data1=(float)matIn.ptr_double[i];
                            matOut->ptr_Vec3f[i].data2=(float)matIn.ptr_double[i];
                            matOut->ptr_Vec3f[i].data3=(float)matIn.ptr_double[i];
                        }
                    break;
                    case CCV_64FC1:
                        memcpy(matOut->ptr_double,matIn.ptr_double,size*getsizeof(CCV_64FC1));
                    break;
                    case CCV_64FC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3d[i].data1=matIn.ptr_double[i];
                            matOut->ptr_Vec3d[i].data2=matIn.ptr_double[i];
                            matOut->ptr_Vec3d[i].data3=matIn.ptr_double[i];
                        }
                    break;
                    default:
                        return 1;
                    break;
                }
            break;
            case CCV_64FC3:
                switch(matOut->_type)
                {
                    case CCV_8UC1:
                        for(i=0;i<size;i++)
                        {
                            i32_value=((matIn.ptr_Vec3d[i].data1+matIn.ptr_Vec3d[i].data2+matIn.ptr_Vec3d[i].data3)/3.0+0.5);
                            matOut->ptr_uchar[i]=(Uint8)i32_value;
                        }
                    break;
                    case CCV_8UC3:
                        for(i=0;i<size;i++)
                        {
                            i32_value1=matIn.ptr_Vec3d[i].data1+0.5;
                            i32_value2=matIn.ptr_Vec3d[i].data2+0.5;
                            i32_value3=matIn.ptr_Vec3d[i].data3+0.5;

                            matOut->ptr_Vec3b[i].data1=(Uint8)i32_value1;
                            matOut->ptr_Vec3b[i].data2=(Uint8)i32_value2;
                            matOut->ptr_Vec3b[i].data3=(Uint8)i32_value3;
                        }
                    break;
                    case CCV_8SC1:
                        for(i=0;i<size;i++)
                        {
                            i32_value=((matIn.ptr_Vec3d[i].data1+matIn.ptr_Vec3d[i].data2+matIn.ptr_Vec3d[i].data3)/3.0+0.5);
                            matOut->ptr_char[i]=(Int8)i32_value;
                        }
                    break;
                    case CCV_8SC3:
                        for(i=0;i<size;i++)
                        {
                            i32_value1=matIn.ptr_Vec3d[i].data1+0.5;
                            i32_value2=matIn.ptr_Vec3d[i].data2+0.5;
                            i32_value3=matIn.ptr_Vec3d[i].data3+0.5;

                            matOut->ptr_Vec3ib[i].data1=(Int8)i32_value1;
                            matOut->ptr_Vec3ib[i].data2=(Int8)i32_value2;
                            matOut->ptr_Vec3ib[i].data3=(Int8)i32_value3;
                        }
                    break;
                    case CCV_16UC1:
                        for(i=0;i<size;i++)
                        {
                            i32_value=((matIn.ptr_Vec3d[i].data1+matIn.ptr_Vec3d[i].data2+matIn.ptr_Vec3d[i].data3)/3.0+0.5);
                            matOut->ptr_ushort[i]=(Uint16)i32_value;
                        }
                    break;
                    case CCV_16UC3:
                        for(i=0;i<size;i++)
                        {
                            i32_value1=matIn.ptr_Vec3d[i].data1+0.5;
                            i32_value2=matIn.ptr_Vec3d[i].data2+0.5;
                            i32_value3=matIn.ptr_Vec3d[i].data3+0.5;

                            matOut->ptr_Vec3s[i].data1=(Uint16)i32_value1;
                            matOut->ptr_Vec3s[i].data2=(Uint16)i32_value2;
                            matOut->ptr_Vec3s[i].data3=(Uint16)i32_value3;
                        }
                    break;
                    case CCV_16SC1:
                        for(i=0;i<size;i++)
                        {
                            i32_value=((matIn.ptr_Vec3d[i].data1+matIn.ptr_Vec3d[i].data2+matIn.ptr_Vec3d[i].data3)/3.0+0.5);
                            matOut->ptr_short[i]=(Int16)i32_value;
                        }
                    break;
                    case CCV_16SC3:
                        for(i=0;i<size;i++)
                        {
                            i32_value1=matIn.ptr_Vec3d[i].data1+0.5;
                            i32_value2=matIn.ptr_Vec3d[i].data2+0.5;
                            i32_value3=matIn.ptr_Vec3d[i].data3+0.5;

                            matOut->ptr_Vec3w[i].data1=(Int16)i32_value1;
                            matOut->ptr_Vec3w[i].data2=(Int16)i32_value2;
                            matOut->ptr_Vec3w[i].data3=(Int16)i32_value3;
                        }
                    break;
                    case CCV_32SC1:
                        for(i=0;i<size;i++)
                        {
                            i32_value=((matIn.ptr_Vec3d[i].data1+matIn.ptr_Vec3d[i].data2+matIn.ptr_Vec3d[i].data3)/3.0+0.5);
                            matOut->ptr_int[i]=i32_value;
                        }
                    break;
                    case CCV_32SC3:
                        for(i=0;i<size;i++)
                        {
                            i32_value1=matIn.ptr_Vec3d[i].data1+0.5;
                            i32_value2=matIn.ptr_Vec3d[i].data2+0.5;
                            i32_value3=matIn.ptr_Vec3d[i].data3+0.5;

                            matOut->ptr_Vec3i[i].data1=i32_value1;
                            matOut->ptr_Vec3i[i].data2=i32_value2;
                            matOut->ptr_Vec3i[i].data3=i32_value3;
                        }
                    break;
                    case CCV_32FC1:
                        for(i=0;i<size;i++)
                        {
                            f_value=(float)(matIn.ptr_Vec3d[i].data1+matIn.ptr_Vec3d[i].data2+matIn.ptr_Vec3d[i].data3)/3.0;
                            matOut->ptr_float[i]=f_value;
                        }
                    break;
                    case CCV_32FC3:
                        for(i=0;i<size;i++)
                        {
                            matOut->ptr_Vec3f[i].data1=(float)matIn.ptr_Vec3d[i].data1;
                            matOut->ptr_Vec3f[i].data2=(float)matIn.ptr_Vec3d[i].data2;
                            matOut->ptr_Vec3f[i].data3=(float)matIn.ptr_Vec3d[i].data3;
                        }
                    break;
                    case CCV_64FC1:
                        for(i=0;i<size;i++)
                        {
                            d_value=(matIn.ptr_Vec3d[i].data1+matIn.ptr_Vec3d[i].data2+matIn.ptr_Vec3d[i].data3)/3.0;
                            matOut->ptr_double[i]=d_value;
                        }
                    break;
                    case CCV_64FC3:
                        memcpy(matOut->ptr_Vec3d,matIn.ptr_Vec3d,size*getsizeof(CCV_64FC3));
                    break;
                    default:
                        return 1;
                    break;
                }
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 MatSet1col(Mat *matIn_Out,double color)
    {
        Int32 size=matIn_Out->nHeight*matIn_Out->nWidth;
        Int32 i,n;

        Uint8 u8_data,u8_data1,u8_data2,u8_data3;
        Uint16 u16_data,u16_data1,u16_data2,u16_data3;
        Int8 i8_data,i8_data1,i8_data2,i8_data3;
        Int16 i16_data,i16_data1,i16_data2,i16_data3;
        Int32 i32_data,i32_data1,i32_data2,i32_data3;
        float f_data,f_data1,f_data2,f_data3;
        double d_data,d_data1,d_data2,d_data3;

        switch(matIn_Out->_type)
        {
            case CCV_8UC1:
                u8_data=(Uint8)(color+0.5);
                memset(matIn_Out->ptr_uchar,u8_data,sizeof(Uint8)*size);
                return 0;
            break;
            case CCV_8UC3:
                u8_data1=(Uint8)(color+0.5);
                u8_data2=(Uint8)(color+0.5);
                u8_data3=(Uint8)(color+0.5);
                for(i=0;i<size;i++)
                {
                    matIn_Out->ptr_Vec3b[i].data1=u8_data1;
                    matIn_Out->ptr_Vec3b[i].data2=u8_data2;
                    matIn_Out->ptr_Vec3b[i].data3=u8_data3;
                }
                return 0;
            break;
            case CCV_8SC1:
                i8_data=(Int8)(color+0.5);
                memset(matIn_Out->ptr_char,i8_data,sizeof(Int8)*size);
                return 0;
            break;
            case CCV_8SC3:
                i8_data1=(Int8)(color+0.5);
                i8_data2=(Int8)(color+0.5);
                i8_data3=(Int8)(color+0.5);
                for(i=0;i<size;i++)
                {
                    matIn_Out->ptr_Vec3ib[i].data1=i8_data1;
                    matIn_Out->ptr_Vec3ib[i].data2=i8_data2;
                    matIn_Out->ptr_Vec3ib[i].data3=i8_data3;
                }
                return 0;
            break;
            case CCV_16UC1:
                u16_data=(Uint16)(color+0.5);
                if(u16_data<256)
                    memset(matIn_Out->ptr_ushort,u16_data,sizeof(Uint16)*size);
                else
                {
                    for(n=0;n<size;n++)
                    {
                        matIn_Out->ptr_ushort[n]=u16_data;
                    }
                }
                return 0;
            break;
            case CCV_16UC3:
                u16_data1=(Uint16)(color+0.5);
                u16_data2=(Uint16)(color+0.5);
                u16_data3=(Uint16)(color+0.5);
                for(i=0;i<size;i++)
                {
                    matIn_Out->ptr_Vec3s[i].data1=u16_data1;
                    matIn_Out->ptr_Vec3s[i].data2=u16_data2;
                    matIn_Out->ptr_Vec3s[i].data3=u16_data3;
                }
                return 0;
            break;
            case CCV_16SC1:
                i16_data=(Int16)(color+0.5);
                if(i16_data>=0&&i16_data<256)
                    memset(matIn_Out->ptr_short,i16_data,sizeof(Int16)*size);
                else
                {
                    for(n=0;n<size;n++)
                    {
                        matIn_Out->ptr_short[n]=i16_data;
                    }
                }
                return 0;
            break;
            case CCV_16SC3:
                i16_data1=(Int16)(color+0.5);
                i16_data2=(Int16)(color+0.5);
                i16_data3=(Int16)(color+0.5);
                for(i=0;i<size;i++)
                {
                    matIn_Out->ptr_Vec3w[i].data1=i16_data1;
                    matIn_Out->ptr_Vec3w[i].data2=i16_data2;
                    matIn_Out->ptr_Vec3w[i].data3=i16_data3;
                }
                return 0;
            break;
            case CCV_32SC1:
                i32_data=(Int32)(color+0.5);
                if(i32_data>=0&&i32_data<256)
                    memset(matIn_Out->ptr_int,i32_data,sizeof(Int32)*size);
                else
                {
                    for(n=0;n<size;n++)
                    {
                        matIn_Out->ptr_int[n]=i32_data;
                    }
                }
                return 0;
            break;
            case CCV_32SC3:
                i32_data1=(Int32)(color+0.5);
                i32_data2=(Int32)(color+0.5);
                i32_data3=(Int32)(color+0.5);
                for(i=0;i<size;i++)
                {
                    matIn_Out->ptr_Vec3i[i].data1=i32_data1;
                    matIn_Out->ptr_Vec3i[i].data2=i32_data2;
                    matIn_Out->ptr_Vec3i[i].data3=i32_data3;
                }
                return 0;
            break;
            case CCV_32FC1:
                f_data=(float)color;
                if(f_data==0)
                    memset(matIn_Out->ptr_float,f_data,sizeof(float)*size);
                else
                {
                    for(n=0;n<size;n++)
                    {
                        matIn_Out->ptr_float[n]=f_data;
                    }
                }
                return 0;
            break;
            case CCV_32FC3:
                f_data1=(float)color;
                f_data2=(float)color;
                f_data3=(float)color;
                for(i=0;i<size;i++)
                {
                    matIn_Out->ptr_Vec3f[i].data1=f_data1;
                    matIn_Out->ptr_Vec3f[i].data2=f_data2;
                    matIn_Out->ptr_Vec3f[i].data3=f_data3;
                }
                return 0;
            break;
            case CCV_64FC1:
                d_data=(double)color;
                if(d_data==0)
                    memset(matIn_Out->ptr_double,d_data,sizeof(double)*size);
                else
                {
                    for(n=0;n<size;n++)
                    {
                        matIn_Out->ptr_double[n]=d_data;
                    }
                }
                return 0;
            break;
            case CCV_64FC3:
                d_data1=(double)color;
                d_data2=(double)color;
                d_data3=(double)color;
                for(i=0;i<size;i++)
                {
                    matIn_Out->ptr_Vec3d[i].data1=d_data1;
                    matIn_Out->ptr_Vec3d[i].data2=d_data2;
                    matIn_Out->ptr_Vec3d[i].data3=d_data3;
                }
                return 0;
            break;
            default:
                return 1;
            break;
        }
        return 1;
    }

    Int8 MyBRYtoRGB(Mat matIn,Mat *matOut)
    {
        Int32 i,j;
        Int32 nnWidth=matIn.nWidth;
        Int32 nnHeight=matIn.nHeight;
        Mat matIntemp;

        matOut->nWidth=matIn.nWidth;
        matOut->nHeight=matIn.nHeight;
        matOut->nWidth=matIn.nWidth;
        matOut->nHeight=matIn.nHeight;
        matOut->startx=matIn.startx;
        matOut->starty=matIn.starty;
        matOut->width=matIn.width;
        matOut->height=matIn.height;
        MyconvertTo(matOut,CCV_8UC3);

        if(matIn.data==matOut->data)
        {
            switch(matIn._type)
            {
                case CCV_8UC1:
                break;
                default:
                    return 1;
                break;
            }
            matIntemp=MatCreatClone(matIn,u8_buffer_x1Temp1);
        }
        else
        {
            matIntemp=matIn;
        }
        
        switch(matIn._type)
        {
            case CCV_8UC1:
                for(j=0;j<nnHeight;j++)
                {
                    for(i=0;i<nnWidth;i++)
                    {
                        matOut->ptr_Vec3b[j*nnWidth+i].data1=matIntemp.ptr_uchar[j*nnWidth+i];
                        matOut->ptr_Vec3b[j*nnWidth+i].data2=matIntemp.ptr_uchar[j*nnWidth+i];
                        matOut->ptr_Vec3b[j*nnWidth+i].data3=matIntemp.ptr_uchar[j*nnWidth+i];
                    }
                }
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 MyRGBtoBRY(Mat matIn,Mat *matOut)
    {
        Int32 i,j;
        Int32 nnWidth=matIn.nWidth;
        Int32 nnHeight=matIn.nHeight;

        matOut->nWidth=matIn.nWidth;
        matOut->nHeight=matIn.nHeight;
        matOut->nWidth=matIn.nWidth;
        matOut->nHeight=matIn.nHeight;
        matOut->startx=matIn.startx;
        matOut->starty=matIn.starty;
        matOut->width=matIn.width;
        matOut->height=matIn.height;
        MyconvertTo(matOut,CCV_8UC1);
        switch(matIn._type)
        {
            case CCV_8UC3:
                for(j=0;j<nnHeight;j++)
                {
                    for(i=0;i<nnWidth;i++)
                    {
                        Int32 color;
                        Int32 colorR=matIn.ptr_Vec3b[j*nnWidth+i].data1;
                        Int32 colorG=matIn.ptr_Vec3b[j*nnWidth+i].data2;
                        Int32 colorB=matIn.ptr_Vec3b[j*nnWidth+i].data3;
                        color=((colorR*19595+colorG*38469+colorB*7472)>>16);
                        matOut->ptr_uchar[j*nnWidth+i]=(Uint8)color;
                    }
                }
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 MyconvertTo(Mat *matIn_Out,type Mod)
    {
        matIn_Out->_type=Mod;
        switch(matIn_Out->_type)
        {
            case CCV_8UC1:
                matIn_Out->ptr_uchar=(Uint8*)matIn_Out->data;
            break;
            case CCV_8UC3:
                matIn_Out->ptr_Vec3b=(Vec3b*)matIn_Out->data;
            break;
            case CCV_8SC1:
                matIn_Out->ptr_char=(Int8*)matIn_Out->data;
            break;
            case CCV_8SC3:
                matIn_Out->ptr_Vec3ib=(Vec3ib*)matIn_Out->data;
            break;
            case CCV_16UC1:
                matIn_Out->ptr_ushort=(Uint16*)matIn_Out->data;
            break;
            case CCV_16UC3:
                matIn_Out->ptr_Vec3s=(Vec3s*)matIn_Out->data;
            break;
            case CCV_16SC1:
                matIn_Out->ptr_short=(Int16*)matIn_Out->data;
            break;
            case CCV_16SC3:
                matIn_Out->ptr_Vec3w=(Vec3w*)matIn_Out->data;
            break;
            case CCV_32SC1:
                matIn_Out->ptr_int=(Int32*)matIn_Out->data;
            break;
            case CCV_32SC3:
                matIn_Out->ptr_Vec3i=(Vec3i*)matIn_Out->data;
            break;
            case CCV_32FC1:
                matIn_Out->ptr_float=(float*)matIn_Out->data;
            break;
            case CCV_32FC3:
                matIn_Out->ptr_Vec3f=(Vec3f*)matIn_Out->data;
            break;
            case CCV_64FC1:
                matIn_Out->ptr_double=(double*)matIn_Out->data;
            break;
            case CCV_64FC3:
                matIn_Out->ptr_Vec3d=(Vec3d*)matIn_Out->data;
            break;
        }
        return 0;
    }

    Int8 MatSet3col(Mat *matIn_Out,double color1,double color2,double color3)
    {
        Int32 size=matIn_Out->nHeight*matIn_Out->nWidth;
        Int32 i;

        Uint8 u8_data,u8_data1,u8_data2,u8_data3;
        Uint16 u16_data,u16_data1,u16_data2,u16_data3;
        Int8 i8_data,i8_data1,i8_data2,i8_data3;
        Int16 i16_data,i16_data1,i16_data2,i16_data3;
        Int32 i32_data,i32_data1,i32_data2,i32_data3;
        float f_data,f_data1,f_data2,f_data3;
        double d_data,d_data1,d_data2,d_data3;

        switch(matIn_Out->_type)
        {
            case CCV_8UC1:
                u8_data=(Uint8)((color1+color2+color3)/3+0.5);
                memset(matIn_Out->ptr_uchar,u8_data,sizeof(Uint8)*size);
            break;
            case CCV_8UC3:
                u8_data1=(Uint8)(color1+0.5);
                u8_data2=(Uint8)(color2+0.5);
                u8_data3=(Uint8)(color3+0.5);
                for(i=0;i<size;i++)
                {
                    matIn_Out->ptr_Vec3b[i].data1=u8_data1;
                    matIn_Out->ptr_Vec3b[i].data2=u8_data2;
                    matIn_Out->ptr_Vec3b[i].data3=u8_data3;
                }
            break;
            case CCV_8SC1:
                i8_data=(Int8)((color1+color2+color3)/3+0.5);
                memset(matIn_Out->ptr_char,i8_data,sizeof(Int8)*size);
            break;
            case CCV_8SC3:
                i8_data1=(Int8)(color1+0.5);
                i8_data2=(Int8)(color2+0.5);
                i8_data3=(Int8)(color3+0.5);
                for(i=0;i<size;i++)
                {
                    matIn_Out->ptr_Vec3ib[i].data1=i8_data1;
                    matIn_Out->ptr_Vec3ib[i].data2=i8_data2;
                    matIn_Out->ptr_Vec3ib[i].data3=i8_data3;
                }
            break;
            case CCV_16UC1:
                u16_data=(Uint16)((color1+color2+color3)/3+0.5);
                memset(matIn_Out->ptr_ushort,u16_data,sizeof(Uint16)*size);
            break;
            case CCV_16UC3:
                u16_data1=(Uint16)(color1+0.5);
                u16_data2=(Uint16)(color2+0.5);
                u16_data3=(Uint16)(color3+0.5);
                for(i=0;i<size;i++)
                {
                    matIn_Out->ptr_Vec3s[i].data1=u16_data1;
                    matIn_Out->ptr_Vec3s[i].data2=u16_data2;
                    matIn_Out->ptr_Vec3s[i].data3=u16_data3;
                }
            break;
            case CCV_16SC1:
                i16_data=(Int16)((color1+color2+color3)/3+0.5);
                memset(matIn_Out->ptr_short,i16_data,sizeof(Int16)*size);
            break;
            case CCV_16SC3:
                i16_data1=(Int16)(color1+0.5);
                i16_data2=(Int16)(color2+0.5);
                i16_data3=(Int16)(color3+0.5);
                for(i=0;i<size;i++)
                {
                    matIn_Out->ptr_Vec3w[i].data1=i16_data1;
                    matIn_Out->ptr_Vec3w[i].data2=i16_data2;
                    matIn_Out->ptr_Vec3w[i].data3=i16_data3;
                }
            break;
            case CCV_32SC1:
                i32_data=(Int32)((color1+color2+color3)/3+0.5);
                memset(matIn_Out->ptr_int,i32_data,sizeof(Int32)*size);
            break;
            case CCV_32SC3:
                i32_data1=(Int32)(color1+0.5);
                i32_data2=(Int32)(color2+0.5);
                i32_data3=(Int32)(color3+0.5);
                for(i=0;i<size;i++)
                {
                    matIn_Out->ptr_Vec3i[i].data1=i32_data1;
                    matIn_Out->ptr_Vec3i[i].data2=i32_data2;
                    matIn_Out->ptr_Vec3i[i].data3=i32_data3;
                }
            break;
            case CCV_32FC1:
                f_data=(float)((color1+color2+color3)/3);
                memset(matIn_Out->ptr_float,f_data,sizeof(float)*size);
            break;
            case CCV_32FC3:
                f_data1=(float)color1;
                f_data2=(float)color2;
                f_data3=(float)color3;
                for(i=0;i<size;i++)
                {
                    matIn_Out->ptr_Vec3f[i].data1=f_data1;
                    matIn_Out->ptr_Vec3f[i].data2=f_data2;
                    matIn_Out->ptr_Vec3f[i].data3=f_data3;
                }
            break;
            case CCV_64FC1:
                d_data=(double)((color1+color2+color3)/3);
                memset(matIn_Out->ptr_double,d_data,sizeof(double)*size);
            break;
            case CCV_64FC3:
                d_data1=(double)color1;
                d_data2=(double)color2;
                d_data3=(double)color3;
                for(i=0;i<size;i++)
                {
                    matIn_Out->ptr_Vec3d[i].data1=d_data1;
                    matIn_Out->ptr_Vec3d[i].data2=d_data2;
                    matIn_Out->ptr_Vec3d[i].data3=d_data3;
                }
            break;
            default:
                return 1;
            break;
        }
        return 1;
    }

    Int8 MatClone(Mat matIn,Mat *matOut)
    {
        Int32 nWidth=matIn.nWidth;
        Int32 nHeight=matIn.nHeight;
        matOut->nWidth=matIn.nWidth;
        matOut->nHeight=matIn.nHeight;
        matOut->startx=matIn.startx;
        matOut->starty=matIn.starty;
        matOut->width=matIn.width;
        matOut->height=matIn.height;
        MyconvertTo(matOut,matIn._type);
        memcpy(matOut->data,matIn.data,getsizeof(matIn._type)*nWidth*nHeight);
        return 0;
    }

    Int8 MatClonesizeadd(Mat matIn,Mat *matIn_Out,Uint32 nStartX,Uint32 nStartY,Uint32 CopyWidth,Uint32 CopyHeight)
    {
        Int32 j;

        if(matIn_Out->_type!=matIn._type||
           matIn_Out->nHeight!=matIn.nHeight||
           matIn_Out->nWidth!=matIn.nWidth)
        {
            return 1;
        }
        switch(matIn._type)
        {
            case CCV_8UC1:
                for(j=nStartY;j<nStartY+CopyHeight;j++)
                {
                    memcpy(&matIn_Out->ptr_uchar[j*matIn.nWidth+nStartX],&matIn.ptr_uchar[j*matIn.nWidth+nStartX],getsizeof(matIn._type)*CopyWidth);
                }
            break;
            case CCV_8UC3:
                for(j=nStartY;j<nStartY+CopyHeight;j++)
                {
                    memcpy(&matIn_Out->ptr_Vec3b[j*matIn.nWidth+nStartX],&matIn.ptr_Vec3b[j*matIn.nWidth+nStartX],getsizeof(matIn._type)*CopyWidth);
                }
            break;
            case CCV_8SC1:
                for(j=nStartY;j<nStartY+CopyHeight;j++)
                {
                    memcpy(&matIn_Out->ptr_char[j*matIn.nWidth+nStartX],&matIn.ptr_char[j*matIn.nWidth+nStartX],getsizeof(matIn._type)*CopyWidth);
                }
            break;
            case CCV_8SC3:
                for(j=nStartY;j<nStartY+CopyHeight;j++)
                {
                    memcpy(&matIn_Out->ptr_Vec3ib[j*matIn.nWidth+nStartX],&matIn.ptr_Vec3ib[j*matIn.nWidth+nStartX],getsizeof(matIn._type)*CopyWidth);
                }
            break;
            case CCV_16UC1:
                for(j=nStartY;j<nStartY+CopyHeight;j++)
                {
                    memcpy(&matIn_Out->ptr_ushort[j*matIn.nWidth+nStartX],&matIn.ptr_ushort[j*matIn.nWidth+nStartX],getsizeof(matIn._type)*CopyWidth);
                }
            break;
            case CCV_16UC3:
                for(j=nStartY;j<nStartY+CopyHeight;j++)
                {
                    memcpy(&matIn_Out->ptr_Vec3s[j*matIn.nWidth+nStartX],&matIn.ptr_Vec3s[j*matIn.nWidth+nStartX],getsizeof(matIn._type)*CopyWidth);
                }
            break;
            case CCV_16SC1:
                for(j=nStartY;j<nStartY+CopyHeight;j++)
                {
                    memcpy(&matIn_Out->ptr_short[j*matIn.nWidth+nStartX],&matIn.ptr_short[j*matIn.nWidth+nStartX],getsizeof(matIn._type)*CopyWidth);
                }
            break;
            case CCV_16SC3:
                for(j=nStartY;j<nStartY+CopyHeight;j++)
                {
                    memcpy(&matIn_Out->ptr_Vec3w[j*matIn.nWidth+nStartX],&matIn.ptr_Vec3w[j*matIn.nWidth+nStartX],getsizeof(matIn._type)*CopyWidth);
                }
            break;
            case CCV_32SC1:
                for(j=nStartY;j<nStartY+CopyHeight;j++)
                {
                    memcpy(&matIn_Out->ptr_int[j*matIn.nWidth+nStartX],&matIn.ptr_int[j*matIn.nWidth+nStartX],getsizeof(matIn._type)*CopyWidth);
                }
            break;
            case CCV_32SC3:
                for(j=nStartY;j<nStartY+CopyHeight;j++)
                {
                    memcpy(&matIn_Out->ptr_Vec3i[j*matIn.nWidth+nStartX],&matIn.ptr_Vec3i[j*matIn.nWidth+nStartX],getsizeof(matIn._type)*CopyWidth);
                }
            break;
            case CCV_32FC1:
                for(j=nStartY;j<nStartY+CopyHeight;j++)
                {
                    memcpy(&matIn_Out->ptr_float[j*matIn.nWidth+nStartX],&matIn.ptr_float[j*matIn.nWidth+nStartX],getsizeof(matIn._type)*CopyWidth);
                }
            break;
            case CCV_32FC3:
                for(j=nStartY;j<nStartY+CopyHeight;j++)
                {
                    memcpy(&matIn_Out->ptr_Vec3f[j*matIn.nWidth+nStartX],&matIn.ptr_Vec3f[j*matIn.nWidth+nStartX],getsizeof(matIn._type)*CopyWidth);
                }
            break;
            case CCV_64FC1:
                for(j=nStartY;j<nStartY+CopyHeight;j++)
                {
                    memcpy(&matIn_Out->ptr_double[j*matIn.nWidth+nStartX],&matIn.ptr_double[j*matIn.nWidth+nStartX],getsizeof(matIn._type)*CopyWidth);
                }
            break;
            case CCV_64FC3:
                for(j=nStartY;j<nStartY+CopyHeight;j++)
                {
                    memcpy(&matIn_Out->ptr_Vec3d[j*matIn.nWidth+nStartX],&matIn.ptr_Vec3d[j*matIn.nWidth+nStartX],getsizeof(matIn._type)*CopyWidth);
                }
            break;
        }
        return 0;
    }

    Int8 MyCutRoi(Mat matIn,Mat *matOut,cutroi Mod,Uint32 nStartX,Uint32 nStartY,Uint32 CutWidth,Uint32 CutHeight)
    {
        Int32 j;
        Int32 nHeight=CutHeight;
        Int32 nWidth=CutWidth;
        Int32 nnWidth=matIn.nWidth;
        switch(Mod)
        {
            case MHC_CUT_NOTCOPY:
                matOut->nWidth=matIn.nWidth;
                matOut->nHeight=matIn.nHeight;
                matOut->startx=nStartX;
                matOut->starty=nStartY;
                matOut->width=CutWidth;
                matOut->height=CutHeight;
                matOut->data=matIn.data;
                MyconvertTo(matOut,matIn._type);
            break;
            case MHC_CUT_COPY:
                matOut->nWidth=matIn.nWidth;
                matOut->nHeight=matIn.nHeight;
                matOut->startx=matIn.startx;
                matOut->starty=matIn.starty;
                matOut->width=matIn.width;
                matOut->height=matIn.height;
                MyconvertTo(matOut,matIn._type);
                MyCutselfRoi(matOut,nStartX,nStartY,CutWidth,CutHeight);
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    memcpy(&matOut->data[j*nnWidth+nStartX],&matIn.data[j*nnWidth+nStartX],getsizeof(matIn._type)*nWidth);
                }
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 MyCutselfRoi(Mat *matIn_Out,Uint32 nStartX,Uint32 nStartY,Uint32 CutWidth,Uint32 CutHeight)
    {
        matIn_Out->startx=nStartX;
        matIn_Out->starty=nStartY;
        matIn_Out->width=CutWidth;
        matIn_Out->height=CutHeight;
        return 0;
    }

    Int8 MyCutminRoi(Mat matIn,Mat *matOut,cutminroi Mod,Uint32 nStartX,Uint32 nStartY,Uint32 CutWidth,Uint32 CutHeight)
    {
        Int32 j;
        Int32 nnHeight=CutHeight;
        Int32 nnWidth=CutWidth;
        Int32 nHeight=CutHeight;
        Int32 nWidth=matIn.nWidth;

        Mat matIntemp;
        if(matIn.data==matOut->data)
        {
            switch(matIn._type)
            {
                case CCV_8UC1:
                break;
                case CCV_8SC1:
                break;
                case CCV_8UC3:
                break;
                case CCV_16UC1:
                break;
                case CCV_16SC1:
                break;
                case CCV_32SC1:
                break;
                case CCV_32FC1:
                break;
                default:
                    return 1;
                break;
            }
            matIntemp=MatCreatClone(matIn,u8_buffer_x1Temp1);
        }
        else
        {
            matIntemp=matIn;
        }
        switch(Mod)
        {
            case MHC_CUTMIN_1:
            break;
            case MHC_CUTMIN_4:
                nnWidth=(nnWidth+3)/4*4;
            break;
            case MHC_CUTMIN_8:
                nnWidth=(nnWidth+7)/8*8;
            break;
            case MHC_CUTMIN_32:
                nnWidth=(nnWidth+31)/32*32;
            break;
            case MHC_CUTMIN_64:
                nnWidth=(nnWidth+63)/64*64;
            break;
            case MHC_CUTMIN_4x4:
                nnWidth=(nnWidth+3)/4*4;
                nnHeight=(nnHeight+3)/4*4;
            break;
            default:
                return 1;
            break;
        }
        matOut->nWidth=nnWidth;
        matOut->nHeight=nnHeight;
        matOut->startx=0;
        matOut->starty=0;
        matOut->width=CutWidth;
        matOut->height=CutHeight;
        MyconvertTo(matOut,matIntemp._type);

        MatSet1col(matOut,0);
        switch(matIn._type)
        {
            case CCV_8UC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    memcpy(&matOut->ptr_uchar[(j-nStartY)*nnWidth],&matIntemp.ptr_uchar[j*nWidth+nStartX],getsizeof(matIntemp._type)*CutWidth);
                }
            break;
            case CCV_8SC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    memcpy(&matOut->ptr_char[(j-nStartY)*nnWidth],&matIntemp.ptr_char[j*nWidth+nStartX],getsizeof(matIntemp._type)*CutWidth);
                }
            break;
            case CCV_8UC3:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    memcpy(&matOut->ptr_Vec3b[(j-nStartY)*nnWidth],&matIntemp.ptr_Vec3b[j*nWidth+nStartX],getsizeof(matIntemp._type)*CutWidth);
                }
            break;
            case CCV_16UC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    memcpy(&matOut->ptr_ushort[(j-nStartY)*nnWidth],&matIntemp.ptr_ushort[j*nWidth+nStartX],getsizeof(matIntemp._type)*CutWidth);
                }
            break;
            case CCV_16SC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    memcpy(&matOut->ptr_short[(j-nStartY)*nnWidth],&matIntemp.ptr_short[j*nWidth+nStartX],getsizeof(matIntemp._type)*CutWidth);
                }
            break;
            case CCV_32SC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    memcpy(&matOut->ptr_int[(j-nStartY)*nnWidth],&matIntemp.ptr_int[j*nWidth+nStartX],getsizeof(matIntemp._type)*CutWidth);
                }
            break;
            case CCV_32FC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    memcpy(&matOut->ptr_float[(j-nStartY)*nnWidth],&matIntemp.ptr_float[j*nWidth+nStartX],getsizeof(matIntemp._type)*CutWidth);
                }
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 MyAddminRoi(Mat matIn,Mat matRoiIn,Mat *matOut,Uint32 addStartX,Uint32 addStartY)
    {
        Int32 nnWidth=matIn.nWidth;
        Int32 nStartY=matIn.starty;
        Int32 nHeight=matIn.height;
        Int32 nStartX=matIn.startx;
        Int32 nWidth=matIn.width;
        Int32 j;
        Int32 addWidth;
        Int32 endj;

        addWidth=matRoiIn.width;
        if(addStartX+matRoiIn.startx+addWidth>nStartX+nWidth)
            addWidth=nStartX+nWidth-addStartX-matRoiIn.startx;

        if(matIn._type!=matRoiIn._type||(matIn._type!=CCV_8UC1&&matIn._type!=CCV_8SC1&&matIn._type!=CCV_8UC3&&matIn._type!=CCV_16UC1&&matIn._type!=CCV_16SC1&&matIn._type!=CCV_32SC1&&matIn._type!=CCV_32FC1))
            return 1;

        endj=matRoiIn.starty+matRoiIn.height;
        if(endj+addStartY>=nStartY+nHeight)
            endj=nStartY+nHeight-addStartY;

        MatClone(matIn,matOut);
        switch(matIn._type)
        {
            case CCV_8UC1:
                for(j=matRoiIn.starty;j<endj;j++)
                {
                    memcpy(&matOut->ptr_uchar[(j+addStartY)*nnWidth+addStartX+matRoiIn.startx],&matRoiIn.ptr_uchar[j*matRoiIn.nWidth+matRoiIn.startx],getsizeof(matRoiIn._type)*addWidth);
                }
            break;
            case CCV_8SC1:
                for(j=matRoiIn.starty;j<endj;j++)
                {
                    memcpy(&matOut->ptr_char[(j+addStartY)*nnWidth+addStartX+matRoiIn.startx],&matRoiIn.ptr_char[j*matRoiIn.nWidth+matRoiIn.startx],getsizeof(matRoiIn._type)*addWidth);
                }
            break;
            case CCV_8UC3:
                for(j=matRoiIn.starty;j<endj;j++)
                {
                    memcpy(&matOut->ptr_Vec3b[(j+addStartY)*nnWidth+addStartX+matRoiIn.startx],&matRoiIn.ptr_Vec3b[j*matRoiIn.nWidth+matRoiIn.startx],getsizeof(matRoiIn._type)*addWidth);
                }
            break;
            case CCV_16UC1:
                for(j=matRoiIn.starty;j<endj;j++)
                {
                    memcpy(&matOut->ptr_ushort[(j+addStartY)*nnWidth+addStartX+matRoiIn.startx],&matRoiIn.ptr_ushort[j*matRoiIn.nWidth+matRoiIn.startx],getsizeof(matRoiIn._type)*addWidth);
                }
            break;
            case CCV_16SC1:
                for(j=matRoiIn.starty;j<endj;j++)
                {
                    memcpy(&matOut->ptr_short[(j+addStartY)*nnWidth+addStartX+matRoiIn.startx],&matRoiIn.ptr_short[j*matRoiIn.nWidth+matRoiIn.startx],getsizeof(matRoiIn._type)*addWidth);
                }
            break;
            case CCV_32SC1:
                for(j=matRoiIn.starty;j<endj;j++)
                {
                    memcpy(&matOut->ptr_int[(j+addStartY)*nnWidth+addStartX+matRoiIn.startx],&matRoiIn.ptr_int[j*matRoiIn.nWidth+matRoiIn.startx],getsizeof(matRoiIn._type)*addWidth);
                }
            break;
            case CCV_32FC1:
                for(j=matRoiIn.starty;j<endj;j++)
                {
                    memcpy(&matOut->ptr_float[(j+addStartY)*nnWidth+addStartX+matRoiIn.startx],&matRoiIn.ptr_float[j*matRoiIn.nWidth+matRoiIn.startx],getsizeof(matRoiIn._type)*addWidth);
                }
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 MyCutRoiSetZero(Mat *matIn_Out)
    {
        Int32 nnHeight=matIn_Out->nHeight;
        Int32 nnWidth=matIn_Out->nWidth;
        Int32 nStartY=matIn_Out->starty;
        Int32 nHeight=matIn_Out->height;
        Int32 nStartX=matIn_Out->startx;
        Int32 nWidth=matIn_Out->width;
        Int32 j;
        switch(matIn_Out->_type)
        {
            case CCV_8UC1:
                if(nStartX!=0)
                {
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        memset(&matIn_Out->ptr_uchar[j*nnWidth],0,nStartX);
                    }
                }
                if(nStartX+nWidth!=nnWidth)
                {
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        memset(&matIn_Out->ptr_uchar[j*nnWidth+nStartX+nWidth],0,nnWidth-(nStartX+nWidth));
                    }
                }
                if(nStartY!=0)
                {
                    memset(matIn_Out->ptr_uchar,0,nStartY*nnWidth);
                }
                if(nStartY+nHeight!=nnHeight)
                {
                    memset(&matIn_Out->ptr_uchar[(nStartY+nHeight)*nnWidth],0,(nnHeight-(nStartY+nHeight))*nnWidth);
                }
            break;
            case CCV_8UC3:
                if(nStartX!=0)
                {
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        memset(&matIn_Out->ptr_Vec3b[j*nnWidth],0,nStartX*getsizeof(CCV_8UC3));
                    }
                }
                if(nStartX+nWidth!=nnWidth)
                {
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        memset(&matIn_Out->ptr_Vec3b[j*nnWidth+nStartX+nWidth],0,(nnWidth-(nStartX+nWidth))*getsizeof(CCV_8UC3));
                    }
                }
                if(nStartY!=0)
                {
                    memset(matIn_Out->ptr_Vec3b,0,(nStartY*nnWidth)*getsizeof(CCV_8UC3));
                }
                if(nStartY+nHeight!=nnHeight)
                {
                    memset(&matIn_Out->ptr_Vec3b[(nStartY+nHeight)*nnWidth],0,(nnHeight-(nStartY+nHeight))*nnWidth*getsizeof(CCV_8UC3));
                }
            break;
            case CCV_8SC1:
                if(nStartX!=0)
                {
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        memset(&matIn_Out->ptr_char[j*nnWidth],0,nStartX);
                    }
                }
                if(nStartX+nWidth!=nnWidth)
                {
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        memset(&matIn_Out->ptr_char[j*nnWidth+nStartX+nWidth],0,nnWidth-(nStartX+nWidth));
                    }
                }
                if(nStartY!=0)
                {
                    memset(matIn_Out->ptr_uchar,0,nStartY*nnWidth);
                }
                if(nStartY+nHeight!=nnHeight)
                {
                    memset(&matIn_Out->ptr_char[(nStartY+nHeight)*nnWidth],0,(nnHeight-(nStartY+nHeight))*nnWidth);
                }
            break;
            case CCV_8SC3:
                if(nStartX!=0)
                {
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        memset(&matIn_Out->ptr_Vec3ib[j*nnWidth],0,nStartX*getsizeof(CCV_8SC3));
                    }
                }
                if(nStartX+nWidth!=nnWidth)
                {
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        memset(&matIn_Out->ptr_Vec3ib[j*nnWidth+nStartX+nWidth],0,(nnWidth-(nStartX+nWidth))*getsizeof(CCV_8SC3));
                    }
                }
                if(nStartY!=0)
                {
                    memset(matIn_Out->ptr_Vec3ib,0,(nStartY*nnWidth)*getsizeof(CCV_8SC3));
                }
                if(nStartY+nHeight!=nnHeight)
                {
                    memset(&matIn_Out->ptr_Vec3ib[(nStartY+nHeight)*nnWidth],0,(nnHeight-(nStartY+nHeight))*nnWidth*getsizeof(CCV_8SC3));
                }
            break;
            case CCV_16UC1:
                if(nStartX!=0)
                {
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        memset(&matIn_Out->ptr_ushort[j*nnWidth],0,nStartX*getsizeof(CCV_16UC1));
                    }
                }
                if(nStartX+nWidth!=nnWidth)
                {
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        memset(&matIn_Out->ptr_ushort[j*nnWidth+nStartX+nWidth],0,(nnWidth-(nStartX+nWidth))*getsizeof(CCV_16UC1));
                    }
                }
                if(nStartY!=0)
                {
                    memset(matIn_Out->ptr_ushort,0,(nStartY*nnWidth)*getsizeof(CCV_16UC1));
                }
                if(nStartY+nHeight!=nnHeight)
                {
                    memset(&matIn_Out->ptr_ushort[(nStartY+nHeight)*nnWidth],0,(nnHeight-(nStartY+nHeight))*nnWidth*getsizeof(CCV_16UC1));
                }
            break;
            case CCV_16UC3:
                if(nStartX!=0)
                {
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        memset(&matIn_Out->ptr_Vec3s[j*nnWidth],0,nStartX*getsizeof(CCV_16UC3));
                    }
                }
                if(nStartX+nWidth!=nnWidth)
                {
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        memset(&matIn_Out->ptr_Vec3s[j*nnWidth+nStartX+nWidth],0,(nnWidth-(nStartX+nWidth))*getsizeof(CCV_16UC3));
                    }
                }
                if(nStartY!=0)
                {
                    memset(matIn_Out->ptr_Vec3s,0,(nStartY*nnWidth)*getsizeof(CCV_16UC3));
                }
                if(nStartY+nHeight!=nnHeight)
                {
                    memset(&matIn_Out->ptr_Vec3s[(nStartY+nHeight)*nnWidth],0,(nnHeight-(nStartY+nHeight))*nnWidth*getsizeof(CCV_16UC3));
                }
            break;
            case CCV_16SC1:
                if(nStartX!=0)
                {
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        memset(&matIn_Out->ptr_short[j*nnWidth],0,nStartX*getsizeof(CCV_16SC1));
                    }
                }
                if(nStartX+nWidth!=nnWidth)
                {
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        memset(&matIn_Out->ptr_short[j*nnWidth+nStartX+nWidth],0,(nnWidth-(nStartX+nWidth))*getsizeof(CCV_16SC1));
                    }
                }
                if(nStartY!=0)
                {
                    memset(matIn_Out->ptr_short,0,(nStartY*nnWidth)*getsizeof(CCV_16SC1));
                }
                if(nStartY+nHeight!=nnHeight)
                {
                    memset(&matIn_Out->ptr_short[(nStartY+nHeight)*nnWidth],0,(nnHeight-(nStartY+nHeight))*nnWidth*getsizeof(CCV_16SC1));
                }
            break;
            case CCV_16SC3:
                if(nStartX!=0)
                {
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        memset(&matIn_Out->ptr_Vec3w[j*nnWidth],0,nStartX*getsizeof(CCV_16SC3));
                    }
                }
                if(nStartX+nWidth!=nnWidth)
                {
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        memset(&matIn_Out->ptr_Vec3w[j*nnWidth+nStartX+nWidth],0,(nnWidth-(nStartX+nWidth))*getsizeof(CCV_16SC3));
                    }
                }
                if(nStartY!=0)
                {
                    memset(matIn_Out->ptr_Vec3w,0,(nStartY*nnWidth)*getsizeof(CCV_16SC3));
                }
                if(nStartY+nHeight!=nnHeight)
                {
                    memset(&matIn_Out->ptr_Vec3w[(nStartY+nHeight)*nnWidth],0,(nnHeight-(nStartY+nHeight))*nnWidth*getsizeof(CCV_16SC3));
                }
            break;
            case CCV_32SC1:
                if(nStartX!=0)
                {
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        memset(&matIn_Out->ptr_int[j*nnWidth],0,nStartX*getsizeof(CCV_32SC1));
                    }
                }
                if(nStartX+nWidth!=nnWidth)
                {
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        memset(&matIn_Out->ptr_int[j*nnWidth+nStartX+nWidth],0,(nnWidth-(nStartX+nWidth))*getsizeof(CCV_32SC1));
                    }
                }
                if(nStartY!=0)
                {
                    memset(matIn_Out->ptr_int,0,(nStartY*nnWidth)*getsizeof(CCV_32SC1));
                }
                if(nStartY+nHeight!=nnHeight)
                {
                    memset(&matIn_Out->ptr_int[(nStartY+nHeight)*nnWidth],0,(nnHeight-(nStartY+nHeight))*nnWidth*getsizeof(CCV_32SC1));
                }
            break;
            case CCV_32SC3:
                if(nStartX!=0)
                {
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        memset(&matIn_Out->ptr_Vec3i[j*nnWidth],0,nStartX*getsizeof(CCV_32SC3));
                    }
                }
                if(nStartX+nWidth!=nnWidth)
                {
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        memset(&matIn_Out->ptr_Vec3i[j*nnWidth+nStartX+nWidth],0,(nnWidth-(nStartX+nWidth))*getsizeof(CCV_32SC3));
                    }
                }
                if(nStartY!=0)
                {
                    memset(matIn_Out->ptr_Vec3i,0,(nStartY*nnWidth)*getsizeof(CCV_32SC3));
                }
                if(nStartY+nHeight!=nnHeight)
                {
                    memset(&matIn_Out->ptr_Vec3i[(nStartY+nHeight)*nnWidth],0,(nnHeight-(nStartY+nHeight))*nnWidth*getsizeof(CCV_32SC3));
                }
            break;
            case CCV_32FC1:
                if(nStartX!=0)
                {
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        memset(&matIn_Out->ptr_float[j*nnWidth],0,nStartX*getsizeof(CCV_32FC1));
                    }
                }
                if(nStartX+nWidth!=nnWidth)
                {
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        memset(&matIn_Out->ptr_float[j*nnWidth+nStartX+nWidth],0,(nnWidth-(nStartX+nWidth))*getsizeof(CCV_32FC1));
                    }
                }
                if(nStartY!=0)
                {
                    memset(matIn_Out->ptr_float,0,(nStartY*nnWidth)*getsizeof(CCV_32FC1));
                }
                if(nStartY+nHeight!=nnHeight)
                {
                    memset(&matIn_Out->ptr_float[(nStartY+nHeight)*nnWidth],0,(nnHeight-(nStartY+nHeight))*nnWidth*getsizeof(CCV_32FC1));
                }
            break;
            case CCV_32FC3:
                if(nStartX!=0)
                {
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        memset(&matIn_Out->ptr_Vec3f[j*nnWidth],0,nStartX*getsizeof(CCV_32FC3));
                    }
                }
                if(nStartX+nWidth!=nnWidth)
                {
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        memset(&matIn_Out->ptr_Vec3f[j*nnWidth+nStartX+nWidth],0,(nnWidth-(nStartX+nWidth))*getsizeof(CCV_32FC3));
                    }
                }
                if(nStartY!=0)
                {
                    memset(matIn_Out->ptr_Vec3f,0,(nStartY*nnWidth)*getsizeof(CCV_32FC3));
                }
                if(nStartY+nHeight!=nnHeight)
                {
                    memset(&matIn_Out->ptr_Vec3f[(nStartY+nHeight)*nnWidth],0,(nnHeight-(nStartY+nHeight))*nnWidth*getsizeof(CCV_32FC3));
                }
            break;
            case CCV_64FC1:
                if(nStartX!=0)
                {
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        memset(&matIn_Out->ptr_double[j*nnWidth],0,nStartX*getsizeof(CCV_64FC1));
                    }
                }
                if(nStartX+nWidth!=nnWidth)
                {
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        memset(&matIn_Out->ptr_double[j*nnWidth+nStartX+nWidth],0,(nnWidth-(nStartX+nWidth))*getsizeof(CCV_64FC1));
                    }
                }
                if(nStartY!=0)
                {
                    memset(matIn_Out->ptr_double,0,(nStartY*nnWidth)*getsizeof(CCV_64FC1));
                }
                if(nStartY+nHeight!=nnHeight)
                {
                    memset(&matIn_Out->ptr_double[(nStartY+nHeight)*nnWidth],0,(nnHeight-(nStartY+nHeight))*nnWidth*getsizeof(CCV_64FC1));
                }
            break;
            case CCV_64FC3:
                if(nStartX!=0)
                {
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        memset(&matIn_Out->ptr_Vec3d[j*nnWidth],0,nStartX*getsizeof(CCV_64FC3));
                    }
                }
                if(nStartX+nWidth!=nnWidth)
                {
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        memset(&matIn_Out->ptr_Vec3d[j*nnWidth+nStartX+nWidth],0,(nnWidth-(nStartX+nWidth))*getsizeof(CCV_64FC3));
                    }
                }
                if(nStartY!=0)
                {
                    memset(matIn_Out->ptr_Vec3d,0,(nStartY*nnWidth)*getsizeof(CCV_64FC3));
                }
                if(nStartY+nHeight!=nnHeight)
                {
                    memset(&matIn_Out->ptr_Vec3d[(nStartY+nHeight)*nnWidth],0,(nnHeight-(nStartY+nHeight))*nnWidth*getsizeof(CCV_64FC3));
                }
            break;
        }
        return 0;
    }

    Int8 Myequ_histo_image(Mat matIn,Mat *matOut)
    {
        Int32 nnWidth=matIn.nWidth;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        Int32 Total=matIn.height*matIn.width;
        Uint32 phist[256];
        Int32 phistmean[256];
        Int32 j,i;

        switch(matIn._type)
        {
            case CCV_8UC1:
                getcloneinfo(matIn,matOut);
                Myhistogram(matIn,phist);
                for(i=1;i<256;i++)
                {
                    phist[i]=phist[i-1]+phist[i];
                }
                for (i = 0; i < 256; ++i)
                {
                    phistmean[i] = (phist[i]<<8)/Total;
                }
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        matOut->data[j*nnWidth+i] = phistmean[matIn.data[j*nnWidth+i]];
                    }
                }
                return 0;
            break;
            default:
                return 1;
            break;
        }
    }

    Int8 Myequ_histo_image_mask(Mat matIn,Mat *matOut,Mat mask)
    {
        Int32 nnWidth=matIn.nWidth;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        Int32 Total=0;

        Uint32 phist[256];
        Int32 phistmean[256];
        Int32 j,i;
        L_Point startLoc;
        if(0!=judgeMaskSize(matIn,mask))
            return 1;
        if(0!=judgeDataNotzero(mask,&startLoc))
        {
            switch(matIn._type)
            {
                case CCV_8UC1:
                    MatClone(matIn,matOut);
                    return 0;
                break;
                default:
                    return 2;
                break;
            }
        }
        switch(matIn._type)
        {
            case CCV_8UC1:
                getcloneinfo(matIn,matOut);
                memset(phist,0,sizeof(Int32)*256);
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(mask.data[j*nnWidth+i]!=0)
                        {
                            Total++;
                            phist[matIn.data[j*nnWidth+i]]++;
                        }
                    }
                }
                for(i=1;i<256;i++)
                {
                    phist[i]=phist[i-1]+phist[i];
                }
                for (i = 0; i < 256; ++i)
                {
                    phistmean[i] = (phist[i]<<8)/Total;
                }
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(mask.data[j*nnWidth+i]!=0)
                        {
                            matOut->data[j*nnWidth+i] = phistmean[matIn.data[j*nnWidth+i]];
                        }
                    }
                }
                return 0;
            break;
            default:
                return 2;
            break;
        }
    }

    Int8 Myequ_histo_image_lineXY(Mat matIn,Mat *matOut,histoline Mod)
    {
        Int32 nnWidth=matIn.nWidth;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        Int32 Total;
        Uint32 phist[256];
        Int32 phistmean[256];
        Int32 j,i;
        switch(matIn._type)
        {
            case CCV_8UC1:
                getcloneinfo(matIn,matOut);
                switch(Mod)
                {
                    case MHC_HISTO_X:
                        Total=matIn.width;
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            memset(phist,0,sizeof(Uint32)*256);
                            for(i=nStartX;i<nStartX+nWidth;i++)
                            {
                                phist[matIn.data[j*nnWidth+i]]++;
                            }
                            for(i=1;i<256;i++)
                            {
                                phist[i]=phist[i-1]+phist[i];
                            }
                            for (i = 0; i < 256; ++i)
                            {
                                phistmean[i] = (phist[i]<<8)/Total;
                            }
                            for(i=nStartX;i<nStartX+nWidth;i++)
                            {
                                matOut->data[j*nnWidth+i] = phistmean[matIn.data[j*nnWidth+i]];
                            }
                        }
                    break;
                    case MHC_HISTO_Y:
                        Total=matIn.height;
                        for(i=nStartX;i<nStartX+nWidth;i++)
                        {
                            memset(phist,0,sizeof(Uint32)*256);
                            for(j=nStartY;j<nStartY+nHeight;j++)
                            {
                                phist[matIn.data[j*nnWidth+i]]++;
                            }
                            for(i=1;i<256;i++)
                            {
                                phist[i]=phist[i-1]+phist[i];
                            }
                            for (i = 0; i < 256; ++i)
                            {
                                phistmean[i] = (phist[i]<<8)/Total;
                            }
                            for(j=nStartY;j<nStartY+nHeight;j++)
                            {
                                matOut->data[j*nnWidth+i] = phistmean[matIn.data[j*nnWidth+i]];
                            }
                        }

                    break;
                }
                return 0;
            break;
            default:
                return 2;
            break;
        }
    }

    Int8 Mynormalize(Mat matIn,Mat *matOut)
    {
        Int32 nnWidth=matIn.nWidth;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        Int32 i,j;
        Int32 i32_min,i32_max;
        double d_min,d_max;
        L_Point minloc,maxloc;
        Int32 i32_dec;
        float f_dec;
        double d_dec;
        Int64 i64_dec;

        matOut->nWidth=matIn.nWidth;
        matOut->nHeight=matIn.nHeight;
        matOut->startx=matIn.startx;
        matOut->starty=matIn.starty;
        matOut->width=matIn.width;
        matOut->height=matIn.height;
        MyconvertTo(matOut,CCV_8UC1);

        switch(matIn._type)
        {
            case CCV_8UC1:
                Mymin_max_gray(matIn,&i32_min,&i32_max,&minloc,&maxloc);
                if(i32_max==i32_min)
                {
                    memset(matOut->data,0,nWidth*nHeight);
                    return 0;
                }
                i32_dec=(255<<8)/(i32_max-i32_min);
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        Int32 val=(((matIn.ptr_uchar[j*nnWidth+i]-i32_min)*i32_dec)>>8);
                        if(val>255)
                            val=255;
                        if(val<0)
                            val=0;
                        matOut->data[j*nnWidth+i]=(Uint8)val;
                    }
                }
                return 0;
            break;
            case CCV_8SC1:
                Mymin_max_gray(matIn,&i32_min,&i32_max,&minloc,&maxloc);
                if(i32_max==i32_min)
                {
                    memset(matOut->data,0,nWidth*nHeight);
                    return 0;
                }
                i32_dec=(255<<8)/(i32_max-i32_min);
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        Int32 val=(((matIn.ptr_char[j*nnWidth+i]-i32_min)*i32_dec)>>8);
                        if(val>255)
                            val=255;
                        if(val<0)
                            val=0;
                        matOut->data[j*nnWidth+i]=(Uint8)val;
                    }
                }
                return 0;
            break;
            case CCV_16UC1:
                Mymin_max_gray(matIn,&i32_min,&i32_max,&minloc,&maxloc);
                if(i32_max==i32_min)
                {
                    memset(matOut->data,0,nWidth*nHeight);
                    return 0;
                }
                i32_dec=(255<<16)/(i32_max-i32_min);
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        Int32 val=(((matIn.ptr_ushort[j*nnWidth+i]-i32_min)*i32_dec)>>16);
                        if(val>255)
                            val=255;
                        if(val<0)
                            val=0;
                        matOut->data[j*nnWidth+i]=(Uint8)val;
                    }
                }
                return 0;
            break;
            case CCV_16SC1:
                Mymin_max_gray(matIn,&i32_min,&i32_max,&minloc,&maxloc);
                if(i32_max==i32_min)
                {
                    memset(matOut->data,0,nWidth*nHeight);
                    return 0;
                }
                i32_dec=(255<<16)/(i32_max-i32_min);
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        Int32 val=(((matIn.ptr_short[j*nnWidth+i]-i32_min)*i32_dec)>>16);
                        if(val>255)
                            val=255;
                        if(val<0)
                            val=0;
                        matOut->data[j*nnWidth+i]=(Uint8)val;
                    }
                }
                return 0;
            break;
            case CCV_32SC1:
                Mymin_max_gray(matIn,&i32_min,&i32_max,&minloc,&maxloc);
                if(i32_max==i32_min)
                {
                    memset(matOut->data,0,nWidth*nHeight);
                    return 0;
                }
                i64_dec=(((Uint64)255)<<32)/(i32_max-i32_min);
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        Int32 val=(((matIn.ptr_int[j*nnWidth+i]-i32_min)*i64_dec)>>32);
                        if(val>255)
                            val=255;
                        if(val<0)
                            val=0;
                        matOut->data[j*nnWidth+i]=(Uint8)val;
                    }
                }
                return 0;
            break;
            case CCV_32FC1:
                Mymin_max_dgray(matIn,&d_min,&d_max,&minloc,&maxloc);
                if(d_max==d_min)
                {
                    memset(matOut->data,0,nWidth*nHeight);
                    return 0;
                }
                f_dec=255.0/(d_max-d_min);
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        Int32 val=(matIn.ptr_float[j*nnWidth+i]-d_min)*f_dec+0.5;
                        if(val>255)
                            val=255;
                        if(val<0)
                            val=0;
                        matOut->data[j*nnWidth+i]=(Uint8)val;
                    }
                }
                return 0;
            break;
            case CCV_64FC1:
                Mymin_max_dgray(matIn,&d_min,&d_max,&minloc,&maxloc);
                if(d_max==d_min)
                {
                    memset(matOut->data,0,nWidth*nHeight);
                    return 0;
                }
                d_dec=255.0/(d_max-d_min);
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        Int32 val=(matIn.ptr_double[j*nnWidth+i]-d_min)*d_dec+0.5;
                        if(val>255)
                            val=255;
                        if(val<0)
                            val=0;
                        matOut->data[j*nnWidth+i]=(Uint8)val;
                    }
                }
                return 0;
            break;
            default:
                return 1;
            break;
        }
    }

    Int8 Mynormalize_mask(Mat matIn,Mat *matOut,Mat mask)
    {
        Int32 nnWidth=matIn.nWidth;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        Int32 i,j;
        Int32 i32_min,i32_max;
        double d_min,d_max;
        L_Point minloc,maxloc;
        Int32 i32_dec;
        float f_dec;
        double d_dec;
        Int64 i64_dec;
        L_Point startLoc;

        if(0!=judgeMaskSize(matIn,mask))
            return 1;
        if(0!=judgeDataNotzero(mask,&startLoc))
        {
            switch(matIn._type)
            {
                case CCV_8UC1:
                    MatClone(matIn,matOut);
                    return 0;
                break;
                default:
                    return 2;
                break;
            }
        }
        matOut->nWidth=matIn.nWidth;
        matOut->nHeight=matIn.nHeight;
        matOut->startx=matIn.startx;
        matOut->starty=matIn.starty;
        matOut->width=matIn.width;
        matOut->height=matIn.height;
        MyconvertTo(matOut,CCV_8UC1);

        switch(matIn._type)
        {
            case CCV_8UC1:
                Mymin_max_gray_mask(matIn,&i32_min,&i32_max,&minloc,&maxloc,mask);
                i32_dec=(255<<8)/(i32_max-i32_min);
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(mask.data[j*nnWidth+i]!=0)
                        {
                            Int32 val=(((matIn.ptr_uchar[j*nnWidth+i]-i32_min)*i32_dec)>>8);
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                }
                return 0;
            break;
            case CCV_8SC1:
                Mymin_max_gray_mask(matIn,&i32_min,&i32_max,&minloc,&maxloc,mask);
                i32_dec=(255<<8)/(i32_max-i32_min);
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(mask.data[j*nnWidth+i]!=0)
                        {
                            Int32 val=(((matIn.ptr_char[j*nnWidth+i]-i32_min)*i32_dec)>>8);
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                }
                return 0;
            break;
            case CCV_16UC1:
                Mymin_max_gray_mask(matIn,&i32_min,&i32_max,&minloc,&maxloc,mask);
                i32_dec=(255<<16)/(i32_max-i32_min);
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(mask.data[j*nnWidth+i]!=0)
                        {
                            Int32 val=(((matIn.ptr_ushort[j*nnWidth+i]-i32_min)*i32_dec)>>16);
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                }
                return 0;
            break;
            case CCV_16SC1:
                Mymin_max_gray_mask(matIn,&i32_min,&i32_max,&minloc,&maxloc,mask);
                i32_dec=(255<<16)/(i32_max-i32_min);
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(mask.data[j*nnWidth+i]!=0)
                        {
                            Int32 val=(((matIn.ptr_short[j*nnWidth+i]-i32_min)*i32_dec)>>16);
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                }
                return 0;
            break;
            case CCV_32SC1:
                Mymin_max_gray_mask(matIn,&i32_min,&i32_max,&minloc,&maxloc,mask);
                i64_dec=(((Uint64)255)<<32)/(i32_max-i32_min);
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(mask.data[j*nnWidth+i]!=0)
                        {
                            Int32 val=(((matIn.ptr_int[j*nnWidth+i]-i32_min)*i64_dec)>>32);
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                }
                return 0;
            break;
            case CCV_32FC1:
                Mymin_max_dgray_mask(matIn,&d_min,&d_max,&minloc,&maxloc,mask);
                f_dec=255.0/(d_max-d_min);
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(mask.data[j*nnWidth+i]!=0)
                        {
                            Int32 val=(matIn.ptr_float[j*nnWidth+i]-d_min)*f_dec+0.5;
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                }
                return 0;
            break;
            case CCV_64FC1:
                Mymin_max_dgray_mask(matIn,&d_min,&d_max,&minloc,&maxloc,mask);
                d_dec=255.0/(d_max-d_min);
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(mask.data[j*nnWidth+i]!=0)
                        {
                            Int32 val=(matIn.ptr_double[j*nnWidth+i]-d_min)*d_dec+0.5;
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                }
                return 0;
            break;
            default:
                return 1;
            break;
        }
    }

    Int8 Mynormalize_lineXY(Mat matIn,Mat *matOut,double value)
    {
        Int32 nnWidth=matIn.nWidth;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        Int32 i,j;
        Int32 i32_max,i32_min;
        float f_max,f_min;
        double d_max,d_min;
        Int32 i32_dec;
        Int64 i64_dec;
        double d_dec;
        Int32 i32_value=(Int32)(value+0.5);
        float f_value=(float)value;

        matOut->nWidth=matIn.nWidth;
        matOut->nHeight=matIn.nHeight;
        matOut->startx=matIn.startx;
        matOut->starty=matIn.starty;
        matOut->width=matIn.width;
        matOut->height=matIn.height;
        MyconvertTo(matOut,CCV_8UC1);

        switch(matIn._type)
        {
            case CCV_8UC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    i32_min=matIn.ptr_uchar[j*nnWidth+nStartX];
                    i32_max=matIn.ptr_uchar[j*nnWidth+nStartX];
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        Int32 val=matIn.ptr_uchar[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        i32_dec=(255<<8)/(i32_max-i32_min);
                        for(i=nStartX;i<nStartX+nWidth;i++)
                        {
                            Int32 val=(((matIn.ptr_uchar[j*nnWidth+i]-i32_min)*i32_dec)>>8);
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                }
                return 0;
            break;
            case CCV_8SC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    i32_min=matIn.ptr_char[j*nnWidth+nStartX];
                    i32_max=matIn.ptr_char[j*nnWidth+nStartX];
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        Int32 val=matIn.ptr_char[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        i32_dec=(255<<8)/(i32_max-i32_min);
                        for(i=nStartX;i<nStartX+nWidth;i++)
                        {
                            Int32 val=(((matIn.ptr_char[j*nnWidth+i]-i32_min)*i32_dec)>>8);
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                }
                return 0;
            break;
            case CCV_16UC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    i32_min=matIn.ptr_ushort[j*nnWidth+nStartX];
                    i32_max=matIn.ptr_ushort[j*nnWidth+nStartX];
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        Int32 val=matIn.ptr_ushort[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        i32_dec=(255<<16)/(i32_max-i32_min);
                        for(i=nStartX;i<nStartX+nWidth;i++)
                        {
                            Int32 val=(((matIn.ptr_ushort[j*nnWidth+i]-i32_min)*i32_dec)>>16);
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                }
                return 0;
            break;
            case CCV_16SC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    i32_min=matIn.ptr_short[j*nnWidth+nStartX];
                    i32_max=matIn.ptr_short[j*nnWidth+nStartX];
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        Int32 val=matIn.ptr_short[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        i32_dec=(255<<16)/(i32_max-i32_min);
                        for(i=nStartX;i<nStartX+nWidth;i++)
                        {
                            Int32 val=(((matIn.ptr_short[j*nnWidth+i]-i32_min)*i32_dec)>>16);
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                }
                return 0;
            break;
            case CCV_32SC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    i32_min=matIn.ptr_int[j*nnWidth+nStartX];
                    i32_max=matIn.ptr_int[j*nnWidth+nStartX];
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        Int32 val=matIn.ptr_int[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        i64_dec=(((Uint64)255)<<32)/(i32_max-i32_min);
                        for(i=nStartX;i<nStartX+nWidth;i++)
                        {
                            Int32 val=(((matIn.ptr_int[j*nnWidth+i]-i32_min)*i64_dec)>>32);
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                }
                return 0;
            break;
            case CCV_32FC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    f_min=matIn.ptr_float[j*nnWidth+nStartX];
                    f_max=matIn.ptr_float[j*nnWidth+nStartX];
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        float val=matIn.ptr_float[j*nnWidth+i];
                        if(f_min>val)
                        {
                            f_min=val;
                        }
                        if(f_max<val)
                        {
                            f_max=val;
                        }
                    }
                    if(f_max-f_min>=f_value)
                    {
                        d_dec=255.0/(double)(f_max-f_min);
                        for(i=nStartX;i<nStartX+nWidth;i++)
                        {
                            Int32 val=(matIn.ptr_float[j*nnWidth+i]-f_min)*d_dec+0.5;
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                }
                return 0;
            break;
            case CCV_64FC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    d_min=matIn.ptr_double[j*nnWidth+nStartX];
                    d_max=matIn.ptr_double[j*nnWidth+nStartX];
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        double val=matIn.ptr_double[j*nnWidth+i];
                        if(d_min>val)
                        {
                            d_min=val;
                        }
                        if(d_max<val)
                        {
                            d_max=val;
                        }
                    }
                    if(d_max-d_min>=value)
                    {
                        d_dec=255.0/(d_max-d_min);
                        for(i=nStartX;i<nStartX+nWidth;i++)
                        {
                            Int32 val=(matIn.ptr_double[j*nnWidth+i]-d_min)*d_dec+0.5;
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                }
                return 0;
            break;
            default:
                return 2;
            break;
        }
    }

    Int8 Mynormalize_lineXY_mask(Mat matIn,Mat *matOut,Mat mask,double value)
    {
        Int32 nnWidth=matIn.nWidth;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        Int32 i,j;
        Int32 i32_max,i32_min;
        float f_max,f_min;
        double d_max,d_min;
        Int32 i32_dec;
        Int64 i64_dec;
        double d_dec;
        Int32 i32_value=(Int32)(value+0.5);
        float f_value=(float)value;
        Uint8 startcheck=FALSE;

        matOut->nWidth=matIn.nWidth;
        matOut->nHeight=matIn.nHeight;
        matOut->startx=matIn.startx;
        matOut->starty=matIn.starty;
        matOut->width=matIn.width;
        matOut->height=matIn.height;
        MyconvertTo(matOut,CCV_8UC1);

        if(0!=judgeMaskSize(matIn,mask))//掩膜不匹配
            return 1;

        switch(matIn._type)
        {
            case CCV_8UC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    startcheck=FALSE;
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(mask.ptr_uchar[j*nnWidth+i]!=0)
                        {
                            Int32 val=matIn.ptr_uchar[j*nnWidth+i];
                            if(startcheck==FALSE)
                            {
                                i32_min=matIn.ptr_uchar[j*nnWidth+i];
                                i32_max=matIn.ptr_uchar[j*nnWidth+i];
                                startcheck=TRUE;
                            }
                            if(i32_min>val)
                            {
                                i32_min=val;
                            }
                            if(i32_max<val)
                            {
                                i32_max=val;
                            }
                        }
                    }
                    if(startcheck==TRUE&&i32_max-i32_min>=i32_value)
                    {
                        i32_dec=(255<<8)/(i32_max-i32_min);
                        for(i=nStartX;i<nStartX+nWidth;i++)
                        {
                            if(mask.ptr_uchar[j*nnWidth+i]!=0)
                            {
                                Int32 val=(((matIn.ptr_uchar[j*nnWidth+i]-i32_min)*i32_dec)>>8);
                                if(val>255)
                                    val=255;
                                if(val<0)
                                    val=0;
                                matOut->data[j*nnWidth+i]=(Uint8)val;
                            }
                        }
                    }
                }
                return 0;
            break;
            case CCV_8SC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    startcheck=FALSE;
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(mask.ptr_uchar[j*nnWidth+i]!=0)
                        {
                            Int32 val=matIn.ptr_char[j*nnWidth+i];
                            if(startcheck==FALSE)
                            {
                                i32_min=matIn.ptr_char[j*nnWidth+i];
                                i32_max=matIn.ptr_char[j*nnWidth+i];
                                startcheck=TRUE;
                            }
                            if(i32_min>val)
                            {
                                i32_min=val;
                            }
                            if(i32_max<val)
                            {
                                i32_max=val;
                            }
                        }
                    }
                    if(startcheck==TRUE&&i32_max-i32_min>=i32_value)
                    {
                        i32_dec=(255<<8)/(i32_max-i32_min);
                        for(i=nStartX;i<nStartX+nWidth;i++)
                        {
                            if(mask.ptr_uchar[j*nnWidth+i]!=0)
                            {
                                Int32 val=(((matIn.ptr_char[j*nnWidth+i]-i32_min)*i32_dec)>>8);
                                if(val>255)
                                    val=255;
                                if(val<0)
                                    val=0;
                                matOut->data[j*nnWidth+i]=(Uint8)val;
                            }
                        }
                    }
                }
                return 0;
            break;
            case CCV_16UC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    startcheck=FALSE;
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(mask.ptr_uchar[j*nnWidth+i]!=0)
                        {
                            Int32 val=matIn.ptr_ushort[j*nnWidth+i];
                            if(startcheck==FALSE)
                            {
                                i32_min=matIn.ptr_ushort[j*nnWidth+i];
                                i32_max=matIn.ptr_ushort[j*nnWidth+i];
                                startcheck=TRUE;
                            }
                            if(i32_min>val)
                            {
                                i32_min=val;
                            }
                            if(i32_max<val)
                            {
                                i32_max=val;
                            }
                        }
                    }
                    if(startcheck==TRUE&&i32_max-i32_min>=i32_value)
                    {
                        i32_dec=(255<<16)/(i32_max-i32_min);
                        for(i=nStartX;i<nStartX+nWidth;i++)
                        {
                            if(mask.ptr_uchar[j*nnWidth+i]!=0)
                            {
                                Int32 val=(((matIn.ptr_ushort[j*nnWidth+i]-i32_min)*i32_dec)>>16);
                                if(val>255)
                                    val=255;
                                if(val<0)
                                    val=0;
                                matOut->data[j*nnWidth+i]=(Uint8)val;
                            }
                        }
                    }
                }
                return 0;
            break;
            case CCV_16SC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    startcheck=FALSE;
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(mask.ptr_uchar[j*nnWidth+i]!=0)
                        {
                            Int32 val=matIn.ptr_short[j*nnWidth+i];
                            if(startcheck==FALSE)
                            {
                                i32_min=matIn.ptr_short[j*nnWidth+i];
                                i32_max=matIn.ptr_short[j*nnWidth+i];
                                startcheck=TRUE;
                            }
                            if(i32_min>val)
                            {
                                i32_min=val;
                            }
                            if(i32_max<val)
                            {
                                i32_max=val;
                            }
                        }
                    }
                    if(startcheck==TRUE&&i32_max-i32_min>=i32_value)
                    {
                        i32_dec=(255<<16)/(i32_max-i32_min);
                        for(i=nStartX;i<nStartX+nWidth;i++)
                        {
                            if(mask.ptr_uchar[j*nnWidth+i]!=0)
                            {
                                Int32 val=(((matIn.ptr_short[j*nnWidth+i]-i32_min)*i32_dec)>>16);
                                if(val>255)
                                    val=255;
                                if(val<0)
                                    val=0;
                                matOut->data[j*nnWidth+i]=(Uint8)val;
                            }
                        }
                    }
                }
                return 0;
            break;
            case CCV_32SC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    startcheck=FALSE;
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(mask.ptr_uchar[j*nnWidth+i]!=0)
                        {
                            Int32 val=matIn.ptr_int[j*nnWidth+i];
                            if(startcheck==FALSE)
                            {
                                i32_min=matIn.ptr_int[j*nnWidth+i];
                                i32_max=matIn.ptr_int[j*nnWidth+i];
                                startcheck=TRUE;
                            }
                            if(i32_min>val)
                            {
                                i32_min=val;
                            }
                            if(i32_max<val)
                            {
                                i32_max=val;
                            }
                        }
                    }
                    if(startcheck==TRUE&&i32_max-i32_min>=i32_value)
                    {
                        i64_dec=(((Uint64)255)<<32)/(i32_max-i32_min);
                        for(i=nStartX;i<nStartX+nWidth;i++)
                        {
                            if(mask.ptr_uchar[j*nnWidth+i]!=0)
                            {
                                Int32 val=(((matIn.ptr_int[j*nnWidth+i]-i32_min)*i64_dec)>>32);
                                if(val>255)
                                    val=255;
                                if(val<0)
                                    val=0;
                                matOut->data[j*nnWidth+i]=(Uint8)val;
                            }
                        }
                    }
                }
                return 0;
            break;
            case CCV_32FC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    startcheck=FALSE;
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(mask.ptr_uchar[j*nnWidth+i]!=0)
                        {
                            float val=matIn.ptr_float[j*nnWidth+i];
                            if(startcheck==FALSE)
                            {
                                f_min=matIn.ptr_float[j*nnWidth+i];
                                f_max=matIn.ptr_float[j*nnWidth+i];
                                startcheck=TRUE;
                            }
                            if(f_min>val)
                            {
                                f_min=val;
                            }
                            if(f_max<val)
                            {
                                f_max=val;
                            }
                        }
                    }
                    if(startcheck==TRUE&&f_max-f_min>=f_value)
                    {
                        d_dec=255.0/(double)(f_max-f_min);
                        for(i=nStartX;i<nStartX+nWidth;i++)
                        {
                            if(mask.ptr_uchar[j*nnWidth+i]!=0)
                            {
                                Int32 val=(matIn.ptr_float[j*nnWidth+i]-f_min)*d_dec+0.5;
                                if(val>255)
                                    val=255;
                                if(val<0)
                                    val=0;
                                matOut->data[j*nnWidth+i]=(Uint8)val;
                            }
                        }
                    }
                }
                return 0;
            break;
            case CCV_64FC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    startcheck=FALSE;
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(mask.ptr_uchar[j*nnWidth+i]!=0)
                        {
                            double val=matIn.ptr_double[j*nnWidth+i];
                            if(startcheck==FALSE)
                            {
                                d_min=matIn.ptr_double[j*nnWidth+i];
                                d_max=matIn.ptr_double[j*nnWidth+i];
                                startcheck=TRUE;
                            }
                            if(d_min>val)
                            {
                                d_min=val;
                            }
                            if(d_max<val)
                            {
                                d_max=val;
                            }
                        }
                    }
                    if(startcheck==TRUE&&d_max-d_min>=value)
                    {
                        d_dec=255.0/(d_max-d_min);
                        for(i=nStartX;i<nStartX+nWidth;i++)
                        {
                            if(mask.ptr_uchar[j*nnWidth+i]!=0)
                            {
                                Int32 val=(matIn.ptr_double[j*nnWidth+i]-d_min)*d_dec+0.5;
                                if(val>255)
                                    val=255;
                                if(val<0)
                                    val=0;
                                matOut->data[j*nnWidth+i]=(Uint8)val;
                            }
                        }
                    }
                }
                return 0;
            break;
            default:
                return 2;
            break;
        }
    }

    Int8 Mynormalize_lineXY_line(Mat matIn,Mat *matOut,L_line lineIn,Int32 lineInsize,double value)
    {
        Int32 nnWidth=matIn.nWidth;
        Int32 nnHeight=matIn.nHeight;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        Int32 i;
        Int32 i32_max,i32_min;
        float f_max,f_min;
        double d_max,d_min;
        Int32 i32_dec;
        Int64 i64_dec;
        double d_dec;
        Int32 i32_value=(Int32)(value+0.5);
        float f_value=(float)value;
        L_line32 l32_line;
        Int32 n;
        Int32 oldj=RANDOM_MAX;

        matOut->nWidth=matIn.nWidth;
        matOut->nHeight=matIn.nHeight;
        matOut->startx=matIn.startx;
        matOut->starty=matIn.starty;
        matOut->width=matIn.width;
        matOut->height=matIn.height;
        MyconvertTo(matOut,CCV_8UC1);

        Myline16to32(lineIn,&l32_line);

        MyLinetoPoint(nnHeight,nnWidth,l32_line.st,l32_line.ed,CV_LINE_8LT,1,&conect_buffer3,u8_buffer_x1Temp3);
        for(n=0;n<conect_buffer3.AllMarkPoint[0].PointArea;n++)
        {
            Int32 sti=conect_buffer3.AllMarkPoint[0].point[n].x-lineInsize/2;
            Int32 j=conect_buffer3.AllMarkPoint[0].point[n].y;
            Int32 endi=sti+lineInsize;
            if(oldj!=j)
                oldj=j;
            else
                continue;
            if(j<nStartY||j>=nStartY+nHeight)
                continue;
            if(sti<nStartX)
            {
                sti=nStartX;
            }
            if(sti>nStartX+nWidth-1)
            {
                sti=nStartX+nWidth-1;
            }
            if(endi<nStartX)
            {
                endi=nStartX;
            }
            if(endi>nStartX+nWidth-1)
            {
                endi=nStartX+nWidth-1;
            }
            switch(matIn._type)
            {
                case CCV_8UC1:
                    i32_min=matIn.ptr_uchar[j*nnWidth+sti];
                    i32_max=matIn.ptr_uchar[j*nnWidth+sti];
                    for(i=sti;i<=endi;i++)
                    {
                        Int32 val=matIn.ptr_uchar[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        i32_dec=(255<<8)/(i32_max-i32_min);
                        for(i=sti;i<=endi;i++)
                        {
                            Int32 val=(((matIn.ptr_uchar[j*nnWidth+i]-i32_min)*i32_dec)>>8);
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                break;
                case CCV_8SC1:
                    i32_min=matIn.ptr_char[j*nnWidth+sti];
                    i32_max=matIn.ptr_char[j*nnWidth+sti];
                    for(i=sti;i<=endi;i++)
                    {
                        Int32 val=matIn.ptr_char[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        i32_dec=(255<<8)/(i32_max-i32_min);
                        for(i=sti;i<=endi;i++)
                        {
                            Int32 val=(((matIn.ptr_char[j*nnWidth+i]-i32_min)*i32_dec)>>8);
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                break;
                case CCV_16UC1:
                    i32_min=matIn.ptr_ushort[j*nnWidth+sti];
                    i32_max=matIn.ptr_ushort[j*nnWidth+sti];
                    for(i=sti;i<=endi;i++)
                    {
                        Int32 val=matIn.ptr_ushort[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        i32_dec=(255<<8)/(i32_max-i32_min);
                        for(i=sti;i<=endi;i++)
                        {
                            Int32 val=(((matIn.ptr_ushort[j*nnWidth+i]-i32_min)*i32_dec)>>16);
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                break;
                case CCV_16SC1:
                    i32_min=matIn.ptr_short[j*nnWidth+sti];
                    i32_max=matIn.ptr_short[j*nnWidth+sti];
                    for(i=sti;i<=endi;i++)
                    {
                        Int32 val=matIn.ptr_short[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        i32_dec=(255<<8)/(i32_max-i32_min);
                        for(i=sti;i<=endi;i++)
                        {
                            Int32 val=(((matIn.ptr_short[j*nnWidth+i]-i32_min)*i32_dec)>>16);
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                break;
                case CCV_32SC1:
                    i32_min=matIn.ptr_int[j*nnWidth+sti];
                    i32_max=matIn.ptr_int[j*nnWidth+sti];
                    for(i=sti;i<=endi;i++)
                    {
                        Int32 val=matIn.ptr_int[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        i64_dec=(((Uint64)255)<<32)/(i32_max-i32_min);
                        for(i=sti;i<=endi;i++)
                        {
                            Int32 val=(((matIn.ptr_int[j*nnWidth+i]-i32_min)*i64_dec)>>32);
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                break;
                case CCV_32FC1:
                    f_min=matIn.ptr_float[j*nnWidth+sti];
                    f_max=matIn.ptr_float[j*nnWidth+sti];
                    for(i=sti;i<=endi;j++)
                    {
                        float val=matIn.ptr_float[j*nnWidth+i];
                        if(f_min>val)
                        {
                            f_min=val;
                        }
                        if(f_max<val)
                        {
                            f_max=val;
                        }
                    }
                    if(f_max-f_min>=f_value)
                    {
                        d_dec=255.0/(double)(f_max-f_min);
                        for(i=sti;i<=endi;i++)
                        {
                            Int32 val=(matIn.ptr_float[j*nnWidth+i]-f_min)*d_dec+0.5;
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                break;
                case CCV_64FC1:
                    d_min=matIn.ptr_double[j*nnWidth+sti];
                    d_max=matIn.ptr_double[j*nnWidth+sti];
                    for(i=sti;i<=endi;i++)
                    {
                        double val=matIn.ptr_double[j*nnWidth+i];
                        if(d_min>val)
                        {
                            d_min=val;
                        }
                        if(d_max<val)
                        {
                            d_max=val;
                        }
                    }
                    if(d_max-d_min>=value)
                    {
                        d_dec=255.0/(double)(d_max-d_min);
                        for(i=sti;i<=endi;i++)
                        {
                            Int32 val=(matIn.ptr_double[j*nnWidth+i]-d_min)*d_dec+0.5;
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                break;
                default:
                    return 2;
                break;
            }
        }

        return 0;
    }

    Int8 Mynormalize_lineXY_line32(Mat matIn,Mat *matOut,L_line32 l32_line,Int32 lineInsize,double value)
    {
        Int32 nnWidth=matIn.nWidth;
        Int32 nnHeight=matIn.nHeight;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        Int32 i;
        Int32 i32_max,i32_min;
        float f_max,f_min;
        double d_max,d_min;
        Int32 i32_dec;
        Int64 i64_dec;
        double d_dec;
        Int32 i32_value=(Int32)(value+0.5);
        float f_value=(float)value;
        Int32 n;
        Int32 oldj=RANDOM_MAX;

        matOut->nWidth=matIn.nWidth;
        matOut->nHeight=matIn.nHeight;
        matOut->startx=matIn.startx;
        matOut->starty=matIn.starty;
        matOut->width=matIn.width;
        matOut->height=matIn.height;
        MyconvertTo(matOut,CCV_8UC1);

        MyLinetoPoint(nnHeight,nnWidth,l32_line.st,l32_line.ed,CV_LINE_8LT,1,&conect_buffer3,u8_buffer_x1Temp3);
        for(n=0;n<conect_buffer3.AllMarkPoint[0].PointArea;n++)
        {
            Int32 sti=conect_buffer3.AllMarkPoint[0].point[n].x-lineInsize/2;
            Int32 j=conect_buffer3.AllMarkPoint[0].point[n].y;
            Int32 endi=sti+lineInsize;
            if(oldj!=j)
                oldj=j;
            else
                continue;
            if(j<nStartY||j>=nStartY+nHeight)
                continue;
            if(sti<nStartX)
            {
                sti=nStartX;
            }
            if(sti>nStartX+nWidth-1)
            {
                sti=nStartX+nWidth-1;
            }
            if(endi<nStartX)
            {
                endi=nStartX;
            }
            if(endi>nStartX+nWidth-1)
            {
                endi=nStartX+nWidth-1;
            }
            switch(matIn._type)
            {
                case CCV_8UC1:
                    i32_min=matIn.ptr_uchar[j*nnWidth+sti];
                    i32_max=matIn.ptr_uchar[j*nnWidth+sti];
                    for(i=sti;i<=endi;i++)
                    {
                        Int32 val=matIn.ptr_uchar[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        i32_dec=(255<<8)/(i32_max-i32_min);
                        for(i=sti;i<=endi;i++)
                        {
                            Int32 val=(((matIn.ptr_uchar[j*nnWidth+i]-i32_min)*i32_dec)>>8);
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                break;
                case CCV_8SC1:
                    i32_min=matIn.ptr_char[j*nnWidth+sti];
                    i32_max=matIn.ptr_char[j*nnWidth+sti];
                    for(i=sti;i<=endi;i++)
                    {
                        Int32 val=matIn.ptr_char[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        i32_dec=(255<<8)/(i32_max-i32_min);
                        for(i=sti;i<=endi;i++)
                        {
                            Int32 val=(((matIn.ptr_char[j*nnWidth+i]-i32_min)*i32_dec)>>8);
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                break;
                case CCV_16UC1:
                    i32_min=matIn.ptr_ushort[j*nnWidth+sti];
                    i32_max=matIn.ptr_ushort[j*nnWidth+sti];
                    for(i=sti;i<=endi;i++)
                    {
                        Int32 val=matIn.ptr_ushort[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        i32_dec=(255<<8)/(i32_max-i32_min);
                        for(i=sti;i<=endi;i++)
                        {
                            Int32 val=(((matIn.ptr_ushort[j*nnWidth+i]-i32_min)*i32_dec)>>16);
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                break;
                case CCV_16SC1:
                    i32_min=matIn.ptr_short[j*nnWidth+sti];
                    i32_max=matIn.ptr_short[j*nnWidth+sti];
                    for(i=sti;i<=endi;i++)
                    {
                        Int32 val=matIn.ptr_short[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        i32_dec=(255<<8)/(i32_max-i32_min);
                        for(i=sti;i<=endi;i++)
                        {
                            Int32 val=(((matIn.ptr_short[j*nnWidth+i]-i32_min)*i32_dec)>>16);
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                break;
                case CCV_32SC1:
                    i32_min=matIn.ptr_int[j*nnWidth+sti];
                    i32_max=matIn.ptr_int[j*nnWidth+sti];
                    for(i=sti;i<=endi;i++)
                    {
                        Int32 val=matIn.ptr_int[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        i64_dec=(((Uint64)255)<<32)/(i32_max-i32_min);
                        for(i=sti;i<=endi;i++)
                        {
                            Int32 val=(((matIn.ptr_int[j*nnWidth+i]-i32_min)*i64_dec)>>32);
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                break;
                case CCV_32FC1:
                    f_min=matIn.ptr_float[j*nnWidth+sti];
                    f_max=matIn.ptr_float[j*nnWidth+sti];
                    for(i=sti;i<=endi;j++)
                    {
                        float val=matIn.ptr_float[j*nnWidth+i];
                        if(f_min>val)
                        {
                            f_min=val;
                        }
                        if(f_max<val)
                        {
                            f_max=val;
                        }
                    }
                    if(f_max-f_min>=f_value)
                    {
                        d_dec=255.0/(double)(f_max-f_min);
                        for(i=sti;i<=endi;i++)
                        {
                            Int32 val=(matIn.ptr_float[j*nnWidth+i]-f_min)*d_dec+0.5;
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                break;
                case CCV_64FC1:
                    d_min=matIn.ptr_double[j*nnWidth+sti];
                    d_max=matIn.ptr_double[j*nnWidth+sti];
                    for(i=sti;i<=endi;i++)
                    {
                        double val=matIn.ptr_double[j*nnWidth+i];
                        if(d_min>val)
                        {
                            d_min=val;
                        }
                        if(d_max<val)
                        {
                            d_max=val;
                        }
                    }
                    if(d_max-d_min>=value)
                    {
                        d_dec=255.0/(double)(d_max-d_min);
                        for(i=sti;i<=endi;i++)
                        {
                            Int32 val=(matIn.ptr_double[j*nnWidth+i]-d_min)*d_dec+0.5;
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                break;
                default:
                    return 2;
                break;
            }
        }

        return 0;
    }

    Int8 Mynormalize_lineXY_downvalue(Mat matIn,Mat *matOut,double value,double downvalue)
    {
        Int32 nnWidth=matIn.nWidth;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        Int32 i,j;
        Int32 i32_max,i32_min;
        float f_max,f_min;
        double d_max,d_min;
        Int32 i32_dec;
        Int64 i64_dec;
        double d_dec;
        Int32 i32_value=(Int32)(value+0.5);
        float f_value=(float)value;
        Int32 i32_downval=(Int32)(downvalue+0.5);
        float f_downval=(float)downvalue;
        double d_downval=downvalue;

        matOut->nWidth=matIn.nWidth;
        matOut->nHeight=matIn.nHeight;
        matOut->startx=matIn.startx;
        matOut->starty=matIn.starty;
        matOut->width=matIn.width;
        matOut->height=matIn.height;
        MyconvertTo(matOut,CCV_8UC1);

        switch(matIn._type)
        {
            case CCV_8UC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    i32_min=matIn.ptr_uchar[j*nnWidth+nStartX];
                    i32_max=matIn.ptr_uchar[j*nnWidth+nStartX];
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        Int32 val=matIn.ptr_uchar[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max>i32_downval)
                    {
                        i32_max=i32_downval;
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        i32_dec=(255<<8)/(i32_max-i32_min);
                        for(i=nStartX;i<nStartX+nWidth;i++)
                        {
                            Int32 val=(((matIn.ptr_uchar[j*nnWidth+i]-i32_min)*i32_dec)>>8);
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                }
                return 0;
            break;
            case CCV_8SC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    i32_min=matIn.ptr_char[j*nnWidth+nStartX];
                    i32_max=matIn.ptr_char[j*nnWidth+nStartX];
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        Int32 val=matIn.ptr_char[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max>i32_downval)
                    {
                        i32_max=i32_downval;
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        i32_dec=(255<<8)/(i32_max-i32_min);
                        for(i=nStartX;i<nStartX+nWidth;i++)
                        {
                            Int32 val=(((matIn.ptr_char[j*nnWidth+i]-i32_min)*i32_dec)>>8);
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                }
                return 0;
            break;
            case CCV_16UC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    i32_min=matIn.ptr_ushort[j*nnWidth+nStartX];
                    i32_max=matIn.ptr_ushort[j*nnWidth+nStartX];
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        Int32 val=matIn.ptr_ushort[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max>i32_downval)
                    {
                        i32_max=i32_downval;
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        i32_dec=(255<<16)/(i32_max-i32_min);
                        for(i=nStartX;i<nStartX+nWidth;i++)
                        {
                            Int32 val=(((matIn.ptr_ushort[j*nnWidth+i]-i32_min)*i32_dec)>>16);
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                }
                return 0;
            break;
            case CCV_16SC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    i32_min=matIn.ptr_short[j*nnWidth+nStartX];
                    i32_max=matIn.ptr_short[j*nnWidth+nStartX];
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        Int32 val=matIn.ptr_short[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max>i32_downval)
                    {
                        i32_max=i32_downval;
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        i32_dec=(255<<16)/(i32_max-i32_min);
                        for(i=nStartX;i<nStartX+nWidth;i++)
                        {
                            Int32 val=(((matIn.ptr_short[j*nnWidth+i]-i32_min)*i32_dec)>>16);
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                }
                return 0;
            break;
            case CCV_32SC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    i32_min=matIn.ptr_int[j*nnWidth+nStartX];
                    i32_max=matIn.ptr_int[j*nnWidth+nStartX];
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        Int32 val=matIn.ptr_int[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max>i32_downval)
                    {
                        i32_max=i32_downval;
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        i64_dec=(((Uint64)255)<<32)/(i32_max-i32_min);
                        for(i=nStartX;i<nStartX+nWidth;i++)
                        {
                            Int32 val=(((matIn.ptr_int[j*nnWidth+i]-i32_min)*i64_dec)>>32);
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                }
                return 0;
            break;
            case CCV_32FC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    f_min=matIn.ptr_float[j*nnWidth+nStartX];
                    f_max=matIn.ptr_float[j*nnWidth+nStartX];
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        float val=matIn.ptr_float[j*nnWidth+i];
                        if(f_min>val)
                        {
                            f_min=val;
                        }
                        if(f_max<val)
                        {
                            f_max=val;
                        }
                    }
                    if(f_max>f_downval)
                    {
                        f_max=f_downval;
                    }
                    if(f_max-f_min>=f_value)
                    {
                        d_dec=255.0/(double)(f_max-f_min);
                        for(i=nStartX;i<nStartX+nWidth;i++)
                        {
                            Int32 val=(matIn.ptr_float[j*nnWidth+i]-f_min)*d_dec+0.5;
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                }
                return 0;
            break;
            case CCV_64FC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    d_min=matIn.ptr_double[j*nnWidth+nStartX];
                    d_max=matIn.ptr_double[j*nnWidth+nStartX];
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        double val=matIn.ptr_double[j*nnWidth+i];
                        if(d_min>val)
                        {
                            d_min=val;
                        }
                        if(d_max<val)
                        {
                            d_max=val;
                        }
                    }
                    if(d_max>d_downval)
                    {
                        d_max=d_downval;
                    }
                    if(d_max-d_min>=value)
                    {
                        d_dec=255.0/(d_max-d_min);
                        for(i=nStartX;i<nStartX+nWidth;i++)
                        {
                            Int32 val=(matIn.ptr_double[j*nnWidth+i]-d_min)*d_dec+0.5;
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                }
                return 0;
            break;
            default:
                return 2;
            break;
        }
    }

    Int8 Mynormalize_lineXY_downvalue_mask(Mat matIn,Mat *matOut,Mat mask,double value,double downvalue)
    {
        Uint32 nnWidth=matIn.nWidth;
        Uint32 nStartX=matIn.startx;
        Uint32 nStartY=matIn.starty;
        Uint32 nWidth=matIn.width;
        Uint32 nHeight=matIn.height;
        Int32 i,j;
        Int32 i32_max,i32_min;
        float f_max,f_min;
        double d_max,d_min;
        Int32 i32_dec;
        Int64 i64_dec;
        double d_dec;
        Int32 i32_value=(Int32)(value+0.5);
        float f_value=(float)value;
        Int32 i32_downval=(Int32)(downvalue+0.5);
        float f_downval=(float)downvalue;
        double d_downval=downvalue;
        Uint8 startcheck=FALSE;

        matOut->nWidth=matIn.nWidth;
        matOut->nHeight=matIn.nHeight;
        matOut->startx=matIn.startx;
        matOut->starty=matIn.starty;
        matOut->width=matIn.width;
        matOut->height=matIn.height;
        MyconvertTo(matOut,CCV_8UC1);

        if(0!=judgeMaskSize(matIn,mask))
            return 1;

        switch(matIn._type)
        {
            case CCV_8UC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    startcheck=FALSE;
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(mask.ptr_uchar[j*nnWidth+i]!=0)
                        {
                            Int32 val=matIn.ptr_uchar[j*nnWidth+i];
                            if(startcheck==FALSE)
                            {
                                i32_min=matIn.ptr_uchar[j*nnWidth+i];
                                i32_max=matIn.ptr_uchar[j*nnWidth+i];
                                startcheck=TRUE;
                            }
                            if(i32_min>val)
                            {
                                i32_min=val;
                            }
                            if(i32_max<val)
                            {
                                i32_max=val;
                            }
                        }
                    }
                    if(i32_max>i32_downval)
                    {
                        i32_max=i32_downval;
                    }
                    if(startcheck==TRUE&&i32_max-i32_min>=i32_value)
                    {
                        i32_dec=(255<<8)/(i32_max-i32_min);
                        for(i=nStartX;i<nStartX+nWidth;i++)
                        {
                            if(mask.ptr_uchar[j*nnWidth+i]!=0)
                            {
                                Int32 val=(((matIn.ptr_uchar[j*nnWidth+i]-i32_min)*i32_dec)>>8);
                                if(val>255)
                                    val=255;
                                if(val<0)
                                    val=0;
                                matOut->data[j*nnWidth+i]=(Uint8)val;
                            }
                        }
                    }
                }
                return 0;
            break;
            case CCV_8SC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    startcheck=FALSE;
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(mask.ptr_uchar[j*nnWidth+i]!=0)
                        {
                            Int32 val=matIn.ptr_char[j*nnWidth+i];
                            if(startcheck==FALSE)
                            {
                                i32_min=matIn.ptr_char[j*nnWidth+i];
                                i32_max=matIn.ptr_char[j*nnWidth+i];
                                startcheck=TRUE;
                            }
                            if(i32_min>val)
                            {
                                i32_min=val;
                            }
                            if(i32_max<val)
                            {
                                i32_max=val;
                            }
                        }
                    }
                    if(i32_max>i32_downval)
                    {
                        i32_max=i32_downval;
                    }
                    if(startcheck==TRUE&&i32_max-i32_min>=i32_value)
                    {
                        i32_dec=(255<<8)/(i32_max-i32_min);
                        for(i=nStartX;i<nStartX+nWidth;i++)
                        {
                            if(mask.ptr_uchar[j*nnWidth+i]!=0)
                            {
                                Int32 val=(((matIn.ptr_char[j*nnWidth+i]-i32_min)*i32_dec)>>8);
                                if(val>255)
                                    val=255;
                                if(val<0)
                                    val=0;
                                matOut->data[j*nnWidth+i]=(Uint8)val;
                            }
                        }
                    }
                }
                return 0;
            break;
            case CCV_16UC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    startcheck=FALSE;
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(mask.ptr_uchar[j*nnWidth+i]!=0)
                        {
                            Int32 val=matIn.ptr_ushort[j*nnWidth+i];
                            if(startcheck==FALSE)
                            {
                                i32_min=matIn.ptr_ushort[j*nnWidth+i];
                                i32_max=matIn.ptr_ushort[j*nnWidth+i];
                                startcheck=TRUE;
                            }
                            if(i32_min>val)
                            {
                                i32_min=val;
                            }
                            if(i32_max<val)
                            {
                                i32_max=val;
                            }
                        }
                    }
                    if(i32_max>i32_downval)
                    {
                        i32_max=i32_downval;
                    }
                    if(startcheck==TRUE&&i32_max-i32_min>=i32_value)
                    {
                        i32_dec=(255<<16)/(i32_max-i32_min);
                        for(i=nStartX;i<nStartX+nWidth;i++)
                        {
                            if(mask.ptr_uchar[j*nnWidth+i]!=0)
                            {
                                Int32 val=(((matIn.ptr_ushort[j*nnWidth+i]-i32_min)*i32_dec)>>16);
                                if(val>255)
                                    val=255;
                                if(val<0)
                                    val=0;
                                matOut->data[j*nnWidth+i]=(Uint8)val;
                            }
                        }
                    }
                }
                return 0;
            break;
            case CCV_16SC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    startcheck=FALSE;
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(mask.ptr_uchar[j*nnWidth+i]!=0)
                        {
                            Int32 val=matIn.ptr_short[j*nnWidth+i];
                            if(startcheck==FALSE)
                            {
                                i32_min=matIn.ptr_short[j*nnWidth+i];
                                i32_max=matIn.ptr_short[j*nnWidth+i];
                                startcheck=TRUE;
                            }
                            if(i32_min>val)
                            {
                                i32_min=val;
                            }
                            if(i32_max<val)
                            {
                                i32_max=val;
                            }
                        }
                    }
                    if(i32_max>i32_downval)
                    {
                        i32_max=i32_downval;
                    }
                    if(startcheck==TRUE&&i32_max-i32_min>=i32_value)
                    {
                        i32_dec=(255<<16)/(i32_max-i32_min);
                        for(i=nStartX;i<nStartX+nWidth;i++)
                        {
                            if(mask.ptr_uchar[j*nnWidth+i]!=0)
                            {
                                Int32 val=(((matIn.ptr_short[j*nnWidth+i]-i32_min)*i32_dec)>>16);
                                if(val>255)
                                    val=255;
                                if(val<0)
                                    val=0;
                                matOut->data[j*nnWidth+i]=(Uint8)val;
                            }
                        }
                    }
                }
                return 0;
            break;
            case CCV_32SC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    startcheck=FALSE;
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(mask.ptr_uchar[j*nnWidth+i]!=0)
                        {
                            Int32 val=matIn.ptr_int[j*nnWidth+i];
                            if(startcheck==FALSE)
                            {
                                i32_min=matIn.ptr_int[j*nnWidth+i];
                                i32_max=matIn.ptr_int[j*nnWidth+i];
                                startcheck=TRUE;
                            }
                            if(i32_min>val)
                            {
                                i32_min=val;
                            }
                            if(i32_max<val)
                            {
                                i32_max=val;
                            }
                        }
                    }
                    if(i32_max>i32_downval)
                    {
                        i32_max=i32_downval;
                    }
                    if(startcheck==TRUE&&i32_max-i32_min>=i32_value)
                    {
                        i64_dec=(((Uint64)255)<<32)/(i32_max-i32_min);
                        for(i=nStartX;i<nStartX+nWidth;i++)
                        {
                            if(mask.ptr_uchar[j*nnWidth+i]!=0)
                            {
                                Int32 val=(((matIn.ptr_int[j*nnWidth+i]-i32_min)*i64_dec)>>32);
                                if(val>255)
                                    val=255;
                                if(val<0)
                                    val=0;
                                matOut->data[j*nnWidth+i]=(Uint8)val;
                            }
                        }
                    }
                }
                return 0;
            break;
            case CCV_32FC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    startcheck=FALSE;
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(mask.ptr_uchar[j*nnWidth+i]!=0)
                        {
                            float val=matIn.ptr_float[j*nnWidth+i];
                            if(startcheck==FALSE)
                            {
                                f_min=matIn.ptr_float[j*nnWidth+i];
                                f_max=matIn.ptr_float[j*nnWidth+i];
                                startcheck=TRUE;
                            }
                            if(f_min>val)
                            {
                                f_min=val;
                            }
                            if(f_max<val)
                            {
                                f_max=val;
                            }
                        }
                    }
                    if(f_max>f_downval)
                    {
                        f_max=f_downval;
                    }
                    if(startcheck==TRUE&&f_max-f_min>=f_value)
                    {
                        d_dec=255.0/(double)(f_max-f_min);
                        for(i=nStartX;i<nStartX+nWidth;i++)
                        {
                            if(mask.ptr_uchar[j*nnWidth+i]!=0)
                            {
                                Int32 val=(matIn.ptr_float[j*nnWidth+i]-f_min)*d_dec+0.5;
                                if(val>255)
                                    val=255;
                                if(val<0)
                                    val=0;
                                matOut->data[j*nnWidth+i]=(Uint8)val;
                            }
                        }
                    }
                }
                return 0;
            break;
            case CCV_64FC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    startcheck=FALSE;
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(mask.ptr_uchar[j*nnWidth+i]!=0)
                        {
                            double val=matIn.ptr_double[j*nnWidth+i];
                            if(startcheck==FALSE)
                            {
                                d_min=matIn.ptr_double[j*nnWidth+i];
                                d_max=matIn.ptr_double[j*nnWidth+i];
                                startcheck=TRUE;
                            }
                            if(d_min>val)
                            {
                                d_min=val;
                            }
                            if(d_max<val)
                            {
                                d_max=val;
                            }
                        }
                    }
                    if(d_max>d_downval)
                    {
                        d_max=d_downval;
                    }
                    if(startcheck==TRUE&&d_max-d_min>=value)
                    {
                        d_dec=255.0/(d_max-d_min);
                        for(i=nStartX;i<nStartX+nWidth;i++)
                        {
                            if(mask.ptr_uchar[j*nnWidth+i]!=0)
                            {
                                Int32 val=(matIn.ptr_double[j*nnWidth+i]-d_min)*d_dec+0.5;
                                if(val>255)
                                    val=255;
                                if(val<0)
                                    val=0;
                                matOut->data[j*nnWidth+i]=(Uint8)val;
                            }
                        }
                    }
                }
                return 0;
            break;
            default:
                return 2;
            break;
        }
    }

    Int8 Mynormalize_rowXY(Mat matIn,Mat *matOut,double value)
    {
        Int32 nnWidth=matIn.nWidth;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        Int32 i,j;
        Int32 i32_max,i32_min;
        float f_max,f_min;
        double d_max,d_min;
        Int32 i32_dec;
        Int64 i64_dec;
        double d_dec;
        Int32 i32_value=(Int32)(value+0.5);
        float f_value=(float)value;

        matOut->nWidth=matIn.nWidth;
        matOut->nHeight=matIn.nHeight;
        matOut->startx=matIn.startx;
        matOut->starty=matIn.starty;
        matOut->width=matIn.width;
        matOut->height=matIn.height;
        MyconvertTo(matOut,CCV_8UC1);

        switch(matIn._type)
        {
            case CCV_8UC1:
                for(i=nStartX;i<nStartX+nWidth;i++)
                {
                    i32_min=matIn.ptr_uchar[nStartY*nnWidth+i];
                    i32_max=matIn.ptr_uchar[nStartY*nnWidth+i];
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        Int32 val=matIn.ptr_uchar[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        i32_dec=(255<<8)/(i32_max-i32_min);
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            Int32 val=(((matIn.ptr_uchar[j*nnWidth+i]-i32_min)*i32_dec)>>8);
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                }
                return 0;
            break;
            case CCV_8SC1:
                for(i=nStartX;i<nStartX+nWidth;i++)
                {
                    i32_min=matIn.ptr_char[nStartY*nnWidth+i];
                    i32_max=matIn.ptr_char[nStartY*nnWidth+i];
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        Int32 val=matIn.ptr_char[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        i32_dec=(255<<8)/(i32_max-i32_min);
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            Int32 val=(((matIn.ptr_char[j*nnWidth+i]-i32_min)*i32_dec)>>8);
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                }
                return 0;
            break;
            case CCV_16UC1:
                for(i=nStartX;i<nStartX+nWidth;i++)
                {
                    i32_min=matIn.ptr_ushort[nStartY*nnWidth+i];
                    i32_max=matIn.ptr_ushort[nStartY*nnWidth+i];
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        Int32 val=matIn.ptr_ushort[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        i32_dec=(255<<16)/(i32_max-i32_min);
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            Int32 val=(((matIn.ptr_ushort[j*nnWidth+i]-i32_min)*i32_dec)>>16);
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                }
                return 0;
            break;
            case CCV_16SC1:
                for(i=nStartX;i<nStartX+nWidth;i++)
                {
                    i32_min=matIn.ptr_short[nStartY*nnWidth+i];
                    i32_max=matIn.ptr_short[nStartY*nnWidth+i];
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        Int32 val=matIn.ptr_short[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        i32_dec=(255<<16)/(i32_max-i32_min);
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            Int32 val=(((matIn.ptr_short[j*nnWidth+i]-i32_min)*i32_dec)>>16);
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                }
                return 0;
            break;
            case CCV_32SC1:
                for(i=nStartX;i<nStartX+nWidth;i++)
                {
                    i32_min=matIn.ptr_int[nStartY*nnWidth+i];
                    i32_max=matIn.ptr_int[nStartY*nnWidth+i];
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        Int32 val=matIn.ptr_int[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        i64_dec=(((Uint64)255)<<32)/(i32_max-i32_min);
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            Int32 val=(((matIn.ptr_int[j*nnWidth+i]-i32_min)*i64_dec)>>32);
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                }
                return 0;
            break;
            case CCV_32FC1:
                for(i=nStartX;i<nStartX+nWidth;i++)
                {
                    f_min=matIn.ptr_float[nStartY*nnWidth+i];
                    f_max=matIn.ptr_float[nStartY*nnWidth+i];
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        float val=matIn.ptr_float[j*nnWidth+i];
                        if(f_min>val)
                        {
                            f_min=val;
                        }
                        if(f_max<val)
                        {
                            f_max=val;
                        }
                    }
                    if(f_max-f_min>=f_value)
                    {
                        d_dec=255.0/(double)(f_max-f_min);
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            Int32 val=(matIn.ptr_float[j*nnWidth+i]-f_min)*d_dec+0.5;
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                }
                return 0;
            break;
            case CCV_64FC1:
                for(i=nStartX;i<nStartX+nWidth;i++)
                {
                    d_min=matIn.ptr_double[nStartY*nnWidth+i];
                    d_max=matIn.ptr_double[nStartY*nnWidth+i];
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        double val=matIn.ptr_double[j*nnWidth+i];
                        if(d_min>val)
                        {
                            d_min=val;
                        }
                        if(d_max<val)
                        {
                            d_max=val;
                        }
                    }
                    if(d_max-d_min>=value)
                    {
                        d_dec=255.0/(d_max-d_min);
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            Int32 val=(matIn.ptr_double[j*nnWidth+i]-d_min)*d_dec+0.5;
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                }
                return 0;
            break;
            default:
                return 2;
            break;
        }
    }

    Int8 Mynormalize_rowXY_mask(Mat matIn,Mat *matOut,Mat mask,double value)
    {
        Int32 nnWidth=matIn.nWidth;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        Int32 i,j;
        Int32 i32_max,i32_min;
        float f_max,f_min;
        double d_max,d_min;
        Int32 i32_dec;
        Int64 i64_dec;
        double d_dec;
        Int32 i32_value=(Int32)(value+0.5);
        float f_value=(float)value;
        Uint8 startcheck=FALSE;

        matOut->nWidth=matIn.nWidth;
        matOut->nHeight=matIn.nHeight;
        matOut->startx=matIn.startx;
        matOut->starty=matIn.starty;
        matOut->width=matIn.width;
        matOut->height=matIn.height;
        MyconvertTo(matOut,CCV_8UC1);

        if(0!=judgeMaskSize(matIn,mask))//掩膜不匹配
            return 1;

        switch(matIn._type)
        {
            case CCV_8UC1:
                for(i=nStartX;i<nStartX+nWidth;i++)
                {
                    startcheck=FALSE;
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        if(mask.ptr_uchar[j*nnWidth+i]!=0)
                        {
                            Int32 val=matIn.ptr_uchar[j*nnWidth+i];
                            if(startcheck==FALSE)
                            {
                                i32_min=matIn.ptr_uchar[j*nnWidth+i];
                                i32_max=matIn.ptr_uchar[j*nnWidth+i];
                                startcheck=TRUE;
                            }
                            if(i32_min>val)
                            {
                                i32_min=val;
                            }
                            if(i32_max<val)
                            {
                                i32_max=val;
                            }
                        }
                    }
                    if(startcheck==TRUE&&i32_max-i32_min>=i32_value)
                    {
                        i32_dec=(255<<8)/(i32_max-i32_min);
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            if(mask.ptr_uchar[j*nnWidth+i]!=0)
                            {
                                Int32 val=(((matIn.ptr_uchar[j*nnWidth+i]-i32_min)*i32_dec)>>8);
                                if(val>255)
                                    val=255;
                                if(val<0)
                                    val=0;
                                matOut->data[j*nnWidth+i]=(Uint8)val;
                            }
                        }
                    }
                }
                return 0;
            break;
            case CCV_8SC1:
                for(i=nStartX;i<nStartX+nWidth;i++)
                {
                    startcheck=FALSE;
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        if(mask.ptr_uchar[j*nnWidth+i]!=0)
                        {
                            Int32 val=matIn.ptr_char[j*nnWidth+i];
                            if(startcheck==FALSE)
                            {
                                i32_min=matIn.ptr_char[j*nnWidth+i];
                                i32_max=matIn.ptr_char[j*nnWidth+i];
                                startcheck=TRUE;
                            }
                            if(i32_min>val)
                            {
                                i32_min=val;
                            }
                            if(i32_max<val)
                            {
                                i32_max=val;
                            }
                        }
                    }
                    if(startcheck==TRUE&&i32_max-i32_min>=i32_value)
                    {
                        i32_dec=(255<<8)/(i32_max-i32_min);
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            if(mask.ptr_uchar[j*nnWidth+i]!=0)
                            {
                                Int32 val=(((matIn.ptr_char[j*nnWidth+i]-i32_min)*i32_dec)>>8);
                                if(val>255)
                                    val=255;
                                if(val<0)
                                    val=0;
                                matOut->data[j*nnWidth+i]=(Uint8)val;
                            }
                        }
                    }
                }
                return 0;
            break;
            case CCV_16UC1:
                for(i=nStartX;i<nStartX+nWidth;i++)
                {
                    startcheck=FALSE;
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        if(mask.ptr_uchar[j*nnWidth+i]!=0)
                        {
                            Int32 val=matIn.ptr_ushort[j*nnWidth+i];
                            if(startcheck==FALSE)
                            {
                                i32_min=matIn.ptr_ushort[j*nnWidth+i];
                                i32_max=matIn.ptr_ushort[j*nnWidth+i];
                                startcheck=TRUE;
                            }
                            if(i32_min>val)
                            {
                                i32_min=val;
                            }
                            if(i32_max<val)
                            {
                                i32_max=val;
                            }
                        }
                    }
                    if(startcheck==TRUE&&i32_max-i32_min>=i32_value)
                    {
                        i32_dec=(255<<16)/(i32_max-i32_min);
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            if(mask.ptr_uchar[j*nnWidth+i]!=0)
                            {
                                Int32 val=(((matIn.ptr_ushort[j*nnWidth+i]-i32_min)*i32_dec)>>16);
                                if(val>255)
                                    val=255;
                                if(val<0)
                                    val=0;
                                matOut->data[j*nnWidth+i]=(Uint8)val;
                            }
                        }
                    }
                }
                return 0;
            break;
            case CCV_16SC1:
                for(i=nStartX;i<nStartX+nWidth;i++)
                {
                    startcheck=FALSE;
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        if(mask.ptr_uchar[j*nnWidth+i]!=0)
                        {
                            Int32 val=matIn.ptr_short[j*nnWidth+i];
                            if(startcheck==FALSE)
                            {
                                i32_min=matIn.ptr_short[j*nnWidth+i];
                                i32_max=matIn.ptr_short[j*nnWidth+i];
                                startcheck=TRUE;
                            }
                            if(i32_min>val)
                            {
                                i32_min=val;
                            }
                            if(i32_max<val)
                            {
                                i32_max=val;
                            }
                        }
                    }
                    if(startcheck==TRUE&&i32_max-i32_min>=i32_value)
                    {
                        i32_dec=(255<<16)/(i32_max-i32_min);
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            if(mask.ptr_uchar[j*nnWidth+i]!=0)
                            {
                                Int32 val=(((matIn.ptr_short[j*nnWidth+i]-i32_min)*i32_dec)>>16);
                                if(val>255)
                                    val=255;
                                if(val<0)
                                    val=0;
                                matOut->data[j*nnWidth+i]=(Uint8)val;
                            }
                        }
                    }
                }
                return 0;
            break;
            case CCV_32SC1:
                for(i=nStartX;i<nStartX+nWidth;i++)
                {
                    startcheck=FALSE;
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        if(mask.ptr_uchar[j*nnWidth+i]!=0)
                        {
                            Int32 val=matIn.ptr_int[j*nnWidth+i];
                            if(startcheck==FALSE)
                            {
                                i32_min=matIn.ptr_int[j*nnWidth+i];
                                i32_max=matIn.ptr_int[j*nnWidth+i];
                                startcheck=TRUE;
                            }
                            if(i32_min>val)
                            {
                                i32_min=val;
                            }
                            if(i32_max<val)
                            {
                                i32_max=val;
                            }
                        }
                    }
                    if(startcheck==TRUE&&i32_max-i32_min>=i32_value)
                    {
                        i64_dec=(((Uint64)255)<<32)/(i32_max-i32_min);
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            if(mask.ptr_uchar[j*nnWidth+i]!=0)
                            {
                                Int32 val=(((matIn.ptr_int[j*nnWidth+i]-i32_min)*i64_dec)>>32);
                                if(val>255)
                                    val=255;
                                if(val<0)
                                    val=0;
                                matOut->data[j*nnWidth+i]=(Uint8)val;
                            }
                        }
                    }
                }
                return 0;
            break;
            case CCV_32FC1:
                for(i=nStartX;i<nStartX+nWidth;i++)
                {
                    startcheck=FALSE;
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        if(mask.ptr_uchar[j*nnWidth+i]!=0)
                        {
                            float val=matIn.ptr_float[j*nnWidth+i];
                            if(startcheck==FALSE)
                            {
                                f_min=matIn.ptr_float[j*nnWidth+i];
                                f_max=matIn.ptr_float[j*nnWidth+i];
                                startcheck=TRUE;
                            }
                            if(f_min>val)
                            {
                                f_min=val;
                            }
                            if(f_max<val)
                            {
                                f_max=val;
                            }
                        }
                    }
                    if(startcheck==TRUE&&f_max-f_min>=f_value)
                    {
                        d_dec=255.0/(double)(f_max-f_min);
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            if(mask.ptr_uchar[j*nnWidth+i]!=0)
                            {
                                Int32 val=(matIn.ptr_float[j*nnWidth+i]-f_min)*d_dec+0.5;
                                if(val>255)
                                    val=255;
                                if(val<0)
                                    val=0;
                                matOut->data[j*nnWidth+i]=(Uint8)val;
                            }
                        }
                    }
                }
                return 0;
            break;
            case CCV_64FC1:
                for(i=nStartX;i<nStartX+nWidth;i++)
                {
                    startcheck=FALSE;
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        if(mask.ptr_uchar[j*nnWidth+i]!=0)
                        {
                            double val=matIn.ptr_double[j*nnWidth+i];
                            if(startcheck==FALSE)
                            {
                                d_min=matIn.ptr_double[j*nnWidth+i];
                                d_max=matIn.ptr_double[j*nnWidth+i];
                                startcheck=TRUE;
                            }
                            if(d_min>val)
                            {
                                d_min=val;
                            }
                            if(d_max<val)
                            {
                                d_max=val;
                            }
                        }
                    }
                    if(startcheck==TRUE&&d_max-d_min>=value)
                    {
                        d_dec=255.0/(d_max-d_min);
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            if(mask.ptr_uchar[j*nnWidth+i]!=0)
                            {
                                Int32 val=(matIn.ptr_double[j*nnWidth+i]-d_min)*d_dec+0.5;
                                if(val>255)
                                    val=255;
                                if(val<0)
                                    val=0;
                                matOut->data[j*nnWidth+i]=(Uint8)val;
                            }
                        }
                    }
                }
                return 0;
            break;
            default:
                return 2;
            break;
        }
    }

    Int8 Mynormalize_rowXY_line(Mat matIn,Mat *matOut,L_line lineIn,Int32 lineInsize,double value)
    {
        Int32 nnWidth=matIn.nWidth;
        Int32 nnHeight=matIn.nHeight;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        Int32 j;
        Int32 i32_max,i32_min;
        float f_max,f_min;
        double d_max,d_min;
        Int32 i32_dec;
        Int64 i64_dec;
        double d_dec;
        Int32 i32_value=(Int32)(value+0.5);
        float f_value=(float)value;
        L_line32 l32_line;
        Int32 n;
        Int32 oldj=RANDOM_MAX;

        matOut->nWidth=matIn.nWidth;
        matOut->nHeight=matIn.nHeight;
        matOut->startx=matIn.startx;
        matOut->starty=matIn.starty;
        matOut->width=matIn.width;
        matOut->height=matIn.height;
        MyconvertTo(matOut,CCV_8UC1);

        Myline16to32(lineIn,&l32_line);

        MyLinetoPoint(nnHeight,nnWidth,l32_line.st,l32_line.ed,CV_LINE_8LT,1,&conect_buffer3,u8_buffer_x1Temp3);
        for(n=0;n<conect_buffer3.AllMarkPoint[0].PointArea;n++)
        {
            Int32 stj=conect_buffer3.AllMarkPoint[0].point[n].y-lineInsize/2;
            Int32 i=conect_buffer3.AllMarkPoint[0].point[n].x;
            Int32 endj=stj+lineInsize;
            if(oldj!=i)
                oldj=i;
            else
                continue;
            if(i<nStartX||i>=nStartX+nWidth)
                continue;
            if(stj<nStartY)
            {
                stj=nStartY;
            }
            if(stj>nStartY+nHeight-1)
            {
                stj=nStartY+nHeight-1;
            }
            if(endj<nStartY)
            {
                endj=nStartY;
            }
            if(endj>nStartY+nHeight-1)
            {
                endj=nStartY+nHeight-1;
            }
            switch(matIn._type)
            {
                case CCV_8UC1:
                    i32_min=matIn.ptr_uchar[stj*nnWidth+i];
                    i32_max=matIn.ptr_uchar[stj*nnWidth+i];
                    for(j=stj;j<=endj;j++)
                    {
                        Int32 val=matIn.ptr_uchar[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        i32_dec=(255<<8)/(i32_max-i32_min);
                        for(j=stj;j<=endj;j++)
                        {
                            Int32 val=(((matIn.ptr_uchar[j*nnWidth+i]-i32_min)*i32_dec)>>8);
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                break;
                case CCV_8SC1:
                    i32_min=matIn.ptr_char[stj*nnWidth+i];
                    i32_max=matIn.ptr_char[stj*nnWidth+i];
                    for(j=stj;j<=endj;j++)
                    {
                        Int32 val=matIn.ptr_char[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        i32_dec=(255<<8)/(i32_max-i32_min);
                        for(j=stj;j<=endj;j++)
                        {
                            Int32 val=(((matIn.ptr_char[j*nnWidth+i]-i32_min)*i32_dec)>>8);
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                break;
                case CCV_16UC1:
                    i32_min=matIn.ptr_ushort[stj*nnWidth+i];
                    i32_max=matIn.ptr_ushort[stj*nnWidth+i];
                    for(j=stj;j<=endj;j++)
                    {
                        Int32 val=matIn.ptr_ushort[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        i32_dec=(255<<8)/(i32_max-i32_min);
                        for(j=stj;j<=endj;j++)
                        {
                            Int32 val=(((matIn.ptr_ushort[j*nnWidth+i]-i32_min)*i32_dec)>>16);
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                break;
                case CCV_16SC1:
                    i32_min=matIn.ptr_short[stj*nnWidth+i];
                    i32_max=matIn.ptr_short[stj*nnWidth+i];
                    for(j=stj;j<=endj;j++)
                    {
                        Int32 val=matIn.ptr_short[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        i32_dec=(255<<8)/(i32_max-i32_min);
                        for(j=stj;j<=endj;j++)
                        {
                            Int32 val=(((matIn.ptr_short[j*nnWidth+i]-i32_min)*i32_dec)>>16);
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                break;
                case CCV_32SC1:
                    i32_min=matIn.ptr_int[stj*nnWidth+i];
                    i32_max=matIn.ptr_int[stj*nnWidth+i];
                    for(j=stj;j<=endj;j++)
                    {
                        Int32 val=matIn.ptr_int[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        i64_dec=(((Uint64)255)<<32)/(i32_max-i32_min);
                        for(j=stj;j<=endj;j++)
                        {
                            Int32 val=(((matIn.ptr_int[j*nnWidth+i]-i32_min)*i64_dec)>>32);
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                break;
                case CCV_32FC1:
                    f_min=matIn.ptr_float[stj*nnWidth+i];
                    f_max=matIn.ptr_float[stj*nnWidth+i];
                    for(j=stj;j<=endj;j++)
                    {
                        float val=matIn.ptr_float[j*nnWidth+i];
                        if(f_min>val)
                        {
                            f_min=val;
                        }
                        if(f_max<val)
                        {
                            f_max=val;
                        }
                    }
                    if(f_max-f_min>=f_value)
                    {
                        d_dec=255.0/(double)(f_max-f_min);
                        for(j=stj;j<=endj;j++)
                        {
                            Int32 val=(matIn.ptr_float[j*nnWidth+i]-f_min)*d_dec+0.5;
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                break;
                case CCV_64FC1:
                    d_min=matIn.ptr_double[stj*nnWidth+i];
                    d_max=matIn.ptr_double[stj*nnWidth+i];
                    for(j=stj;j<=endj;j++)
                    {
                        double val=matIn.ptr_double[j*nnWidth+i];
                        if(d_min>val)
                        {
                            d_min=val;
                        }
                        if(d_max<val)
                        {
                            d_max=val;
                        }
                    }
                    if(d_max-d_min>=value)
                    {
                        d_dec=255.0/(double)(d_max-d_min);
                        for(j=stj;j<=endj;j++)
                        {
                            Int32 val=(matIn.ptr_double[j*nnWidth+i]-d_min)*d_dec+0.5;
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                break;
                default:
                    return 2;
                break;
            }
        }

        return 0;
    }

    Int8 Mynormalize_rowXY_line32(Mat matIn,Mat *matOut,L_line32 l32_line,Int32 lineInsize,double value)
    {
        Int32 nnWidth=matIn.nWidth;
        Int32 nnHeight=matIn.nHeight;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        Int32 j;
        Int32 i32_max,i32_min;
        float f_max,f_min;
        double d_max,d_min;
        Int32 i32_dec;
        Int64 i64_dec;
        double d_dec;
        Int32 i32_value=(Int32)(value+0.5);
        float f_value=(float)value;
        Int32 n;
        Int32 oldj=RANDOM_MAX;

        matOut->nWidth=matIn.nWidth;
        matOut->nHeight=matIn.nHeight;
        matOut->startx=matIn.startx;
        matOut->starty=matIn.starty;
        matOut->width=matIn.width;
        matOut->height=matIn.height;
        MyconvertTo(matOut,CCV_8UC1);

        MyLinetoPoint(nnHeight,nnWidth,l32_line.st,l32_line.ed,CV_LINE_8LT,1,&conect_buffer3,u8_buffer_x1Temp3);
        for(n=0;n<conect_buffer3.AllMarkPoint[0].PointArea;n++)
        {
            Int32 stj=conect_buffer3.AllMarkPoint[0].point[n].y-lineInsize/2;
            Int32 i=conect_buffer3.AllMarkPoint[0].point[n].x;
            Int32 endj=stj+lineInsize;
            if(oldj!=i)
                oldj=i;
            else
                continue;
            if(i<nStartX||i>=nStartX+nWidth)
                continue;
            if(stj<nStartY)
            {
                stj=nStartY;
            }
            if(stj>nStartY+nHeight-1)
            {
                stj=nStartY+nHeight-1;
            }
            if(endj<nStartY)
            {
                endj=nStartY;
            }
            if(endj>nStartY+nHeight-1)
            {
                endj=nStartY+nHeight-1;
            }
            switch(matIn._type)
            {
                case CCV_8UC1:
                    i32_min=matIn.ptr_uchar[stj*nnWidth+i];
                    i32_max=matIn.ptr_uchar[stj*nnWidth+i];
                    for(j=stj;j<=endj;j++)
                    {
                        Int32 val=matIn.ptr_uchar[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        i32_dec=(255<<8)/(i32_max-i32_min);
                        for(j=stj;j<=endj;j++)
                        {
                            Int32 val=(((matIn.ptr_uchar[j*nnWidth+i]-i32_min)*i32_dec)>>8);
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                break;
                case CCV_8SC1:
                    i32_min=matIn.ptr_char[stj*nnWidth+i];
                    i32_max=matIn.ptr_char[stj*nnWidth+i];
                    for(j=stj;j<=endj;j++)
                    {
                        Int32 val=matIn.ptr_char[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        i32_dec=(255<<8)/(i32_max-i32_min);
                        for(j=stj;j<=endj;j++)
                        {
                            Int32 val=(((matIn.ptr_char[j*nnWidth+i]-i32_min)*i32_dec)>>8);
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                break;
                case CCV_16UC1:
                    i32_min=matIn.ptr_ushort[stj*nnWidth+i];
                    i32_max=matIn.ptr_ushort[stj*nnWidth+i];
                    for(j=stj;j<=endj;j++)
                    {
                        Int32 val=matIn.ptr_ushort[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        i32_dec=(255<<8)/(i32_max-i32_min);
                        for(j=stj;j<=endj;j++)
                        {
                            Int32 val=(((matIn.ptr_ushort[j*nnWidth+i]-i32_min)*i32_dec)>>16);
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                break;
                case CCV_16SC1:
                    i32_min=matIn.ptr_short[stj*nnWidth+i];
                    i32_max=matIn.ptr_short[stj*nnWidth+i];
                    for(j=stj;j<=endj;j++)
                    {
                        Int32 val=matIn.ptr_short[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        i32_dec=(255<<8)/(i32_max-i32_min);
                        for(j=stj;j<=endj;j++)
                        {
                            Int32 val=(((matIn.ptr_short[j*nnWidth+i]-i32_min)*i32_dec)>>16);
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                break;
                case CCV_32SC1:
                    i32_min=matIn.ptr_int[stj*nnWidth+i];
                    i32_max=matIn.ptr_int[stj*nnWidth+i];
                    for(j=stj;j<=endj;j++)
                    {
                        Int32 val=matIn.ptr_int[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        i64_dec=(((Uint64)255)<<32)/(i32_max-i32_min);
                        for(j=stj;j<=endj;j++)
                        {
                            Int32 val=(((matIn.ptr_int[j*nnWidth+i]-i32_min)*i64_dec)>>32);
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                break;
                case CCV_32FC1:
                    f_min=matIn.ptr_float[stj*nnWidth+i];
                    f_max=matIn.ptr_float[stj*nnWidth+i];
                    for(j=stj;j<=endj;j++)
                    {
                        float val=matIn.ptr_float[j*nnWidth+i];
                        if(f_min>val)
                        {
                            f_min=val;
                        }
                        if(f_max<val)
                        {
                            f_max=val;
                        }
                    }
                    if(f_max-f_min>=f_value)
                    {
                        d_dec=255.0/(double)(f_max-f_min);
                        for(j=stj;j<=endj;j++)
                        {
                            Int32 val=(matIn.ptr_float[j*nnWidth+i]-f_min)*d_dec+0.5;
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                break;
                case CCV_64FC1:
                    d_min=matIn.ptr_double[stj*nnWidth+i];
                    d_max=matIn.ptr_double[stj*nnWidth+i];
                    for(j=stj;j<=endj;j++)
                    {
                        double val=matIn.ptr_double[j*nnWidth+i];
                        if(d_min>val)
                        {
                            d_min=val;
                        }
                        if(d_max<val)
                        {
                            d_max=val;
                        }
                    }
                    if(d_max-d_min>=value)
                    {
                        d_dec=255.0/(double)(d_max-d_min);
                        for(j=stj;j<=endj;j++)
                        {
                            Int32 val=(matIn.ptr_double[j*nnWidth+i]-d_min)*d_dec+0.5;
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                break;
                default:
                    return 2;
                break;
            }
        }

        return 0;
    }

    Int8 Mynormalize_rowXY_downvalue(Mat matIn,Mat *matOut,double value,double downvalue)
    {
        Int32 nnWidth=matIn.nWidth;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        Int32 i,j;
        Int32 i32_max,i32_min;
        float f_max,f_min;
        double d_max,d_min;
        Int32 i32_dec;
        Int64 i64_dec;
        double d_dec;
        Int32 i32_value=(Int32)(value+0.5);
        float f_value=(float)value;
        Int32 i32_downval=(Int32)(downvalue+0.5);
        float f_downval=(float)downvalue;
        double d_downval=downvalue;

        matOut->nWidth=matIn.nWidth;
        matOut->nHeight=matIn.nHeight;
        matOut->startx=matIn.startx;
        matOut->starty=matIn.starty;
        matOut->width=matIn.width;
        matOut->height=matIn.height;
        MyconvertTo(matOut,CCV_8UC1);

        switch(matIn._type)
        {
            case CCV_8UC1:
                for(i=nStartX;i<nStartX+nWidth;i++)
                {
                    i32_min=matIn.ptr_uchar[nStartY*nnWidth+i];
                    i32_max=matIn.ptr_uchar[nStartY*nnWidth+i];
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        Int32 val=matIn.ptr_uchar[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max>i32_downval)
                    {
                        i32_max=i32_downval;
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        i32_dec=(255<<8)/(i32_max-i32_min);
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            Int32 val=(((matIn.ptr_uchar[j*nnWidth+i]-i32_min)*i32_dec)>>8);
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                }
                return 0;
            break;
            case CCV_8SC1:
                for(i=nStartX;i<nStartX+nWidth;i++)
                {
                    i32_min=matIn.ptr_char[nStartY*nnWidth+i];
                    i32_max=matIn.ptr_char[nStartY*nnWidth+i];
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        Int32 val=matIn.ptr_char[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max>i32_downval)
                    {
                        i32_max=i32_downval;
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        i32_dec=(255<<8)/(i32_max-i32_min);
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            Int32 val=(((matIn.ptr_char[j*nnWidth+i]-i32_min)*i32_dec)>>8);
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                }
                return 0;
            break;
            case CCV_16UC1:
                for(i=nStartX;i<nStartX+nWidth;i++)
                {
                    i32_min=matIn.ptr_ushort[nStartY*nnWidth+i];
                    i32_max=matIn.ptr_ushort[nStartY*nnWidth+i];
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        Int32 val=matIn.ptr_ushort[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max>i32_downval)
                    {
                        i32_max=i32_downval;
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        i32_dec=(255<<16)/(i32_max-i32_min);
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            Int32 val=(((matIn.ptr_ushort[j*nnWidth+i]-i32_min)*i32_dec)>>16);
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                }
                return 0;
            break;
            case CCV_16SC1:
                for(i=nStartX;i<nStartX+nWidth;i++)
                {
                    i32_min=matIn.ptr_short[nStartY*nnWidth+i];
                    i32_max=matIn.ptr_short[nStartY*nnWidth+i];
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        Int32 val=matIn.ptr_short[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max>i32_downval)
                    {
                        i32_max=i32_downval;
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        i32_dec=(255<<16)/(i32_max-i32_min);
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            Int32 val=(((matIn.ptr_short[j*nnWidth+i]-i32_min)*i32_dec)>>16);
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                }
                return 0;
            break;
            case CCV_32SC1:
                for(i=nStartX;i<nStartX+nWidth;i++)
                {
                    i32_min=matIn.ptr_int[nStartY*nnWidth+i];
                    i32_max=matIn.ptr_int[nStartY*nnWidth+i];
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        Int32 val=matIn.ptr_int[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max>i32_downval)
                    {
                        i32_max=i32_downval;
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        i64_dec=(((Uint64)255)<<32)/(i32_max-i32_min);
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            Int32 val=(((matIn.ptr_int[j*nnWidth+i]-i32_min)*i64_dec)>>32);
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                }
                return 0;
            break;
            case CCV_32FC1:
                for(i=nStartX;i<nStartX+nWidth;i++)
                {
                    f_min=matIn.ptr_float[nStartY*nnWidth+i];
                    f_max=matIn.ptr_float[nStartY*nnWidth+i];
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        float val=matIn.ptr_float[j*nnWidth+i];
                        if(f_min>val)
                        {
                            f_min=val;
                        }
                        if(f_max<val)
                        {
                            f_max=val;
                        }
                    }
                    if(f_max>f_downval)
                    {
                        f_max=f_downval;
                    }
                    if(f_max-f_min>=f_value)
                    {
                        d_dec=255.0/(double)(f_max-f_min);
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            Int32 val=(matIn.ptr_float[j*nnWidth+i]-f_min)*d_dec+0.5;
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                }
                return 0;
            break;
            case CCV_64FC1:
                for(i=nStartX;i<nStartX+nWidth;i++)
                {
                    d_min=matIn.ptr_double[nStartY*nnWidth+i];
                    d_max=matIn.ptr_double[nStartY*nnWidth+i];
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        double val=matIn.ptr_double[j*nnWidth+i];
                        if(d_min>val)
                        {
                            d_min=val;
                        }
                        if(d_max<val)
                        {
                            d_max=val;
                        }
                    }
                    if(d_max>d_downval)
                    {
                        d_max=d_downval;
                    }
                    if(d_max-d_min>=value)
                    {
                        d_dec=255.0/(d_max-d_min);
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            Int32 val=(matIn.ptr_double[j*nnWidth+i]-d_min)*d_dec+0.5;
                            if(val>255)
                                val=255;
                            if(val<0)
                                val=0;
                            matOut->data[j*nnWidth+i]=(Uint8)val;
                        }
                    }
                }
                return 0;
            break;
            default:
                return 2;
            break;
        }
    }

    Int8 Mynormalize_rowXY_downvalue_mask(Mat matIn,Mat *matOut,Mat mask,double value,double downvalue)
    {
        Int32 nnWidth=matIn.nWidth;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        Int32 i,j;
        Int32 i32_max,i32_min;
        float f_max,f_min;
        double d_max,d_min;
        Int32 i32_dec;
        Int64 i64_dec;
        double d_dec;
        Int32 i32_value=(Int32)(value+0.5);
        float f_value=(float)value;
        Int32 i32_downval=(Int32)(downvalue+0.5);
        float f_downval=(float)downvalue;
        double d_downval=downvalue;
        Uint8 startcheck=FALSE;

        matOut->nWidth=matIn.nWidth;
        matOut->nHeight=matIn.nHeight;
        matOut->startx=matIn.startx;
        matOut->starty=matIn.starty;
        matOut->width=matIn.width;
        matOut->height=matIn.height;
        MyconvertTo(matOut,CCV_8UC1);

        if(0!=judgeMaskSize(matIn,mask))//掩膜不匹配
            return 1;

        switch(matIn._type)
        {
            case CCV_8UC1:
                for(i=nStartX;i<nStartX+nWidth;i++)
                {
                    startcheck=FALSE;
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        if(mask.ptr_uchar[j*nnWidth+i]!=0)
                        {
                            Int32 val=matIn.ptr_uchar[j*nnWidth+i];
                            if(startcheck==FALSE)
                            {
                                i32_min=matIn.ptr_uchar[j*nnWidth+i];
                                i32_max=matIn.ptr_uchar[j*nnWidth+i];
                                startcheck=TRUE;
                            }
                            if(i32_min>val)
                            {
                                i32_min=val;
                            }
                            if(i32_max<val)
                            {
                                i32_max=val;
                            }
                        }
                    }
                    if(i32_max>i32_downval)
                    {
                        i32_max=i32_downval;
                    }
                    if(startcheck==TRUE&&i32_max-i32_min>=i32_value)
                    {
                        i32_dec=(255<<8)/(i32_max-i32_min);
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            if(mask.ptr_uchar[j*nnWidth+i]!=0)
                            {
                                Int32 val=(((matIn.ptr_uchar[j*nnWidth+i]-i32_min)*i32_dec)>>8);
                                if(val>255)
                                    val=255;
                                if(val<0)
                                    val=0;
                                matOut->data[j*nnWidth+i]=(Uint8)val;
                            }
                        }
                    }
                }
                return 0;
            break;
            case CCV_8SC1:
                for(i=nStartX;i<nStartX+nWidth;i++)
                {
                    startcheck=FALSE;
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        if(mask.ptr_uchar[j*nnWidth+i]!=0)
                        {
                            Int32 val=matIn.ptr_char[j*nnWidth+i];
                            if(startcheck==FALSE)
                            {
                                i32_min=matIn.ptr_char[j*nnWidth+i];
                                i32_max=matIn.ptr_char[j*nnWidth+i];
                                startcheck=TRUE;
                            }
                            if(i32_min>val)
                            {
                                i32_min=val;
                            }
                            if(i32_max<val)
                            {
                                i32_max=val;
                            }
                        }
                    }
                    if(i32_max>i32_downval)
                    {
                        i32_max=i32_downval;
                    }
                    if(startcheck==TRUE&&i32_max-i32_min>=i32_value)
                    {
                        i32_dec=(255<<8)/(i32_max-i32_min);
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            if(mask.ptr_uchar[j*nnWidth+i]!=0)
                            {
                                Int32 val=(((matIn.ptr_char[j*nnWidth+i]-i32_min)*i32_dec)>>8);
                                if(val>255)
                                    val=255;
                                if(val<0)
                                    val=0;
                                matOut->data[j*nnWidth+i]=(Uint8)val;
                            }
                        }
                    }
                }
                return 0;
            break;
            case CCV_16UC1:
                for(i=nStartX;i<nStartX+nWidth;i++)
                {
                    startcheck=FALSE;
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        if(mask.ptr_uchar[j*nnWidth+i]!=0)
                        {
                            Int32 val=matIn.ptr_ushort[j*nnWidth+i];
                            if(startcheck==FALSE)
                            {
                                i32_min=matIn.ptr_ushort[j*nnWidth+i];
                                i32_max=matIn.ptr_ushort[j*nnWidth+i];
                                startcheck=TRUE;
                            }
                            if(i32_min>val)
                            {
                                i32_min=val;
                            }
                            if(i32_max<val)
                            {
                                i32_max=val;
                            }
                        }
                    }
                    if(i32_max>i32_downval)
                    {
                        i32_max=i32_downval;
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        i32_dec=(255<<16)/(i32_max-i32_min);
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            if(mask.ptr_uchar[j*nnWidth+i]!=0)
                            {
                                Int32 val=(((matIn.ptr_ushort[j*nnWidth+i]-i32_min)*i32_dec)>>16);
                                if(val>255)
                                    val=255;
                                if(val<0)
                                    val=0;
                                matOut->data[j*nnWidth+i]=(Uint8)val;
                            }
                        }
                    }
                }
                return 0;
            break;
            case CCV_16SC1:
                for(i=nStartX;i<nStartX+nWidth;i++)
                {
                    startcheck=FALSE;
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        if(mask.ptr_uchar[j*nnWidth+i]!=0)
                        {
                            Int32 val=matIn.ptr_short[j*nnWidth+i];
                            if(startcheck==FALSE)
                            {
                                i32_min=matIn.ptr_short[j*nnWidth+i];
                                i32_max=matIn.ptr_short[j*nnWidth+i];
                                startcheck=TRUE;
                            }
                            if(i32_min>val)
                            {
                                i32_min=val;
                            }
                            if(i32_max<val)
                            {
                                i32_max=val;
                            }
                        }
                    }
                    if(i32_max>i32_downval)
                    {
                        i32_max=i32_downval;
                    }
                    if(startcheck==TRUE&&i32_max-i32_min>=i32_value)
                    {
                        i32_dec=(255<<16)/(i32_max-i32_min);
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            if(mask.ptr_uchar[j*nnWidth+i]!=0)
                            {
                                Int32 val=(((matIn.ptr_short[j*nnWidth+i]-i32_min)*i32_dec)>>16);
                                if(val>255)
                                    val=255;
                                if(val<0)
                                    val=0;
                                matOut->data[j*nnWidth+i]=(Uint8)val;
                            }
                        }
                    }
                }
                return 0;
            break;
            case CCV_32SC1:
                for(i=nStartX;i<nStartX+nWidth;i++)
                {
                    startcheck=FALSE;
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        if(mask.ptr_uchar[j*nnWidth+i]!=0)
                        {
                            Int32 val=matIn.ptr_int[j*nnWidth+i];
                            if(startcheck==FALSE)
                            {
                                i32_min=matIn.ptr_int[j*nnWidth+i];
                                i32_max=matIn.ptr_int[j*nnWidth+i];
                                startcheck=TRUE;
                            }
                            if(i32_min>val)
                            {
                                i32_min=val;
                            }
                            if(i32_max<val)
                            {
                                i32_max=val;
                            }
                        }
                    }
                    if(i32_max>i32_downval)
                    {
                        i32_max=i32_downval;
                    }
                    if(startcheck==TRUE&&i32_max-i32_min>=i32_value)
                    {
                        i64_dec=(((Uint64)255)<<32)/(i32_max-i32_min);
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            if(mask.ptr_uchar[j*nnWidth+i]!=0)
                            {
                                Int32 val=(((matIn.ptr_int[j*nnWidth+i]-i32_min)*i64_dec)>>32);
                                if(val>255)
                                    val=255;
                                if(val<0)
                                    val=0;
                                matOut->data[j*nnWidth+i]=(Uint8)val;
                            }
                        }
                    }
                }
                return 0;
            break;
            case CCV_32FC1:
                for(i=nStartX;i<nStartX+nWidth;i++)
                {
                    startcheck=FALSE;
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        if(mask.ptr_uchar[j*nnWidth+i]!=0)
                        {
                            float val=matIn.ptr_float[j*nnWidth+i];
                            if(startcheck==FALSE)
                            {
                                f_min=matIn.ptr_float[j*nnWidth+i];
                                f_max=matIn.ptr_float[j*nnWidth+i];
                                startcheck=TRUE;
                            }
                            if(f_min>val)
                            {
                                f_min=val;
                            }
                            if(f_max<val)
                            {
                                f_max=val;
                            }
                        }
                    }
                    if(f_max>f_downval)
                    {
                        f_max=f_downval;
                    }
                    if(startcheck==TRUE&&f_max-f_min>=f_value)
                    {
                        d_dec=255.0/(double)(f_max-f_min);
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            if(mask.ptr_uchar[j*nnWidth+i]!=0)
                            {
                                Int32 val=(matIn.ptr_float[j*nnWidth+i]-f_min)*d_dec+0.5;
                                if(val>255)
                                    val=255;
                                if(val<0)
                                    val=0;
                                matOut->data[j*nnWidth+i]=(Uint8)val;
                            }
                        }
                    }
                }
                return 0;
            break;
            case CCV_64FC1:
                for(i=nStartX;i<nStartX+nWidth;i++)
                {
                    startcheck=FALSE;
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        if(mask.ptr_uchar[j*nnWidth+i]!=0)
                        {
                            double val=matIn.ptr_double[j*nnWidth+i];
                            if(startcheck==FALSE)
                            {
                                d_min=matIn.ptr_double[j*nnWidth+i];
                                d_max=matIn.ptr_double[j*nnWidth+i];
                                startcheck=TRUE;
                            }
                            if(d_min>val)
                            {
                                d_min=val;
                            }
                            if(d_max<val)
                            {
                                d_max=val;
                            }
                        }
                    }
                    if(d_max>d_downval)
                    {
                        d_max=d_downval;
                    }
                    if(startcheck==TRUE&&d_max-d_min>=value)
                    {
                        d_dec=255.0/(d_max-d_min);
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            if(mask.ptr_uchar[j*nnWidth+i]!=0)
                            {
                                Int32 val=(matIn.ptr_double[j*nnWidth+i]-d_min)*d_dec+0.5;
                                if(val>255)
                                    val=255;
                                if(val<0)
                                    val=0;
                                matOut->data[j*nnWidth+i]=(Uint8)val;
                            }
                        }
                    }
                }
                return 0;
            break;
            default:
                return 2;
            break;
        }
    }

    Int8 Mymean(Mat matIn,Mat *matOut,Uint8 sizew,Uint8 sizeh)
    {
        Int32 i,j;
        Int32 nnHeight=matIn.nHeight;
        Int32 nnWidth=matIn.nWidth;
        Int32 nStartY=matIn.starty;
        Int32 nHeight=matIn.height;
        Int32 nStartX=matIn.startx;
        Int32 nWidth=matIn.width;
        Mat matOuttemp;
        Mat m_filter;
        L_Point32 f_center={-1,-1};

        if(sizew==1&&sizeh==1)
        {
            MatClone(matIn,matOut);
            return 0;
        }

        getcloneinfo(matIn,matOut);
        switch(matIn._type)
        {
            case CCV_8UC1:
                m_filter=MatCreat1col(sizeh,sizew,CCV_8UC1,u8_buffer_x1Temp4,1);
                matOuttemp=MatCreatzero(nnHeight,nnWidth,CCV_16UC1,u8_buffer_x1Temp5);
                Myfilter(matIn,m_filter,&matOuttemp,CCV_16UC1,0,f_center);
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        matOut->data[j*matOut->nWidth+i]=matOuttemp.ptr_ushort[j*matOuttemp.nWidth+i]/(sizew*sizeh);
                    }
                }
            break;
            default:
                return 1;
            break;
        }
    }

    Int8 Mymean_mask(Mat matIn,Mat *matOut,Mat mask,Uint8 sizew,Uint8 sizeh)
    {
        Int32 i,j,di,dj;
        Int32 nnHeight=matIn.nHeight;
        Int32 nnWidth=matIn.nWidth;
        Int32 nStartY=matIn.starty;
        Int32 nHeight=matIn.height;
        Int32 nStartX=matIn.startx;
        Int32 nWidth=matIn.width;
        Int32 nST=nStartY-sizeh/2;
        Int32 nED=nStartY+nHeight-sizeh/2;
        Int32 nST_X=nStartX-sizew/2;
        Int32 nED_X=nStartX+nWidth-sizew/2;
        Mat matIntemp,F_mask,matOuttemp,F_Outmask;
        L_Point startLoc;
        Int32 newnST,newnST_X;

        if(0!=judgeMaskSize(matIn,mask))
            return 1;

        switch(matIn._type)
        {
            case CCV_8UC1:
            break;
            default:
                return 1;
            break;
        }
        if(0!=judgeDataNotzero(mask,&startLoc))
        {
            MatClone(matIn,matOut);
            return 0;
        }
        if(sizew==1&&sizeh==1)
        {
            MatClone(matIn,matOut);
            return 0;
        }
        if(nST<0)
            nST=0;
        if(nED>nnHeight-(sizeh-1))
            nED=nnHeight-(sizeh-1);
        if(nHeight<sizeh)
            return 1;
        if(nST_X<0)
            nST_X=0;
        if(nED_X>nnWidth-(sizew-1))
            nED_X=nnWidth-(sizew-1);
        if(nWidth<sizew)
            return 1;
        getcloneinfo(matIn,matOut);

        if(sizeh==1)
        {
            if(matIn.data==matOut->data)
            {
                matIntemp=MatCreatClone(matIn,u8_buffer_x1Temp5);
            }
            else
            {
                matIntemp=matIn;
            }
            for(j=nST;j<nED;j++)
            {
                for(i=nST_X;i<nED_X;i++)
                {
                    Int32 count=0;
                    Int32 num=0;
                    if(mask.data[(j+sizeh/2)*nnWidth+i+sizew/2]==0)
                    {
                        matOut->data[(j+sizeh/2)*nnWidth+i+sizew/2]=matIntemp.data[(j+sizeh/2)*nnWidth+i+sizew/2];
                    }
                    else
                    {
                        for(dj=0;dj<sizeh;dj++)
                        {
                            for(di=0;di<sizew;di++)
                            {
                                if(mask.data[(j+dj)*nnWidth+i+di]!=0)
                                {
                                    count=matIntemp.data[(j+dj)*nnWidth+i+di]+count;
                                    num++;
                                }
                            }
                        }
                        matOut->data[(j+sizeh/2)*nnWidth+i+sizew/2]=count/num;
                    }
                }
            }
        }
        else
        {
            matIntemp=MatCreatClone(matIn,u8_buffer_x1Temp5);
            MyCutRoiSetZero(&matIntemp);
            F_mask=MatCreatzero(matIntemp.nHeight,matIntemp.nWidth,CCV_8UC1,u8_buffer_x1Temp6);
            for(j=0;j<nStartY+nHeight;j++)
            {
                memset(&F_mask.data[j*F_mask.nWidth+nStartX],1,nWidth);
            }
            i=startLoc.x;
            j=startLoc.y;
            for(;j<nStartY+nHeight;j++)
            {
                for(;i<nStartX+nWidth;i++)
                {
                    if(mask.data[j*mask.nWidth+i]==0)
                    {
                        matIntemp.data[j*matIntemp.nWidth+i]=0;
                        F_mask.data[j*F_mask.nWidth+i]=0;
                    }
                }
                i=nStartX;
            }
            matOuttemp=MatCreatzero(nnHeight,nnWidth,CCV_32SC1,u8_buffer_x1Temp1);
            matIntemp.startx=nST_X;
            matIntemp.starty=nST;
            matIntemp.width=nED_X-nST_X+sizew;
            matIntemp.height=nED-nST+sizeh;
            Myintegral(matIntemp,&matOuttemp);

            F_Outmask=MatCreatzero(nnHeight,nnWidth,CCV_32SC1,u8_buffer_x3Temp1);
            F_mask.startx=nST_X;
            F_mask.starty=nST;
            F_mask.width=nED_X-nST_X+sizew;
            F_mask.height=nED-nST+sizeh;
            Myintegral(F_mask,&F_Outmask);

            newnST=nST;
            newnST_X=nST_X;
            if(newnST<1)
            {
                newnST=1;
            }
            if(newnST_X<1)
            {
                newnST_X=1;
            }
            for(j=newnST;j<nED;j++)
            {
                for(i=newnST_X;i<nED_X;i++)
                {
                    if(F_mask.data[(j+sizeh/2)*F_mask.nWidth+i+sizew/2]==0)
                    {
                        matOut->data[(j+sizeh/2)*nnWidth+i+sizew/2]=matIn.data[(j+sizeh/2)*nnWidth+i+sizew/2];
                    }
                    else
                    {
                        Int32 countLeftTop=matOuttemp.ptr_int[(j-1)*nnWidth+(i-1)];
                        Int32 countRightTop=matOuttemp.ptr_int[(j-1)*nnWidth+(i+sizew-1)];
                        Int32 countLeftDeep=matOuttemp.ptr_int[(j+sizeh-1)*nnWidth+(i-1)];
                        Int32 countRightDeep=matOuttemp.ptr_int[(j+sizeh-1)*nnWidth+(i+sizew-1)];
                        Int32 count=countLeftTop+countRightDeep-countRightTop-countLeftDeep;
                        Int32 maskLeftTop=F_Outmask.ptr_int[(j-1)*nnWidth+(i-1)];
                        Int32 maskRightTop=F_Outmask.ptr_int[(j-1)*nnWidth+(i+sizew-1)];
                        Int32 maskLeftDeep=F_Outmask.ptr_int[(j+sizeh-1)*nnWidth+(i-1)];
                        Int32 maskRightDeep=F_Outmask.ptr_int[(j+sizeh-1)*nnWidth+(i+sizew-1)];
                        Int32 num=maskLeftTop+maskRightDeep-maskRightTop-maskLeftDeep;
                        matOut->data[(j+sizeh/2)*nnWidth+i+sizew/2]=count/num;
                    }
                }
            }
            if(nST==0)
            {
                j=nST;
                for(i=newnST_X;i<nED_X;i++)
                {
                    if(F_mask.data[(j+sizeh/2)*F_mask.nWidth+i+sizew/2]==0)
                    {
                        matOut->data[(j+sizeh/2)*nnWidth+i+sizew/2]=matIn.data[(j+sizeh/2)*nnWidth+i+sizew/2];
                    }
                    else
                    {
                        Int32 countLeftDeep=matOuttemp.ptr_int[(j+sizeh-1)*nnWidth+(i-1)];
                        Int32 countRightDeep=matOuttemp.ptr_int[(j+sizeh-1)*nnWidth+(i+sizew-1)];
                        Int32 count=countRightDeep-countLeftDeep;
                        Int32 maskLeftDeep=F_Outmask.ptr_int[(j+sizeh-1)*nnWidth+(i-1)];
                        Int32 maskRightDeep=F_Outmask.ptr_int[(j+sizeh-1)*nnWidth+(i+sizew-1)];
                        Int32 num=maskRightDeep-maskLeftDeep;
                        matOut->data[(j+sizeh/2)*nnWidth+i+sizew/2]=count/num;
                    }
                }
            }
            if(nST_X==0)
            {
                i=nST_X;
                for(j=newnST;j<nED;j++)
                {
                    if(F_mask.data[(j+sizeh/2)*F_mask.nWidth+i+sizew/2]==0)
                    {
                        matOut->data[(j+sizeh/2)*nnWidth+i+sizew/2]=matIn.data[(j+sizeh/2)*nnWidth+i+sizew/2];
                    }
                    else
                    {
                        Int32 countRightTop=matOuttemp.ptr_int[(j-1)*nnWidth+(i+sizew-1)];
                        Int32 countRightDeep=matOuttemp.ptr_int[(j+sizeh-1)*nnWidth+(i+sizew-1)];
                        Int32 count=countRightDeep-countRightTop;
                        Int32 maskRightTop=F_Outmask.ptr_int[(j-1)*nnWidth+(i+sizew-1)];
                        Int32 maskRightDeep=F_Outmask.ptr_int[(j+sizeh-1)*nnWidth+(i+sizew-1)];
                        Int32 num=maskRightDeep-maskRightTop;
                        matOut->data[(j+sizeh/2)*nnWidth+i+sizew/2]=count/num;
                    }
                }
            }
            if(nST==0&&nST_X==0)
            {
                i=nST_X;
                j=nST;
                if(F_mask.data[(j+sizeh/2)*F_mask.nWidth+i+sizew/2]==0)
                {
                    matOut->data[(j+sizeh/2)*nnWidth+i+sizew/2]=matIn.data[(j+sizeh/2)*nnWidth+i+sizew/2];
                }
                else
                {
                    matOut->data[(j+sizeh/2)*nnWidth+i+sizew/2]=matOuttemp.ptr_int[j*nnWidth+i];
                }
            }
        }
        return 0;
    }

    Int8 Mymedian(Mat matIn,Mat *matOut)
    {
        Int32 j;
        Int32 nnHeight=matIn.nHeight;
        Int32 nnWidth=matIn.nWidth;
        Int32 nStartY=matIn.starty;
        Int32 nStartX=matIn.startx;
        Int32 nHeight=matIn.height;
        Int32 nWidth=matIn.width;
        Int32 nST;
        Int32 nED;
        Int32 iST;
        Int32 iED;
        Int32 nST2;
        Int32 nED2;
        Int32 iST2;
        Int32 iED2;
        Mat matIntemp;
        cv::Mat cvimgIn,cvimgOut;
        Int32 moveX,moveY;
        Int32 moveX2,moveY2;
        Int32 mintop,minleft;
        Mat m16_dataIn=MatCreat(matIn.nHeight,matIn.nWidth,CCV_8UC1,u8_buffer_x1Temp2);

        if(nHeight<3)
            return 1;

        moveX=1;
        moveY=1;
        moveX2=3-moveX;
        moveY2=3-moveY;

        nST=nStartY-moveY;
        nED=nStartY+nHeight+moveY2;
        iST=nStartX-moveX;
        iED=nStartX+nWidth+moveX2;

        nST2=nST;
        nED2=nED;
        iST2=iST;
        iED2=iED;

        mintop=moveY;
        minleft=moveX;

        if(nST2<0)
        {
            nST2=0;
            mintop=mintop-(nST2-nST);
        }
        if(nED2>nnHeight-1)
        {
            nED2=nnHeight-1;
        }
        if(iST2<0)
        {
            iST2=0;
            minleft=minleft-(iST2-iST);
        }
        if(iED2>nnWidth-1)
        {
            iED2=nnWidth-1;
        }


        getcloneinfo(matIn,matOut);
        if(matIn.data==matOut->data)
        {
            switch(matIn._type)
            {
                case CCV_8UC1:
                break;
                default:
                    return 1;
                break;
            }
            matIntemp=MatCreatClone(matIn,u8_buffer_x1Temp1);
        }
        else
        {
            matIntemp=matIn;
        }

        MyCutminRoi(matIntemp,&m16_dataIn,MHC_CUTMIN_1,iST2,nST2,iED2-iST2+1,nED2-nST2+1);

        switch(matIntemp._type)
        {
            case CCV_8UC1:
                cvimgIn=cv::Mat(m16_dataIn.nHeight,m16_dataIn.nWidth,CV_8U);
                memcpy(cvimgIn.data,m16_dataIn.data,getsizeof(m16_dataIn._type)*m16_dataIn.nHeight*m16_dataIn.nWidth);
                cv::medianBlur(cvimgIn,cvimgOut,3);
                memcpy(m16_dataIn.data,cvimgOut.data,cvimgOut.elemSize()*cvimgOut.rows*cvimgOut.cols);
            break;
            default:
                return 1;
            break;
        }

        MyCutselfRoi(&m16_dataIn,minleft,mintop,nWidth,nHeight);

        switch(matOut->_type)
        {
            case CCV_8UC1:
                for(j=m16_dataIn.starty;j<m16_dataIn.starty+m16_dataIn.height;j++)
                {
                    memcpy(&matOut->ptr_uchar[(j-m16_dataIn.starty+nStartY)*matOut->nWidth+nStartX],&m16_dataIn.ptr_uchar[j*m16_dataIn.nWidth+m16_dataIn.startx],nWidth*getsizeof(matOut->_type));
                }
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 Mymedian2(Mat matIn,Mat *matOut,Uint32 sizew,Uint32 sizeh)
    {
        Int32 i,j,di,dj;
        Int32 nnHeight=matIn.nHeight;
        Int32 nnWidth=matIn.nWidth;
        Int32 nStartY=matIn.starty;
        Int32 nHeight=matIn.height;
        Int32 nStartX=matIn.startx;
        Int32 nWidth=matIn.width;
        Int32 nST=nStartY-sizeh/2;
        Int32 nED=nStartY+nHeight-sizeh/2;
        Int32 nST_X=nStartX-sizew/2;
        Int32 nED_X=nStartX+nWidth-sizew/2;
        Uint8 *u8_tempbuffer=(Uint8*)u8_buffer_x3Temp1;
        Mat matIntemp;

        if(sizew==1&&sizeh==1)
        {
            MatClone(matIn,matOut);
            return 0;
        }
        if(nST<0)
            nST=0;
        if(nED>nnHeight-(sizeh-1))
            nED=nnHeight-(sizeh-1);
        if(nHeight<sizeh)
            return 1;
        if(nST_X<0)
            nST_X=0;
        if(nED_X>nnWidth-(sizew-1))
            nED_X=nnWidth-(sizew-1);
        if(nWidth<sizew)
            return 1;
        getcloneinfo(matIn,matOut);
        if(matIn.data==matOut->data)
        {
            switch(matIn._type)
            {
                case CCV_8UC1:
                break;
                default:
                    return 1;
                break;
            }
            matIntemp=MatCreatClone(matIn,u8_buffer_x1Temp1);
        }
        else
        {
            matIntemp=matIn;
        }
        switch(matIntemp._type)
        {
            case CCV_8UC1:
                for(j=nST;j<nED;j++)
                {
                    for(i=nST_X;i<nED_X;i++)
                    {
                        Int32 count=0;
                        for(dj=0;dj<sizeh;dj++)
                        {
                            for(di=0;di<sizew;di++)
                            {
                                u8_tempbuffer[count++]=matIntemp.data[(j+dj)*nnWidth+i+di];
                            }
                        }
                        u8_QuickSortC(u8_tempbuffer,count);
                        matOut->data[(j+sizeh/2)*nnWidth+i+sizew/2]=u8_tempbuffer[count/2];
                    }
                }
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 Mygaussia(Mat matIn,Mat *matOut,gauss_win Mod)
    {
        cv::Mat cvimgIn,cvimgOut;
        Int32 j;
        Int32 moveX,moveY;
        Int32 moveX2,moveY2;
        Int32 mintop,minleft;
        Int32 nST;
        Int32 nED;
        Int32 iST;
        Int32 iED;
        Int32 nST2;
        Int32 nED2;
        Int32 iST2;
        Int32 iED2;
        Int32 nnHeight=matIn.nHeight;
        Int32 nnWidth=matIn.nWidth;
        Int32 nStartY=matIn.starty;
        Int32 nStartX=matIn.startx;
        Int32 nHeight=matIn.height;
        Int32 nWidth=matIn.width;
        Mat m16_dataIn=MatCreat(matIn.nHeight,matIn.nWidth,CCV_8UC1,u8_buffer_x1Temp2);
        cv::Size size;

        switch(matIn._type)
        {
            case CCV_8UC1:
                switch(Mod)
                {
                    case GAUSS_WIN_3x3:
                        moveX=1;
                        moveY=1;
                        moveX2=3-moveX;
                        moveY2=3-moveY;
                        if(nHeight<3||nWidth<3)
                            return 1;
                        size=cv::Size(3,3);
                    break;
                    case GAUSS_WIN_5x5:
                        moveX=2;
                        moveY=2;
                        moveX2=5-moveX;
                        moveY2=5-moveY;
                        if(nHeight<5|nWidth<5)
                            return 1;
                        size=cv::Size(5,5);
                    break;
                    case GAUSS_WIN_7x7:
                        moveX=3;
                        moveY=3;
                        moveX2=7-moveX;
                        moveY2=7-moveY;
                        if(nHeight<7||nWidth<7)
                            return 1;
                        size=cv::Size(7,7);
                    break;
                    default:
                        return 1;
                    break;
                }
            break;
            default:
                return 1;
            break;
        }
        nST=nStartY-moveY;
        nED=nStartY+nHeight+moveY2;
        iST=nStartX-moveX;
        iED=nStartX+nWidth+moveX2;

        nST2=nST;
        nED2=nED;
        iST2=iST;
        iED2=iED;

        mintop=moveY;
        minleft=moveX;

        if(nST2<0)
        {
            nST2=0;
            mintop=mintop-(nST2-nST);
        }
        if(nED2>nnHeight-1)
        {
            nED2=nnHeight-1;
        }
        if(iST2<0)
        {
            iST2=0;
            minleft=minleft-(iST2-iST);
        }
        if(iED2>nnWidth-1)
        {
            iED2=nnWidth-1;
        }

        getcloneinfo(matIn,matOut);

        MyCutminRoi(matIn,&m16_dataIn,MHC_CUTMIN_1,iST2,nST2,iED2-iST2+1,nED2-nST2+1);

        switch(m16_dataIn._type)
        {
            case CCV_8UC1:
                cvimgIn=cv::Mat(m16_dataIn.nHeight,m16_dataIn.nWidth,CV_8U);
                memcpy(cvimgIn.data,m16_dataIn.data,getsizeof(m16_dataIn._type)*m16_dataIn.nHeight*m16_dataIn.nWidth);
                cv::GaussianBlur(cvimgIn,cvimgOut,size,0);
                memcpy(m16_dataIn.data,cvimgOut.data,cvimgOut.elemSize()*cvimgOut.rows*cvimgOut.cols);
            break;
            default:
                return 1;
            break;
        }

        MyCutselfRoi(&m16_dataIn,minleft,mintop,nWidth,nHeight);

        switch(matOut->_type)
        {
            case CCV_8UC1:
                for(j=m16_dataIn.starty;j<m16_dataIn.starty+m16_dataIn.height;j++)
                {
                    memcpy(&matOut->ptr_uchar[(j-m16_dataIn.starty+nStartY)*matOut->nWidth+nStartX],&m16_dataIn.ptr_uchar[j*m16_dataIn.nWidth+m16_dataIn.startx],nWidth*getsizeof(matOut->_type));
                }
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 MyGabor(Mat matIn,Mat *matOut,gabor_win size,double theta,double sigma,double lambd,double gamma,double psi)
    {
        Mat gabor;
        Int32 Size;
        Uint32 nnWidth=matIn.nWidth;
        Uint32 nnHeight=matIn.nHeight;
        Int32 nStartY=matIn.starty;
        Int32 nHeight=matIn.height;
        Int32 nStartX=matIn.startx;
        Int32 nWidth=matIn.width;
        double sigma_x = sigma;
        double sigma_y = sigma/gamma;
        double scale = 1;
        double ex = -0.5/(sigma_x*sigma_x);
        double ey = -0.5/(sigma_y*sigma_y);
        double cscale = CV_PI*2/lambd;
        Int32 x,y;
        Int32 xmin, xmax, ymin, ymax;
        double c = cos(theta), s = sin(theta);
        L_Point32 center={-1,-1};
        Int16 *i16_dataIn=(Int16*)u8_buffer_x1Temp1;
        Int32 *i32_dataOut=(Int32*)u8_buffer_x1Temp2;
        Mat matInTemp;
        Mat matInTempOut;
        Int32 i,j;
        float f_tal=0;

        switch(size)
        {
            case GABOR_WIN_3x3:
                Size=3;
            break;
            case GABOR_WIN_5x5:
                Size=5;
            break;
            case GABOR_WIN_11x11:
                Size=11;
            break;
            default:
                return 1;
            break;
        }
        gabor.nWidth=Size;
        gabor.nHeight=Size;
        gabor.startx=0;
        gabor.width=Size;
        gabor.starty=0;
        gabor.height=Size;
        gabor.data=(Uint8*)i16_gabor_11x11;
        MyconvertTo(&gabor,CCV_16SC1);
        xmax=Size/2;
        ymax=Size/2;
        xmin=-xmax;
        ymin=-ymax;

        for(y = ymin; y <= ymax; y++ )
        {
            for(x = xmin; x <= xmax; x++ )
            {
                double xr = x*c + y*s;
                double yr = -x*s + y*c;
                double v = scale*exp(ex*xr*xr + ey*yr*yr)*cos(cscale*xr + psi);
                f_gabor_11x11[(ymax - y)*gabor.nWidth+(xmax - x)]=(float)v;
                f_tal=v+f_tal;
            }
        }
        My_float_to_q15(f_gabor_11x11,Size*Size,gabor.ptr_short);
        matInTempOut.data=(Uint8*)i32_dataOut;
        switch(matIn._type)
        {
        case CCV_8UC1:
            if(Size==3||Size==5)
            {
                getcloneinfo(matIn,&matInTemp);
                matInTemp.data=(Uint8*)i16_dataIn;
                MyconvertTo(&matInTemp,CCV_16SC1);
                IMG_pix_expand(nnWidth*nnHeight,matIn.data,matInTemp.ptr_short);
                Myfilter(matInTemp,gabor,&matInTempOut,CCV_32SC1,15,center);
            }
            else if(Size==11)
            {
                Myfilter(matIn,gabor,&matInTempOut,CCV_32SC1,15,center);
            }
            break;
        default:
            return 1;
        break;
        }
        if(f_tal==0||f_tal==1)
        {
            MatClone(matIn,matOut);
        }
        else
        {
            getcloneinfo(matIn,matOut);
            if(Size==11)
            {
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        Int32 i32_data=(matInTempOut.ptr_int[j*nnWidth+i]>>15)/f_tal;
                        i32_data=i32_data<0?0:i32_data;
                        i32_data=i32_data>255?255:i32_data;
                        matOut->data[j*nnWidth+i]=i32_data;
                    }
                }
            }
            else
            {
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        Int32 i32_data=matInTempOut.ptr_int[j*nnWidth+i]/f_tal;
                        i32_data=i32_data<0?0:i32_data;
                        i32_data=i32_data>255?255:i32_data;
                        matOut->data[j*nnWidth+i]=i32_data;
                    }
                }
            }
        }
        return 0;
    }

    Int8 MyImGabor(Mat matIn,Mat *matOut,gabor_win size,double theta,double sigma,double lambd,double gamma,double psi)
    {
        Mat gabor;
        Int32 Size;
        Uint32 nnWidth=matIn.nWidth;
        Uint32 nnHeight=matIn.nHeight;
        Int32 nStartY=matIn.starty;
        Int32 nHeight=matIn.height;
        Int32 nStartX=matIn.startx;
        Int32 nWidth=matIn.width;
        double sigma_x = sigma;
        double sigma_y = sigma/gamma;
        double scale = 1;
        double ex = -0.5/(sigma_x*sigma_x);
        double ey = -0.5/(sigma_y*sigma_y);
        double cscale = CV_PI*2/lambd;
        Int32 x,y;
        Int32 xmin, xmax, ymin, ymax;
        double c = cos(theta), s = sin(theta);
        L_Point32 center={-1,-1};
        Int16 *i16_dataIn=(Int16*)u8_buffer_x1Temp1;
        Int32 *i32_dataOut=(Int32*)u8_buffer_x1Temp2;
        Mat matInTemp;
        Mat matInTempOut;
        Int32 i,j;

        switch(size)
        {
            case GABOR_WIN_3x3:
                Size=3;
            break;
            case GABOR_WIN_5x5:
                Size=5;
            break;
            case GABOR_WIN_11x11:
                Size=11;
            break;
            default:
                return 1;
            break;
        }
        gabor.nWidth=Size;
        gabor.nHeight=Size;
        gabor.startx=0;
        gabor.width=Size;
        gabor.starty=0;
        gabor.height=Size;
        gabor.data=(Uint8*)i16_gabor_11x11;
        MyconvertTo(&gabor,CCV_16SC1);
        xmax=Size/2;
        ymax=Size/2;
        xmin=-xmax;
        ymin=-ymax;

        for(y = ymin; y <= ymax; y++ )
        {
            for(x = xmin; x <= xmax; x++ )
            {
                double xr = x*c + y*s;
                double yr = -x*s + y*c;
                double v = scale*exp(ex*xr*xr + ey*yr*yr)*sin(cscale*xr + psi);
                f_gabor_11x11[(ymax - y)*gabor.nWidth+(xmax - x)]=(float)v;
            }
        }
        My_float_to_q15(f_gabor_11x11,Size*Size,gabor.ptr_short);
        matInTempOut.data=(Uint8*)i32_dataOut;
        switch(matIn._type)
        {
        case CCV_8UC1:
            if(Size==3||Size==5)
            {
                getcloneinfo(matIn,&matInTemp);
                matInTemp.data=(Uint8*)i16_dataIn;
                MyconvertTo(&matInTemp,CCV_16SC1);
                IMG_pix_expand(nnWidth*nnHeight,matIn.data,matInTemp.ptr_short);
                Myfilter(matInTemp,gabor,&matInTempOut,CCV_32SC1,15,center);
            }
            else if(Size==11)
            {
                Myfilter(matIn,gabor,&matInTempOut,CCV_32SC1,15,center);
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        matOut->data[j*nnWidth+i]=(matInTempOut.ptr_int[j*nnWidth+i]>>15);
                    }
                }
            }
            break;
        default:
            return 1;
        break;
        }
        Mynormalize(matInTempOut,matOut);
        return 0;
    }

    Int8 Mysobel(Mat matIn,Mat *matOut,sobel_win Mod,Uint16 value)
    {
        Int32 nnWidth=matIn.nWidth;
        Int32 nnHeight=matIn.nHeight;
        Int32 nStartY=matIn.starty;
        Int32 nHeight=matIn.height;
        Int16 *i16_dataIn=(Int16*)u8_buffer_x1Temp1;
        Int16 *i16_dataOut=(Int16*)u8_buffer_x3Temp1;
        Uint8 *u8_dataOut=(Uint8*)u8_buffer_x3Temp1;
        Int32 height;

        getcloneinfo(matIn,matOut);
        if(value>0)
            value=value-1;
        switch(matIn._type)
        {
            case CCV_8UC1:
                switch(Mod)
                {
                    case SOB_WIN_3x3:
                        height=nHeight+2;
                        if(height+nStartY>nnHeight)
                        {
                            height=nnHeight-nStartY;
                        }
                        if(value<256)
                        {
                            IMG_sobel_3x3_8(&matIn.data[nStartY*nnWidth],(Uint8*)&u8_dataOut,nnWidth,height);
                            memset(matOut->data,0,nnWidth*nnHeight);
                            IMG_thr_le2min_8((Uint8*)&u8_dataOut,&matOut->data[nStartY*nnWidth],nnWidth,nHeight,value);
                        }
                        else
                        {
                            IMG_pix_expand(nnWidth*height,&matIn.data[nStartY*nnWidth],(Int16*)&i16_dataIn);
                            IMG_sobel_3x3_16s(i16_dataIn,i16_dataOut,nnWidth,height);
                            IMG_thr_le2min_16((Uint16*)i16_dataOut,(Uint16*)i16_dataOut,nnWidth,nHeight,value);
                            memset(matOut->data,0,nnWidth*nnHeight);
                            IMG_pix_sat(nnWidth*nHeight,i16_dataOut,&matOut->data[nStartY*nnWidth]);
                        }
                    break;
                    case SOB_WIN_5x5:
                        height=nHeight+4;
                        if(height+nStartY>nnHeight)
                        {
                            height=nnHeight-nStartY;
                        }
                        IMG_pix_expand(nnWidth*height,&matIn.data[nStartY*nnWidth],i16_dataIn);
                        IMG_sobel_5x5_16s(i16_dataIn,i16_dataOut,nnWidth,height);
                        IMG_thr_le2min_16((Uint16*)i16_dataOut,(Uint16*)i16_dataOut,nnWidth,nHeight,value);
                        memset(matOut->data,0,nnWidth*nnHeight);
                        IMG_pix_sat(nnWidth*nHeight,i16_dataOut,&matOut->data[nStartY*nnWidth]);
                    break;
                    case SOB_WIN_7x7:
                        height=nHeight+6;
                        if(height+nStartY>nnHeight)
                        {
                            height=nnHeight-nStartY;
                        }
                        IMG_pix_expand(nnWidth*height,&matIn.data[nStartY*nnWidth],i16_dataIn);
                        IMG_sobel_7x7_16s(i16_dataIn,i16_dataOut,nnWidth,height);
                        IMG_thr_le2min_16((Uint16*)i16_dataOut,(Uint16*)i16_dataOut,nnWidth,nHeight,value);
                        memset(matOut->data,0,nnWidth*nnHeight);
                        IMG_pix_sat(nnWidth*nHeight,i16_dataOut,&matOut->data[nStartY*nnWidth]);
                    break;
                    default:
                        return 1;
                    break;
                }

            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 Mycanny(Mat matIn,Mat *matOut,gauss_win Mod,Uint8 valueLow,Uint8 valueHight)
    {
        cv::Mat cvimgIn,cvimgOut;
        Int32 j;
        Int32 moveX,moveY;
        Int32 moveX2,moveY2;
        Int32 mintop,minleft;
        Int32 nST;
        Int32 nED;
        Int32 iST;
        Int32 iED;
        Int32 nST2;
        Int32 nED2;
        Int32 iST2;
        Int32 iED2;
        Int32 nnHeight=matIn.nHeight;
        Int32 nnWidth=matIn.nWidth;
        Int32 nStartY=matIn.starty;
        Int32 nStartX=matIn.startx;
        Int32 nHeight=matIn.height;
        Int32 nWidth=matIn.width;
        Mat m16_dataIn=MatCreat(matIn.nHeight,matIn.nWidth,CCV_8UC1,u8_buffer_x1Temp2);
        cv::Size size;

        switch(matIn._type)
        {
            case CCV_8UC1:
                switch(Mod)
                {
                    case GAUSS_WIN_3x3:
                        moveX=2;
                        moveY=2;
                        moveX2=5-moveX;
                        moveY2=5-moveY;
                        if(nHeight<5||nWidth<5)
                            return 1;
                        size=cv::Size(3,3);
                    break;
                    case GAUSS_WIN_5x5:
                        moveX=3;
                        moveY=3;
                        moveX2=7-moveX;
                        moveY2=7-moveY;
                        if(nHeight<7|nWidth<7)
                            return 1;
                        size=cv::Size(5,5);
                    break;
                    case GAUSS_WIN_7x7:
                        moveX=4;
                        moveY=4;
                        moveX2=9-moveX;
                        moveY2=9-moveY;
                        if(nHeight<9||nWidth<9)
                            return 1;
                        size=cv::Size(7,7);
                    break;
                    default:
                        return 1;
                    break;
                }
            break;
            default:
                return 1;
            break;
        }
        nST=nStartY-moveY;
        nED=nStartY+nHeight+moveY2;
        iST=nStartX-moveX;
        iED=nStartX+nWidth+moveX2;

        nST2=nST;
        nED2=nED;
        iST2=iST;
        iED2=iED;

        mintop=moveY;
        minleft=moveX;

        if(nST2<0)
        {
            nST2=0;
            mintop=mintop-(nST2-nST);
        }
        if(nED2>nnHeight-1)
        {
            nED2=nnHeight-1;
        }
        if(iST2<0)
        {
            iST2=0;
            minleft=minleft-(iST2-iST);
        }
        if(iED2>nnWidth-1)
        {
            iED2=nnWidth-1;
        }

        getcloneinfo(matIn,matOut);

        MyCutminRoi(matIn,&m16_dataIn,MHC_CUTMIN_1,iST2,nST2,iED2-iST2+1,nED2-nST2+1);

        switch(m16_dataIn._type)
        {
            case CCV_8UC1:
                cvimgIn=cv::Mat(m16_dataIn.nHeight,m16_dataIn.nWidth,CV_8U);
                memcpy(cvimgIn.data,m16_dataIn.data,getsizeof(m16_dataIn._type)*m16_dataIn.nHeight*m16_dataIn.nWidth);
                cv::GaussianBlur(cvimgIn,cvimgOut,size,0);
                cv::Canny(cvimgOut,cvimgOut,valueLow,valueHight);
                memcpy(m16_dataIn.data,cvimgOut.data,cvimgOut.elemSize()*cvimgOut.rows*cvimgOut.cols);
            break;
            default:
                return 1;
            break;
        }

        MyCutselfRoi(&m16_dataIn,minleft,mintop,nWidth,nHeight);

        switch(matOut->_type)
        {
            case CCV_8UC1:
                for(j=m16_dataIn.starty;j<m16_dataIn.starty+m16_dataIn.height;j++)
                {
                    memcpy(&matOut->ptr_uchar[(j-m16_dataIn.starty+nStartY)*matOut->nWidth+nStartX],&m16_dataIn.ptr_uchar[j*m16_dataIn.nWidth+m16_dataIn.startx],nWidth*getsizeof(matOut->_type));
                }
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 Myharris(Mat matIn,Mat *matOut,float paraMeter,Uint16 value)
    {
        Mat matIntemp;
        Int32 i,j;
        Int32 moveX,moveY;
        Int32 moveX2,moveY2;
        Int32 mintop,minleft;
        Int32 nST;
        Int32 nED;
        Int32 iST;
        Int32 iED;
        Int32 nST2;
        Int32 nED2;
        Int32 iST2;
        Int32 iED2;
        Int32 nnHeight=matIn.nHeight;
        Int32 nnWidth=matIn.nWidth;
        Int32 nStartY=matIn.starty;
        Int32 nStartX=matIn.startx;
        Int32 nHeight=matIn.height;
        Int32 nWidth=matIn.width;
        Mat m16_dataIn=MatCreat(matIn.nHeight,matIn.nWidth,CCV_8UC1,u8_buffer_x1Temp2);
        cv::Mat cvimgIn,cvimgOut;
        float f_value=(float)value/1024.0;

        moveX=3;
        moveY=3;
        moveX2=7-moveX;
        moveY2=7-moveY;
        if(nHeight<7|nWidth<7)
            return 1;

        nST=nStartY-moveY;
        nED=nStartY+nHeight+moveY2;
        iST=nStartX-moveX;
        iED=nStartX+nWidth+moveX2;

        nST2=nST;
        nED2=nED;
        iST2=iST;
        iED2=iED;

        mintop=moveY;
        minleft=moveX;

        if(nST2<0)
        {
            nST2=0;
            mintop=mintop-(nST2-nST);
        }
        if(nED2>nnHeight-1)
        {
            nED2=nnHeight-1;
        }
        if(iST2<0)
        {
            iST2=0;
            minleft=minleft-(iST2-iST);
        }
        if(iED2>nnWidth-1)
        {
            iED2=nnWidth-1;
        }

        getcloneinfo(matIn,matOut);

        if(matIn.data==matOut->data)
        {
            switch(matIn._type)
            {
                case CCV_8UC1:
                break;
                default:
                    return 1;
                break;
            }
            matIntemp=MatCreatClone(matIn,(Uint8*)u8_buffer_x1Temp6);
        }
        else
        {
            matIntemp=matIn;
        }
        MatSet1col(matOut,0);

        MyCutminRoi(matIntemp,&m16_dataIn,MHC_CUTMIN_1,iST2,nST2,iED2-iST2+1,nED2-nST2+1);

        switch(matIntemp._type)
        {
            case CCV_8UC1:
                cvimgIn=cv::Mat(m16_dataIn.nHeight,m16_dataIn.nWidth,CV_8U);
                memcpy(cvimgIn.data,m16_dataIn.data,getsizeof(m16_dataIn._type)*m16_dataIn.nHeight*m16_dataIn.nWidth);
                cv::cornerHarris(cvimgIn,cvimgIn,2,7,paraMeter);
                cvimgOut=cv::Mat::zeros(m16_dataIn.nHeight,m16_dataIn.nWidth,CV_8U);
                for(j=0;j<cvimgIn.rows;j++)
                {
                    float *f32=cvimgIn.ptr<float>(j);
                    Uint8 *u8=cvimgOut.ptr<Uint8>(j);
                    for(i=0;i<cvimgIn.cols;i++)
                    {
                        if(f32[i]>f_value)
                        {
                            u8[i]=255;
                        }
                    }
                }
                memcpy(m16_dataIn.data,cvimgOut.data,cvimgOut.elemSize()*cvimgOut.rows*cvimgOut.cols);
            break;
            default:
                return 1;
            break;
        }

        MyCutselfRoi(&m16_dataIn,minleft,mintop,nWidth,nHeight);

        switch(matOut->_type)
        {
            case CCV_8UC1:
                for(j=m16_dataIn.starty;j<m16_dataIn.starty+m16_dataIn.height;j++)
                {
                    memcpy(&matOut->ptr_uchar[(j-m16_dataIn.starty+nStartY)*matOut->nWidth+nStartX],&m16_dataIn.ptr_uchar[j*m16_dataIn.nWidth+m16_dataIn.startx],nWidth*getsizeof(matOut->_type));
                }
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 Myskeleton_cn(Mat matIn,Mat *matOut,skeleton_cn Mod)
    {
        Int32 nnWidth=matIn.nWidth;
        Int32 nnHeight=matIn.nHeight;
        Int32 nStartY=matIn.starty;
        Int32 nHeight=matIn.height;
        Int32 nStartX=matIn.startx;
        Int32 nWidth=matIn.width;
        Int32 nSTY=nStartY;
        Int32 nEDY=nStartY+nHeight;
        Int32 nSTX=nStartX;
        Int32 nEDX=nStartX+nWidth;
        Int32 p1,p2,p3,p4,p5,p6,p7,p8,p9;
        Uint8 *img;
        Uint8 ifEnd;
        Int32 step=nnWidth;
        Int32 n,i,j;
        Int32 dir[4];
        Mat tmpimg;
        Int32 offset[9][2]={{0,0},{1,0},{1,-1},{0,-1},{-1,-1},{-1,0},{-1,1},{0,1},{1,1}};
        Int32 n_odd[4] = { 1, 3, 5, 7 };
        Int32 px, py;
        Int32 b[9];
        Int32 condition[6];
        Int32 counter;
        Int32 x, y, copy, sum;
        Uint8 GRAY=128;
        Uint8 WHITE=255;
        Uint8 BLACK=0;
        Int32 A1;

        dir[0]=-step;
        dir[1]=step;
        dir[2]=-1;
        dir[3]=1;

        switch(matIn._type)
        {
            case CCV_8UC1:
            break;
            default:
                return 1;
            break;
        }

        MatClone(matIn,matOut);

        if(nSTY<1)
        {
            nSTY=1;
        }
        if(nEDY>=nnHeight)
        {
            nEDY=nnHeight-1;
        }
        if(nSTX<1)
        {
            nSTX=1;
        }
        if(nEDX>=nnWidth)
        {
            nEDX=nnWidth-1;
        }

        switch(Mod)
        {
            case SKELETON_CN_ROSENFELD:
                while(1)
                {
                     ifEnd=FALSE;
                     for(n=0;n<4;n++)
                     {
                         tmpimg=MatCreatClone(*matOut,(Uint8*)u8_buffer_x3Temp1);
                         img=tmpimg.data;
                         for(i=nSTY;i<nEDY;i++)
                         {
                             for(j=nSTX;j<nEDX;j++)
                             {
                                 Uint8 *p=img+i*step+j;
                                 Int32 is8simple=1;
                                 Int32 adjsum;

                                 if(p[0]==0||p[dir[n]]!=0)
                                     continue;
                                 p1=p[-step]>0?1:0;
                                 p2=p[-step+1]>0?1:0;
                                 p3=p[1]>0?1:0;
                                 p4=p[step+1]>0?1:0;
                                 p5=p[step]>0?1:0;
                                 p6=p[step-1]>0?1:0;
                                 p7=p[-1]>0?1:0;
                                 p8=p[-step-1]>0?1:0;

                                 if(p1==0&&p5==0&&(p8==1||p7==1||p6==1)&&(p2==1||p3==1||p4==1))
                                 {
                                     is8simple=0;
                                 }
                                 if(p3==0&&p7==0&&(p8==1||p1==1||p2==1)&&(p4==1||p5==1||p6==1))
                                 {
                                     is8simple = 0;
                                 }
                                 if(p7==0&&p1==0&&p8==1&&(p2==1||p3==1||p4==1||p5==1||p6 == 1))
                                 {
                                     is8simple = 0;
                                 }
                                 if(p3==0&&p1==0&&p2==1&&(p4==1||p5==1||p6==1||p7==1||p8==1))
                                 {
                                     is8simple = 0;
                                 }
                                 if(p7==0&&p5==0&&p6==1&&(p2==9||p1==1||p2==1||p3==1||p4==1))
                                 {
                                     is8simple = 0;
                                 }
                                 if(p3==0&&p5==0&&p4==1&&(p6==1||p7==1||p8==1||p1==1||p2==1))
                                 {
                                     is8simple = 0;
                                 }
                                 adjsum=p1+p2+p3+p4+p5+p6+p7+p8;
                                 if(adjsum!=1&&adjsum!=0&&is8simple==1)
                                 {
                                     matOut->ptr_uchar[i*nnWidth+j]=0;
                                     ifEnd=TRUE;
                                 }
                             }
                         }
                     }
                     if(!ifEnd)
                         break;
                }
            break;
            case SKELETON_CN_HILDITCH_1:
                Mybinaryself(matOut,MHC_BARINY_VALUE,255,1,0);
                img=matOut->data;
                do
                {
                    counter=0;
                    for (y=nSTY;y<nEDY;y++)
                    {
                        for (x=nSTX;x<nEDX;x++)
                        {
                            for (i=0;i<9;i++)
                            {
                                b[i]=0;
                                px=x+offset[i][0];
                                py=y+offset[i][1];
                                if(img[py*step+px]==WHITE)
                                {
                                    b[i]=1;
                                }
                                else if(img[py*step+px]==GRAY)
                                {
                                    b[i]=-1;
                                }
                            }
                            for(i=0;i<6;i++)
                            {
                                condition[i]=0;
                            }
                            if(b[0]==1)
                                condition[0]=1;
                            sum=0;
                            for(i=0;i<4;i++)
                            {
                                sum=sum+1-abs(b[n_odd[i]]);
                            }
                            if(sum>=1)
                                condition[1]=1;
                            sum=0;
                            for(i=1;i<=8;i++)
                            {
                                sum=sum+abs(b[i]);
                            }
                            if(sum>=2)
                                condition[2]=1;
                            sum=0;
                            for(i=1;i<=8;i++)
                            {
                                if(b[i]==1)
                                    sum++;
                            }
                            if(sum>=1)
                                condition[3]=1;
                            if(func_nc8(b)==1)
                                condition[4]=1;
                            sum=0;
                            for(i=1;i<=8;i++)
                            {
                                if(b[i]!=-1)
                                {
                                    sum++;
                                }
                                else
                                {
                                    copy=b[i];
                                    b[i]=0;
                                    if(func_nc8(b)==1)
                                        sum++;
                                    b[i]=copy;
                                }
                            }
                            if(sum==8)
                                condition[5]=1;

                            if(condition[0]&&condition[1]&&condition[2]&&condition[3]&&condition[4]&&condition[5])
                            {
                                img[y*step+x]=GRAY;
                                counter++;
                            }
                        }
                    }
                    if (counter != 0)
                    {
                        for (y=nSTY;y<nEDY;y++)
                        {
                            for (x=nSTX;x<nEDX;x++)
                            {
                                if(img[y*step+x]==GRAY)
                                    img[y*step+x]=BLACK;
                            }
                        }
                    }
                }while(counter!=0);
            break;
            case SKELETON_CN_HILDITCH_2:
                if(nSTY<2)
                {
                    nSTY=2;
                }
                if(nEDY>=nnHeight-1)
                {
                    nEDY=nnHeight-2;
                }
                if(nSTX<2)
                {
                    nSTX=2;
                }
                if(nEDX>=nnWidth-1)
                {
                    nEDX=nnWidth-2;
                }
                while(1)
                {
                    tmpimg=MatCreatClone(*matOut,(Uint8*)u8_buffer_x3Temp1);
                    ifEnd=FALSE;
                    img=tmpimg.data+step;
                    for(i=nSTY;i<nEDY;i++)
                    {
                        img+=step;
                        for(j=nSTX;j<nEDX;j++)
                        {
                            Uint8*p=img+j;
                            A1=0;
                            if(p[0]>0)
                            {
                                Int32 A2,A4;
                                if(p[-step]==0&&p[-step+1]>0)
                                {
                                    A1++;
                                }
                                if(p[-step+1]==0&&p[1]>0)
                                {
                                    A1++;
                                }
                                if(p[1]==0&&p[step+1]>0)
                                {
                                    A1++;
                                }
                                if(p[step+1]==0&&p[step]>0)
                                {
                                    A1++;
                                }
                                if(p[step]==0&&p[step-1]>0)
                                {
                                    A1++;
                                }
                                if(p[step-1]==0&&p[-1]>0)
                                {
                                    A1++;
                                }
                                if(p[-1]==0&&p[-step-1]>0)
                                {
                                    A1++;
                                }
                                if(p[-step-1]==0&&p[-step]>0)
                                {
                                    A1++;
                                }
                                p2 = p[-step]>0?1:0;
                                p3 = p[-step+1]>0?1:0;
                                p4 = p[1]>0?1:0;
                                p5 = p[step+1]>0?1:0;
                                p6 = p[step]>0?1:0;
                                p7 = p[step-1]>0?1:0;
                                p8 = p[-1]>0?1:0;
                                p9 = p[-step-1]>0?1:0;
                                A2 = 0;
                                {
                                    if(p[-2*step]==0&&p[-2*step+1]>0)
                                        A2++;
                                    if(p[-2*step+1]==0&&p[-step+1]>0)
                                        A2++;
                                    if(p[-step+1]==0&&p[1]>0)
                                        A2++;
                                    if(p[1]==0&&p[0]>0)
                                        A2++;
                                    if(p[0]==0&&p[-1]>0)
                                        A2++;
                                    if(p[-1]==0&&p[-step-1]>0)
                                        A2++;
                                    if(p[-step-1]==0&&p[-2*step-1]>0)
                                        A2++;
                                    if(p[-2*step-1]==0&&p[-2*step]>0)
                                        A2++;
                                }
                                A4 = 0;
                                {
                                    if(p[-step+1]==0&&p[-step+2]>0)
                                        A4++;
                                    if(p[-step+2]==0&&p[2]>0)
                                        A4++;
                                    if(p[2]==0&&p[step+2]>0)
                                        A4++;
                                    if(p[step+2]==0&&p[step+1]>0)
                                        A4++;
                                    if(p[step+1]==0&&p[step]>0)
                                        A4++;
                                    if(p[step]==0&&p[0]>0)
                                        A4++;
                                    if(p[0]==0&&p[-step]>0)
                                        A4++;
                                    if(p[-step]==0&&p[-step+1]>0)
                                        A4++;
                                }
                                if((p2+p3+p4+p5+p6+p7+p8+p9)>1&&(p2+p3+p4+p5+p6+p7+p8+p9)<7&&A1==1)
                                {
                                    if(((p2==0||p4==0||p8==0)||A2!=1)&&((p2==0||p4==0||p6==0)||A4!=1))
                                    {
                                        matOut->ptr_uchar[i*nnWidth+j]=0;
                                        ifEnd=TRUE;
                                    }
                                }
                            }
                        }
                    }
                    if(!ifEnd)
                        break;
                }
            break;
            #if USE_XIMGPROC == 1
            case SKELETON_CN_ZHANGSUNEN:
            {
                Mat m16_dataIn=MatCreat(matIn.nHeight,matIn.nWidth,CCV_8UC1,u8_buffer_x3Temp1);
                cv::Mat cvimgIn,cvimgOut;
                MyCutminRoi(matIn,&m16_dataIn,MHC_CUTMIN_1,matIn.startx,matIn.starty,matIn.width,matIn.height);

                switch(m16_dataIn._type)
                {
                    case CCV_8UC1:
                        cvimgIn=cv::Mat(m16_dataIn.nHeight,m16_dataIn.nWidth,CV_8U);
                        memcpy(cvimgIn.data,m16_dataIn.data,getsizeof(m16_dataIn._type)*m16_dataIn.nHeight*m16_dataIn.nWidth);
                        cv::ximgproc::thinning(cvimgIn,cvimgOut,cv::ximgproc::THINNING_ZHANGSUEN);
                        memcpy(m16_dataIn.data,cvimgOut.data,cvimgOut.elemSize()*cvimgOut.rows*cvimgOut.cols);
                        MyAddminRoi(*matOut,m16_dataIn,matOut,matIn.startx,matIn.starty);
                    break;
                    default:
                        return 1;
                    break;
                }
            }
            break;
            case SKELETON_CN_GUOHALL:
            {
                Mat m16_dataIn=MatCreat(matIn.nHeight,matIn.nWidth,CCV_8UC1,u8_buffer_x3Temp1);
                cv::Mat cvimgIn,cvimgOut;
                MyCutminRoi(matIn,&m16_dataIn,MHC_CUTMIN_1,matIn.startx,matIn.starty,matIn.width,matIn.height);

                switch(m16_dataIn._type)
                {
                    case CCV_8UC1:
                        cvimgIn=cv::Mat(m16_dataIn.nHeight,m16_dataIn.nWidth,CV_8U);
                        memcpy(cvimgIn.data,m16_dataIn.data,getsizeof(m16_dataIn._type)*m16_dataIn.nHeight*m16_dataIn.nWidth);
                        cv::ximgproc::thinning(cvimgIn,cvimgOut,cv::ximgproc::THINNING_GUOHALL);
                        memcpy(m16_dataIn.data,cvimgOut.data,cvimgOut.elemSize()*cvimgOut.rows*cvimgOut.cols);
                        MyAddminRoi(*matOut,m16_dataIn,matOut,matIn.startx,matIn.starty);
                    break;
                    default:
                        return 1;
                    break;
                }
            }
            #endif
            break;
            default:
                return 1;
            break;
        }

        return 0;
    }

    Int8 Myrescale(Mat matIn,Mat *matOut,float paraMeter)
    {
        Int32 nStartY=matIn.starty;
        Int32 nHeight=matIn.height;
        Int32 nStartX=matIn.startx;
        Int32 nWidth=matIn.width;
        Mat matIntemp;
        cv::Mat cvimgIn,cvimgOut;

        nStartY=nStartY*paraMeter+0.5;
        nStartX=nStartX*paraMeter+0.5;
        nHeight=nHeight*paraMeter+0.5;
        nWidth=nWidth*paraMeter+0.5;

        getcloneinfo(matIn,matOut);
        if(matIn.data==matOut->data)
        {
            switch(matIn._type)
            {
                case CCV_8UC1:
                break;
                default:
                    return 1;
                break;
            }
            matIntemp=MatCreatClone(matIn,(Uint8*)u8_buffer_x3Temp1);
        }
        else
        {
            matIntemp=matIn;
        }

        matOut->startx=nStartX;
        matOut->starty=nStartY;
        matOut->width=nWidth;
        matOut->height=nHeight;

        switch(matIn._type)
        {
            case CCV_8UC1:
                cvimgIn=cv::Mat(matIntemp.nHeight,matIntemp.nWidth,CV_8U);
                memcpy(cvimgIn.data,matIntemp.data,getsizeof(matIntemp._type)*matIntemp.nHeight*matIntemp.nWidth);
                cv::resize(cvimgIn,cvimgOut,cv::Size(0,0),paraMeter,paraMeter);
                memcpy(matOut->data,cvimgOut.data,cvimgOut.elemSize()*cvimgOut.rows*cvimgOut.cols);
            break;
            default:
                return 1;
            break;
        }
        matOut->nHeight=cvimgOut.rows;
        matOut->nWidth=cvimgOut.cols;
        if(matOut->startx+matOut->width>matOut->nWidth)
        {
            matOut->width=matOut->nWidth-matOut->startx;
        }
        if(matOut->starty+matOut->height>matOut->nHeight)
        {
            matOut->height=matOut->nHeight-matOut->starty;
        }

        return 0;
    }

    Int8 MyMat2Contours(Mat matIn,Mat *matOut)
    {
        Int32 j;
        Int32 nnHeight=matIn.nHeight;
        Int32 nnWidth=matIn.nWidth;
        Int32 nStartY=matIn.starty;
        Int32 nHeight=matIn.height;
        Int32 nST=(Int32)nStartY-1;
        Int32 nED=nStartY+nHeight-1;
        Mat matIntemp;

        if(nST<1)
            nST=1;
        if(nED>nnHeight-2)
            nED=nnHeight-2;

        getcloneinfo(matIn,matOut);
        if(matIn.data==matOut->data)
        {
            switch(matIn._type)
            {
                case CCV_8UC1:
                break;
                default:
                    return 1;
                break;
            }
            matIntemp=MatCreatClone(matIn,(Uint8*)u8_buffer_x1Temp6);
        }
        else
        {
            matIntemp=matIn;
        }
        switch(matIntemp._type)
        {
            case CCV_8UC1:
            for(j=nST;j<nED;j++)
            {
                IMG_perimeter_8(&matIntemp.data[j*nnWidth],nnWidth,&matOut->data[(j+1)*nnWidth]);
            }
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 Myintersection(Mat matIn1,Mat matIn2,Mat *matOut)
    {
        Uint32 nnHeight=matIn1.nHeight;
        Uint32 nnWidth=matIn1.nWidth;
        if(matIn1._type!=matIn2._type||matIn1.nHeight!=matIn2.nHeight||matIn1.nWidth!=matIn2.nWidth)
            return 1;
        getcloneinfo(matIn1,matOut);
        switch(matIn1._type)
        {
            case CCV_8UC1:
                IMG_and_8(matIn1.ptr_uchar,matIn2.ptr_uchar,(Int8*)(matOut->ptr_uchar),nnHeight*nnWidth);
            break;
            case CCV_16UC1:
                IMG_and_16(matIn1.ptr_ushort,matIn2.ptr_ushort,(Int16*)(matOut->ptr_ushort),nnHeight*nnWidth);
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 Myunion2(Mat matIn1,Mat matIn2,Mat *matOut)
    {
        Uint32 nnHeight=matIn1.nHeight;
        Uint32 nnWidth=matIn1.nWidth;
        if(matIn1._type!=matIn2._type||matIn1.nHeight!=matIn2.nHeight||matIn1.nWidth!=matIn2.nWidth)
            return 1;
        getcloneinfo(matIn1,matOut);
        switch(matIn1._type)
        {
            case CCV_8UC1:
                IMG_or_8(matIn1.ptr_uchar,matIn2.ptr_uchar,(Int8*)(matOut->ptr_uchar),nnHeight*nnWidth);
            break;
            case CCV_16UC1:
                IMG_or_16(matIn1.ptr_ushort,matIn2.ptr_ushort,(Int16*)(matOut->ptr_ushort),nnHeight*nnWidth);
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 Myinvert_image(Mat matIn,Mat *matOut)
    {
        Uint32 nnWidth=matIn.nWidth;
        Int32 nStartY=matIn.starty;
        Int32 nHeight=matIn.height;
        Int32 nStartX=matIn.startx;
        Int32 nWidth=matIn.width;
        Int32 i,j;

        getcloneinfo(matIn,matOut);
        switch(matIn._type)
        {
            case CCV_8UC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(matIn.ptr_uchar[j*nnWidth+i]!=0)
                        {
                            matOut->ptr_uchar[j*nnWidth+i]=0;
                        }
                        else
                        {
                            matOut->ptr_uchar[j*nnWidth+i]=0xff;
                        }
                    }
                }
            break;
            case CCV_16UC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(matIn.ptr_ushort[j*nnWidth+i]!=0)
                        {
                            matOut->ptr_ushort[j*nnWidth+i]=0;
                        }
                        else
                        {
                            matOut->ptr_ushort[j*nnWidth+i]=0xffff;
                        }
                    }
                }
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 Myadd_image(Mat matIn1,Mat matIn2,Mat *matOut)
    {
        Uint32 nnHeight=matIn1.nHeight;
        Uint32 nnWidth=matIn1.nWidth;
        if(matIn1._type!=matIn2._type||matIn1.nHeight!=matIn2.nHeight||matIn1.nWidth!=matIn2.nWidth)
            return 1;
        getcloneinfo(matIn1,matOut);
        switch(matIn1._type)
        {
            case CCV_8UC1:
                IMG_add_8((Int8*)matIn1.ptr_uchar,(Int8*)matIn2.ptr_uchar,(Int8*)(matOut->ptr_uchar),nnHeight*nnWidth);
            break;
            case CCV_16UC1:
                IMG_add_16s((Int16*)matIn1.ptr_ushort,(Int16*)matIn2.ptr_ushort,(Int16*)(matOut->ptr_ushort),nnHeight*nnWidth);
            break;
            case CCV_8SC1:
                IMG_add_8(matIn1.ptr_char,matIn2.ptr_char,matOut->ptr_char,nnHeight*nnWidth);
            break;
            case CCV_16SC1:
                IMG_add_16s(matIn1.ptr_short,matIn2.ptr_short,matOut->ptr_short,nnHeight*nnWidth);
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 Mysub_image(Mat matIn1,Mat matIn2,Mat *matOut)
    {
        Uint32 nnHeight=matIn1.nHeight;
        Uint32 nnWidth=matIn1.nWidth;
        if(matIn1._type!=matIn2._type||matIn1.nHeight!=matIn2.nHeight||matIn1.nWidth!=matIn2.nWidth)
            return 1;
        getcloneinfo(matIn1,matOut);
        switch(matIn1._type)
        {
            case CCV_8UC1:
                IMG_sub_8((Int8*)matIn1.ptr_uchar,(Int8*)matIn2.ptr_uchar,(Int8*)(matOut->ptr_uchar),nnHeight*nnWidth);
            break;
            case CCV_16UC1:
                IMG_sub_16s((Int16*)matIn1.ptr_ushort,(Int16*)matIn2.ptr_ushort,(Int16*)(matOut->ptr_ushort),nnHeight*nnWidth);
            break;
            case CCV_8SC1:
                IMG_sub_8(matIn1.ptr_char,matIn2.ptr_char,matOut->ptr_char,nnHeight*nnWidth);
            break;
            case CCV_16SC1:
                IMG_sub_16s(matIn1.ptr_short,matIn2.ptr_short,matOut->ptr_short,nnHeight*nnWidth);
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 Mymul_image(Mat matIn1,Mat matIn2,Mat *matOut)
    {
        Uint32 nnHeight=matIn1.nHeight;
        Uint32 nnWidth=matIn1.nWidth;
        if(matIn1._type!=matIn2._type||matIn1.nHeight!=matIn2.nHeight||matIn1.nWidth!=matIn2.nWidth)
            return 1;
        matOut->nWidth=matIn1.nWidth;
        matOut->nHeight=matIn1.nHeight;
        matOut->startx=matIn1.startx;
        matOut->starty=matIn1.starty;
        matOut->width=matIn1.width;
        matOut->height=matIn1.height;

        switch(matIn1._type)
        {
            case CCV_8UC1:
                MyconvertTo(matOut,CCV_16SC1);
                IMG_mul_8((Int8*)matIn1.ptr_uchar,(Int8*)matIn2.ptr_uchar,matOut->ptr_short,nnHeight*nnWidth);
            break;
            case CCV_16UC1:
                MyconvertTo(matOut,CCV_32SC1);
                IMG_mul_16s((Int16*)matIn1.ptr_ushort,(Int16*)matIn2.ptr_ushort,matOut->ptr_int,nnHeight*nnWidth);
            break;
            case CCV_8SC1:
                MyconvertTo(matOut,CCV_16SC1);
                IMG_mul_8(matIn1.ptr_char,matIn2.ptr_char,matOut->ptr_short,nnHeight*nnWidth);
            break;
            case CCV_16SC1:
                MyconvertTo(matOut,CCV_32SC1);
                IMG_mul_16s(matIn1.ptr_short,matIn2.ptr_short,matOut->ptr_int,nnHeight*nnWidth);
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 Myinvert_value(Mat matIn,Mat *matOut)
    {
        Uint32 nnHeight=matIn.nHeight;
        Uint32 nnWidth=matIn.nWidth;

        getcloneinfo(matIn,matOut);
        switch(matIn._type)
        {
            case CCV_8UC1:
                IMG_invS_8((Int8*)matIn.ptr_uchar,(Int8*)matOut->ptr_uchar,nnHeight*nnWidth);
            break;
            case CCV_16UC1:
                IMG_invS_16s((Int16*)matIn.ptr_ushort,(Int16*)matOut->ptr_ushort,nnHeight*nnWidth);
            break;
            case CCV_8SC1:
                IMG_invS_8(matIn.ptr_char,matOut->ptr_char,nnHeight*nnWidth);
            break;
            case CCV_16SC1:
                IMG_invS_16s(matIn.ptr_short,matOut->ptr_short,nnHeight*nnWidth);
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 Myadd_value(Mat matIn,Mat *matOut,Int32 value)
    {
        Uint32 nnHeight=matIn.nHeight;
        Uint32 nnWidth=matIn.nWidth;
        getcloneinfo(matIn,matOut);
        switch(matIn._type)
        {
            case CCV_8UC1:
                IMG_addS_8((Int8*)matIn.ptr_uchar,(Int8*)matOut->ptr_uchar,(Int8)value,nnHeight*nnWidth);
            break;
            case CCV_16UC1:
                IMG_addS_16s((Int16*)matIn.ptr_ushort,(Int16*)matOut->ptr_ushort,(Int16)value,nnHeight*nnWidth);
            break;
            case CCV_8SC1:
                IMG_addS_8(matIn.ptr_char,matOut->ptr_char,(Int8)value,nnHeight*nnWidth);
            break;
            case CCV_16SC1:
                IMG_addS_16s(matIn.ptr_short,matOut->ptr_short,(Int16)value,nnHeight*nnWidth);
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 Mysub_value(Mat matIn,Mat *matOut,Int32 value)
    {
        Uint32 nnHeight=matIn.nHeight;
        Uint32 nnWidth=matIn.nWidth;
        getcloneinfo(matIn,matOut);
        switch(matIn._type)
        {
            case CCV_8UC1:
                IMG_subS_8((Int8*)matIn.ptr_uchar,(Int8*)matOut->ptr_uchar,(Int8)value,nnHeight*nnWidth);
            break;
            case CCV_16UC1:
                IMG_subS_16s((Int16*)matIn.ptr_ushort,(Int16*)matOut->ptr_ushort,(Int16)value,nnHeight*nnWidth);
            break;
            case CCV_8SC1:
                IMG_subS_8(matIn.ptr_char,matOut->ptr_char,(Int8)value,nnHeight*nnWidth);
            break;
            case CCV_16SC1:
                IMG_subS_16s(matIn.ptr_short,matOut->ptr_short,(Int16)value,nnHeight*nnWidth);
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 Mymul_value(Mat matIn,Mat *matOut,Int32 value)
    {
        Uint32 nnHeight=matIn.nHeight;
        Uint32 nnWidth=matIn.nWidth;

        matOut->nWidth=matIn.nWidth;
        matOut->nHeight=matIn.nHeight;
        matOut->startx=matIn.startx;
        matOut->starty=matIn.starty;
        matOut->width=matIn.width;
        matOut->height=matIn.height;

        switch(matIn._type)
        {
            case CCV_8UC1:
                MyconvertTo(matOut,CCV_16SC1);
                IMG_mulS_8(matIn.ptr_uchar,matOut->ptr_short,(Int8)value,nnHeight*nnWidth);
            break;
            case CCV_16UC1:
                MyconvertTo(matOut,CCV_32SC1);
                IMG_mulS_16s((Int16*)matIn.ptr_ushort,matOut->ptr_int,(Int16)value,nnHeight*nnWidth);
            break;
            case CCV_8SC1:
                MyconvertTo(matOut,CCV_16SC1);
                IMG_mulS_8((Uint8*)matIn.ptr_char,matOut->ptr_short,(Int8)value,nnHeight*nnWidth);
            break;
            case CCV_16SC1:
                MyconvertTo(matOut,CCV_32SC1);
                IMG_mulS_16s(matIn.ptr_short,matOut->ptr_int,(Int16)value,nnHeight*nnWidth);
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 Myabs_value(Mat matIn,Mat *matOut)
    {
        Int32 nnWidth=matIn.nWidth;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        Int32 i,j;

        switch(matIn._type)
        {
            case CCV_8UC1:
                MatClone(matIn,matOut);
            break;
            case CCV_16UC1:
                MatClone(matIn,matOut);
            break;
            case CCV_8SC1:
                getcloneinfo(matIn,matOut);
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        matOut->ptr_char[j*nnWidth+i]=abs(matIn.ptr_char[j*nnWidth+i]);
                    }
                }
            break;
            case CCV_16SC1:
                getcloneinfo(matIn,matOut);
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        matOut->ptr_short[j*nnWidth+i]=abs(matIn.ptr_short[j*nnWidth+i]);
                    }
                }
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 Mypyramid(Mat matIn,Mat *matOut1,Mat *matOut2,Mat *matOut3)
    {
        Int32 nStartY=matIn.starty;
        Int32 nHeight=matIn.height;
        Int32 nStartX=matIn.startx;
        Int32 nWidth=matIn.width;
        void *buffer1=matOut1->data;
        void *buffer2=matOut2->data;
        void *buffer3=matOut3->data;

        cv::Mat cvimgIn,cvimgOut1,cvimgOut2,cvimgOut3;
        MatToCvMat(matIn,&cvimgIn);
        cv::resize(cvimgIn,cvimgOut1,cv::Size(0,0),0.5,0.5);
        cv::resize(cvimgOut1,cvimgOut2,cv::Size(0,0),0.5,0.5);
        cv::resize(cvimgOut2,cvimgOut3,cv::Size(0,0),0.5,0.5);
        CvMatToMat(cvimgOut1,matOut1,buffer1);
        CvMatToMat(cvimgOut2,matOut2,buffer2);
        CvMatToMat(cvimgOut3,matOut3,buffer3);

        matOut1->startx=(nStartX>>1);
        matOut1->starty=(nStartY>>1);
        matOut1->width=(nWidth>>1);
        matOut1->height=(nHeight>>1);

        matOut2->startx=(nStartX>>2);
        matOut2->starty=(nStartY>>2);
        matOut2->width=(nWidth>>2);
        matOut2->height=(nHeight>>2);

        matOut3->startx=(nStartX>>3);
        matOut3->starty=(nStartY>>3);
        matOut3->width=(nWidth>>3);
        matOut3->height=(nHeight>>3);

        return 0;
    }

    Int8 Mygausspyramid(Mat matIn,Mat *matOut)
    {
        Int32 nStartY=matIn.starty;
        Int32 nHeight=matIn.height;
        Int32 nStartX=matIn.startx;
        Int32 nWidth=matIn.width;
        cv::Mat cvimgIn,cvimgOut;
        void *buffer=matOut->data;

        MatToCvMat(matIn,&cvimgIn);
        cv::pyrDown(cvimgIn,cvimgOut);
        CvMatToMat(cvimgOut,matOut,buffer);

        matOut->startx=(nStartX>>1);
        matOut->starty=(nStartY>>1);
        matOut->width=(nWidth>>1);
        matOut->height=(nHeight>>1);

        return 0;
    }

    Int8 Mygausspyramid_2levl(Mat matIn,Mat *matOut)
    {
        Int32 nStartY=matIn.starty;
        Int32 nHeight=matIn.height;
        Int32 nStartX=matIn.startx;
        Int32 nWidth=matIn.width;
        cv::Mat cvimgIn,cvimgOut;
        void *buffer=matOut->data;

        MatToCvMat(matIn,&cvimgIn);
        cv::pyrDown(cvimgIn,cvimgOut);
        cv::pyrDown(cvimgOut,cvimgOut);
        CvMatToMat(cvimgOut,matOut,buffer);

        matOut->startx=(nStartX>>2);
        matOut->starty=(nStartY>>2);
        matOut->width=(nWidth>>2);
        matOut->height=(nHeight>>2);

        return 0;
    }

    Int8 Mygausspyramid_3levl(Mat matIn,Mat *matOut)
    {
        Int32 nStartY=matIn.starty;
        Int32 nHeight=matIn.height;
        Int32 nStartX=matIn.startx;
        Int32 nWidth=matIn.width;
        cv::Mat cvimgIn,cvimgOut;
        void *buffer=matOut->data;

        MatToCvMat(matIn,&cvimgIn);
        cv::pyrDown(cvimgIn,cvimgOut);
        cv::pyrDown(cvimgOut,cvimgOut);
        cv::pyrDown(cvimgOut,cvimgOut);
        CvMatToMat(cvimgOut,matOut,buffer);

        matOut->startx=(nStartX>>3);
        matOut->starty=(nStartY>>3);
        matOut->width=(nWidth>>3);
        matOut->height=(nHeight>>3);

        return 0;
    }

    Int8 MygausspyramidUp(Mat matIn,Mat *matOut)
    {
        Int32 nStartY=matIn.starty;
        Int32 nHeight=matIn.height;
        Int32 nStartX=matIn.startx;
        Int32 nWidth=matIn.width;
        cv::Mat cvimgIn,cvimgOut;
        void *buffer=matOut->data;

        MatToCvMat(matIn,&cvimgIn);
        cv::pyrUp(cvimgIn,cvimgOut);
        CvMatToMat(cvimgOut,matOut,buffer);

        matOut->startx=(nStartX<<1);
        matOut->starty=(nStartY<<1);
        matOut->width=(nWidth<<1);
        matOut->height=(nHeight<<1);

        return 0;
    }

    Int8 Mylapalcepyramid(Mat matIn,Mat gausspyramidIn,Mat *matOut)
    {
        Int32 nnHeight=matIn.nHeight;
        Int32 nnWidth=matIn.nWidth;
        Mat datafilterOut=MatCreatzero(nnHeight,nnWidth,CCV_8UC1,(Uint8*)u8_buffer_x3Temp1);
        Mat matOutabs=MatCreat(nnHeight,nnWidth,CCV_8UC1,(Uint8*)u8_buffer_x1Temp2);
        Mat matIntemp;
        if(matIn.data==matOut->data)
        {
            switch(matIn._type)
            {
                case CCV_8UC1:
                case CCV_8SC1:
                case CCV_16UC1:
                case CCV_16SC1:
                break;
                default:
                    return 1;
                break;
            }
            matIntemp=MatCreatClone(matIn,(Uint8*)u8_buffer_x1Temp6);
        }
        else
        {
            matIntemp=matIn;
        }
        if(gausspyramidIn.nHeight*2!=nnHeight||gausspyramidIn.nWidth*2!=nnWidth||
          matIntemp._type!=gausspyramidIn._type)
        {
            return 1;
        }
        getcloneinfo(gausspyramidIn,matOut);
        MyconvertTo(matOut,matIntemp._type);
        MatSet1col(matOut,0);
        switch(matIntemp._type)
        {
            case CCV_8UC1:
                MygausspyramidUp(gausspyramidIn,&datafilterOut);
                Mysub_image(matIntemp,datafilterOut,&matOutabs);
                Myadd_value(matOutabs,matOut,128);
            break;
            case CCV_8SC1:
                MygausspyramidUp(gausspyramidIn,&datafilterOut);
                Mysub_image(matIntemp,datafilterOut,matOut);
            break;
            case CCV_16UC1:
                MygausspyramidUp(gausspyramidIn,&datafilterOut);
                Mysub_image(matIntemp,datafilterOut,&matOutabs);
                Myadd_value(matOutabs,matOut,32768);
            break;
            case CCV_16SC1:
                MygausspyramidUp(gausspyramidIn,&datafilterOut);
                Mysub_image(matIntemp,datafilterOut,matOut);
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 Mygradpyramid(Mat matIn,gradpyramidtype Mod,Mat *matOut)
    {
        Int32 nnHeight=matIn.nHeight;
        Int32 nnWidth=matIn.nWidth;
        Int32 nStartY=matIn.starty;
        Int32 nHeight=matIn.height;
        Int32 nStartX=matIn.startx;
        Int32 nWidth=matIn.width;
        Uint8 *u8_data1=(Uint8*)u8_buffer_x1Temp2;
        Uint8 *u8_data2=(Uint8*)u8_buffer_x1Temp3;
        Int32 j,i;
        Mat filterIn_H=MatCreat(5,5,CCV_8SC1,gaussian_H5);
        Mat filterIn_V=MatCreat(5,5,CCV_8SC1,gaussian_V5);
        Mat img1,img2;
        cv::Mat cv_filterIn_H,cv_filterIn_V;
        cv::Mat cvimgIn,cvimgOut_H,cvimgOut_V;
        cv::Point cvpoint=cv::Point(2,2);

        MatToCvMat(filterIn_H,&cv_filterIn_H);
        cv_filterIn_H.convertTo(cv_filterIn_H,CV_32FC1);
        MatToCvMat(filterIn_V,&cv_filterIn_V);
        cv_filterIn_V.convertTo(cv_filterIn_V,CV_32FC1);

        MyconvertTo(matOut,matIn._type);
        matOut->nHeight=(nnHeight>>1);
        matOut->nWidth=(nnWidth>>1);
        matOut->startx=(nStartX>>1);
        matOut->starty=(nStartY>>1);
        matOut->width=(nWidth>>1);
        matOut->height=(nHeight>>1);

        switch(matIn._type)
        {
            case CCV_8UC1:
                switch(Mod)
                {
                    case MHC_GRADPYRAMID_X:
                        cvimgIn=cv::Mat(nnHeight,nnWidth,CV_8U);
                        memcpy(cvimgIn.data,matIn.data,getsizeof(matIn._type)*nnHeight*nnWidth);
                        cv::filter2D(cvimgIn,cvimgOut_H,CV_32F,cv_filterIn_H,cvpoint);
                        cvimgOut_H.convertTo(cvimgOut_H,CV_8UC1,1.0/(pow(2,7)));
                        cv::resize(cvimgOut_H,cvimgOut_H,cv::Size(0,0),0.5,0.5,cv::INTER_NEAREST);
                        cvimgOut_H=cvimgOut_H+128;
                        memcpy(matOut->data,cvimgOut_H.data,cvimgOut_H.elemSize()*cvimgOut_H.rows*cvimgOut_H.cols);
                        Myhom_mat2d_translate(*matOut,matOut,1,0);
                    break;
                    case MHC_GRADPYRAMID_Y:
                        cvimgIn=cv::Mat(nnHeight,nnWidth,CV_8U);
                        memcpy(cvimgIn.data,matIn.data,getsizeof(matIn._type)*nnHeight*nnWidth);
                        cv::filter2D(cvimgIn,cvimgOut_V,CV_32F,cv_filterIn_V,cvpoint);
                        cvimgOut_V.convertTo(cvimgOut_V,CV_8UC1,1.0/(pow(2,7)));
                        cv::resize(cvimgOut_V,cvimgOut_V,cv::Size(0,0),0.5,0.5,cv::INTER_NEAREST);
                        cvimgOut_V=cvimgOut_V+128;
                        memcpy(matOut->data,cvimgOut_V.data,cvimgOut_V.elemSize()*cvimgOut_V.rows*cvimgOut_V.cols);
                        Myhom_mat2d_translate(*matOut,matOut,0,1);
                    break;
                    case MHC_GRADPYRAMID_X_Y:
                        cvimgIn=cv::Mat(nnHeight,nnWidth,CV_8U);
                        memcpy(cvimgIn.data,matIn.data,getsizeof(matIn._type)*nnHeight*nnWidth);
                        cv::filter2D(cvimgIn,cvimgOut_H,CV_32F,cv_filterIn_H,cvpoint);
                        cvimgOut_H.convertTo(cvimgOut_H,CV_8UC1,1.0/(pow(2,7)));
                        cv::resize(cvimgOut_H,cvimgOut_H,cv::Size(0,0),0.5,0.5,cv::INTER_NEAREST);
                        cvimgOut_H=cvimgOut_H+128;
                        CvMatToMat(cvimgOut_H,&img1,u8_data1);

                        cv::filter2D(cvimgIn,cvimgOut_V,CV_32F,cv_filterIn_V,cvpoint);
                        cvimgOut_V.convertTo(cvimgOut_V,CV_8UC1,1.0/(pow(2,7)));
                        cv::resize(cvimgOut_V,cvimgOut_V,cv::Size(0,0),0.5,0.5,cv::INTER_NEAREST);
                        cvimgOut_V=cvimgOut_V+128;
                        CvMatToMat(cvimgOut_V,&img2,u8_data2);

                        for(j=0;j<((nnHeight-5)>>1);j++)
                        {
                            for(i=2;i<matOut->nWidth;i++)
                            {
                                matOut->ptr_uchar[j*matOut->nWidth+i-2]=(Uint8)(((Int32)u8_data1[i-1]+(Int32)u8_data2[i])>>1);
                            }
                        }
                    break;
                    case MHC_GRADPYRAMID_XoY:
                        cvimgIn=cv::Mat(nnHeight,nnWidth,CV_8U);
                        memcpy(cvimgIn.data,matIn.data,getsizeof(matIn._type)*nnHeight*nnWidth);
                        cv::filter2D(cvimgIn,cvimgOut_H,CV_32F,cv_filterIn_H,cvpoint);
                        cvimgOut_H.convertTo(cvimgOut_H,CV_8UC1,1.0/(pow(2,7)));
                        cv::resize(cvimgOut_H,cvimgOut_H,cv::Size(0,0),0.5,0.5,cv::INTER_NEAREST);
                        cvimgOut_H=cvimgOut_H+128;
                        CvMatToMat(cvimgOut_H,&img1,u8_data1);

                        cv::filter2D(cvimgIn,cvimgOut_V,CV_32F,cv_filterIn_V,cvpoint);
                        cvimgOut_V.convertTo(cvimgOut_V,CV_8UC1,1.0/(pow(2,7)));
                        cv::resize(cvimgOut_V,cvimgOut_V,cv::Size(0,0),0.5,0.5,cv::INTER_NEAREST);
                        cvimgOut_V=cvimgOut_V+128;
                        CvMatToMat(cvimgOut_V,&img2,u8_data2);

                        for(j=0;j<((nnHeight-5)>>1);j++)
                        {
                            for(i=2;i<matOut->nWidth;i++)
                            {
                                if(abs(128-(Int32)u8_data1[i-1])>abs(128-(Int32)u8_data2[i]))
                                {
                                    matOut->ptr_uchar[j*matOut->nWidth+i-2]=u8_data1[i-1];
                                }
                                else
                                {
                                    matOut->ptr_uchar[j*matOut->nWidth+i-2]=u8_data2[i];
                                }
                            }
                        }
                    break;
                    default:
                        return 1;
                    break;
                }
            break;
            case CCV_8SC1:
                switch(Mod)
                {
                    case MHC_GRADPYRAMID_X:
                        cvimgIn=cv::Mat(nnHeight,nnWidth,CV_16S);
                        memcpy(cvimgIn.data,matIn.data,getsizeof(matIn._type)*nnHeight*nnWidth);
                        cv::filter2D(cvimgIn,cvimgOut_H,CV_32F,cv_filterIn_H,cvpoint);
                        cvimgOut_H.convertTo(cvimgOut_H,CV_8SC1,1.0/(pow(2,7)));
                        cv::resize(cvimgOut_H,cvimgOut_H,cv::Size(0,0),0.5,0.5,cv::INTER_NEAREST);
                        memcpy(matOut->data,cvimgOut_H.data,cvimgOut_H.elemSize()*cvimgOut_H.rows*cvimgOut_H.cols);
                        Myhom_mat2d_translate(*matOut,matOut,1,0);
                    break;
                    case MHC_GRADPYRAMID_Y:
                        cvimgIn=cv::Mat(nnHeight,nnWidth,CV_16S);
                        memcpy(cvimgIn.data,matIn.data,getsizeof(matIn._type)*nnHeight*nnWidth);
                        cv::filter2D(cvimgIn,cvimgOut_V,CV_32F,cv_filterIn_V,cvpoint);
                        cvimgOut_V.convertTo(cvimgOut_V,CV_8SC1,1.0/(pow(2,7)));
                        cv::resize(cvimgOut_V,cvimgOut_V,cv::Size(0,0),0.5,0.5,cv::INTER_NEAREST);
                        memcpy(matOut->data,cvimgOut_V.data,cvimgOut_V.elemSize()*cvimgOut_V.rows*cvimgOut_V.cols);
                        Myhom_mat2d_translate(*matOut,matOut,0,1);
                    break;
                    case MHC_GRADPYRAMID_X_Y:
                        cvimgIn=cv::Mat(nnHeight,nnWidth,CV_16S);
                        memcpy(cvimgIn.data,matIn.data,getsizeof(matIn._type)*nnHeight*nnWidth);
                        cv::filter2D(cvimgIn,cvimgOut_H,CV_32F,cv_filterIn_H,cvpoint);
                        cvimgOut_H.convertTo(cvimgOut_H,CV_8SC1,1.0/(pow(2,7)));
                        cv::resize(cvimgOut_H,cvimgOut_H,cv::Size(0,0),0.5,0.5,cv::INTER_NEAREST);
                        CvMatToMat(cvimgOut_H,&img1,u8_data1);

                        cv::filter2D(cvimgIn,cvimgOut_V,CV_32F,cv_filterIn_V,cvpoint);
                        cvimgOut_V.convertTo(cvimgOut_V,CV_8SC1,1.0/(pow(2,7)));
                        cv::resize(cvimgOut_V,cvimgOut_V,cv::Size(0,0),0.5,0.5,cv::INTER_NEAREST);
                        CvMatToMat(cvimgOut_V,&img2,u8_data2);

                        for(j=0;j<((nnHeight-5)>>1);j++)
                        {
                            for(i=2;i<matOut->nWidth;i++)
                            {
                                matOut->ptr_char[j*matOut->nWidth+i-2]=(Uint8)(((Int32)img1.ptr_char[i-1]+(Int32)img2.ptr_char[i])>>1);
                            }
                        }

                    break;
                    case MHC_GRADPYRAMID_XoY:
                        cvimgIn=cv::Mat(nnHeight,nnWidth,CV_16S);
                        memcpy(cvimgIn.data,matIn.data,getsizeof(matIn._type)*nnHeight*nnWidth);
                        cv::filter2D(cvimgIn,cvimgOut_H,CV_32F,cv_filterIn_H,cvpoint);
                        cvimgOut_H.convertTo(cvimgOut_H,CV_8SC1,1.0/(pow(2,7)));
                        cv::resize(cvimgOut_H,cvimgOut_H,cv::Size(0,0),0.5,0.5,cv::INTER_NEAREST);
                        CvMatToMat(cvimgOut_H,&img1,u8_data1);

                        cv::filter2D(cvimgIn,cvimgOut_V,CV_32F,cv_filterIn_V,cvpoint);
                        cvimgOut_V.convertTo(cvimgOut_V,CV_8SC1,1.0/(pow(2,7)));
                        cv::resize(cvimgOut_V,cvimgOut_V,cv::Size(0,0),0.5,0.5,cv::INTER_NEAREST);
                        CvMatToMat(cvimgOut_V,&img2,u8_data2);

                        for(j=0;j<((nnHeight-5)>>1);j++)
                        {
                            for(i=2;i<matOut->nWidth;i++)
                            {
                                if(abs(128-(Int32)img1.ptr_char[i-1])>abs(128-(Int32)img2.ptr_char[i]))
                                {
                                    matOut->ptr_char[j*matOut->nWidth+i-2]=img1.ptr_char[i-1];
                                }
                                else
                                {
                                    matOut->ptr_char[j*matOut->nWidth+i-2]=img2.ptr_char[i];
                                }
                            }
                        }
                    break;
                    default:
                        return 1;
                    break;
                }
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 Myaddimagebry(Mat matIn,Mat mask,Int32 *valout)
    {
        Int32 nnWidth=matIn.nWidth;
        Int32 j,i;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        Int32 val=0;
        if(0!=judgeMaskSize(matIn,mask))//掩膜不匹配
            return 1;
        switch(matIn._type)
        {
            case CCV_8UC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(mask.data[j*nnWidth+i]!=0)
                        {
                            val=val+matIn.ptr_uchar[j*nnWidth+i];
                        }
                    }
                }
            break;
            case CCV_8SC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(mask.data[j*nnWidth+i]!=0)
                        {
                            val=val+matIn.ptr_char[j*nnWidth+i];
                        }
                    }
                }
            break;
            case CCV_16UC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(mask.data[j*nnWidth+i]!=0)
                        {
                            val=val+matIn.ptr_ushort[j*nnWidth+i];
                        }
                    }
                }
            break;
            case CCV_16SC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(mask.data[j*nnWidth+i]!=0)
                        {
                            val=val+matIn.ptr_short[j*nnWidth+i];
                        }
                    }
                }
            break;
            case CCV_32SC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(mask.data[j*nnWidth+i]!=0)
                        {
                            val=val+matIn.ptr_int[j*nnWidth+i];
                        }
                    }
                }
            break;
            default:
                return 1;
            break;
        }
        *valout=val;
        return 0;
    }

    Int8 Myfilter(Mat matIn,Mat filterIn,Mat *matOut,type Mod,Int16 shift,L_Point32 center)
    {
        Int32 j;
        Int32 nnHeight=matIn.nHeight;
        Int32 nnWidth=matIn.nWidth;
        Int32 nStartY=matIn.starty;
        Int32 nHeight=matIn.height;
        Int32 nStartX=matIn.startx;
        Int32 nWidth=matIn.width;
        Int32 nST;
        Int32 nED;
        Int32 iST;
        Int32 iED;
        Int32 nST2;
        Int32 nED2;
        Int32 iST2;
        Int32 iED2;

        cv::Mat m16_filterIn;
        Mat m16_dataIn=MatCreat(matIn.nHeight,matIn.nWidth,CCV_16SC1,u8_buffer_x1Temp2);
        cv::Mat cvimgIn,cvimgOut;

        Mat matIntemp;

        Int32 moveX,moveY;
        Int32 moveX2,moveY2;
        Int32 mintop,minleft;

        cv::Point cvpoint=cv::Point(center.x,center.y);

        MatToCvMat(filterIn,&m16_filterIn);
        m16_filterIn.convertTo(m16_filterIn,CV_32FC1);

        if(center.x>=(Int32)filterIn.nWidth)
            center.x=filterIn.nWidth-1;
        if(center.y>=(Int32)filterIn.nHeight)
            center.y=filterIn.nHeight-1;
        if(center.x<0||center.y<0)
        {
            moveX=(filterIn.nWidth>>1);
            moveY=(filterIn.nHeight>>1);
        }
        else
        {
            moveX=center.x;
            moveY=center.y;
        }

        matOut->nWidth=matIn.nWidth;
        matOut->nHeight=matIn.nHeight;
        matOut->startx=matIn.startx;
        matOut->starty=matIn.starty;
        matOut->width=matIn.width;
        matOut->height=matIn.height;
        MyconvertTo(matOut,Mod);

        if(matIn.data==matOut->data)
        {
            switch(matIn._type)
            {
                case CCV_8UC1:
                case CCV_8SC1:
                case CCV_16UC1:
                case CCV_16SC1:
                case CCV_32SC1:
                case CCV_32FC1:
                break;
                default:
                    return 1;
                break;
            }
            matIntemp=MatCreatClone(matIn,u8_buffer_x1Temp3);
        }
        else
        {
            matIntemp=matIn;
        }

        moveX2=filterIn.nWidth-moveX;
        moveY2=filterIn.nHeight-moveY;

        nST=nStartY-moveY;
        nED=nStartY+nHeight+moveY2;
        iST=nStartX-moveX;
        iED=nStartX+nWidth+moveX2;

        nST2=nST;
        nED2=nED;
        iST2=iST;
        iED2=iED;

        mintop=moveY;
        minleft=moveX;

        if(nST2<0)
        {
            nST2=0;
            mintop=mintop-(nST2-nST);
        }
        if(nED2>nnHeight-1)
        {
            nED2=nnHeight-1;
        }
        if(iST2<0)
        {
            iST2=0;
            minleft=minleft-(iST2-iST);
        }
        if(iED2>nnWidth-1)
        {
            iED2=nnWidth-1;
        }

        MyCutminRoi(matIntemp,&m16_dataIn,MHC_CUTMIN_1,iST2,nST2,iED2-iST2+1,nED2-nST2+1);

        switch(matIntemp._type)
        {
            case CCV_8UC1:
            case CCV_8SC1:
            {
                switch(Mod)
                {
                    case CCV_8UC1:
                    case CCV_8SC1:
                    {
                        if(shift==0)
                        {
                            cvimgIn=cv::Mat(m16_dataIn.nHeight,m16_dataIn.nWidth,CV_8U);
                            memcpy(cvimgIn.data,m16_dataIn.data,getsizeof(m16_dataIn._type)*m16_dataIn.nHeight*m16_dataIn.nWidth);
                            cv::filter2D(cvimgIn,cvimgOut,-1,m16_filterIn,cvpoint);
                            memcpy(m16_dataIn.data,cvimgOut.data,cvimgOut.elemSize()*cvimgOut.rows*cvimgOut.cols);
                        }
                        else if(shift<=4)
                        {
                            cvimgIn=cv::Mat(m16_dataIn.nHeight,m16_dataIn.nWidth,CV_8U);
                            memcpy(cvimgIn.data,m16_dataIn.data,getsizeof(m16_dataIn._type)*m16_dataIn.nHeight*m16_dataIn.nWidth);
                            cv::filter2D(cvimgIn,cvimgOut,CV_16S,m16_filterIn,cvpoint);
                            if(Mod==CCV_8UC1)
                                cvimgOut.convertTo(cvimgOut,CV_8U,1.0/(pow(2,shift)));
                            else
                                cvimgOut.convertTo(cvimgOut,CV_8S,1.0/(pow(2,shift)));
                            memcpy(m16_dataIn.data,cvimgOut.data,cvimgOut.elemSize()*cvimgOut.rows*cvimgOut.cols);
                        }
                        else
                        {
                            cvimgIn=cv::Mat(m16_dataIn.nHeight,m16_dataIn.nWidth,CV_8U);
                            memcpy(cvimgIn.data,m16_dataIn.data,getsizeof(m16_dataIn._type)*m16_dataIn.nHeight*m16_dataIn.nWidth);
                            cv::filter2D(cvimgIn,cvimgOut,CV_32F,m16_filterIn,cvpoint);
                            if(Mod==CCV_8UC1)
                                cvimgOut.convertTo(cvimgOut,CV_8U,1.0/(pow(2,shift)));
                            else
                                cvimgOut.convertTo(cvimgOut,CV_8S,1.0/(pow(2,shift)));
                            memcpy(m16_dataIn.data,cvimgOut.data,cvimgOut.elemSize()*cvimgOut.rows*cvimgOut.cols);
                        }
                    }
                    break;
                    case CCV_16UC1:
                    case CCV_16SC1:
                    {
                        if(shift==0)
                        {
                            cvimgIn=cv::Mat(m16_dataIn.nHeight,m16_dataIn.nWidth,CV_8U);
                            memcpy(cvimgIn.data,m16_dataIn.data,getsizeof(m16_dataIn._type)*m16_dataIn.nHeight*m16_dataIn.nWidth);
                            cv::filter2D(cvimgIn,cvimgOut,CV_16S,m16_filterIn,cvpoint);
                            MyconvertTo(&m16_dataIn,Mod);
                            memcpy(m16_dataIn.data,cvimgOut.data,cvimgOut.elemSize()*cvimgOut.rows*cvimgOut.cols);
                        }
                        else
                        {
                            cvimgIn=cv::Mat(m16_dataIn.nHeight,m16_dataIn.nWidth,CV_8U);
                            memcpy(cvimgIn.data,m16_dataIn.data,getsizeof(m16_dataIn._type)*m16_dataIn.nHeight*m16_dataIn.nWidth);
                            cv::filter2D(cvimgIn,cvimgOut,CV_32F,m16_filterIn,cvpoint);
                            if(Mod==CCV_16UC1)
                                cvimgOut.convertTo(cvimgOut,CV_16U,1.0/(pow(2,shift)));
                            else
                                cvimgOut.convertTo(cvimgOut,CV_16S,1.0/(pow(2,shift)));
                            MyconvertTo(&m16_dataIn,Mod);
                            memcpy(m16_dataIn.data,cvimgOut.data,cvimgOut.elemSize()*cvimgOut.rows*cvimgOut.cols);
                        }
                    }
                    break;
                    case CCV_32SC1:
                    {
                        if(shift==0)
                        {
                            cvimgIn=cv::Mat(m16_dataIn.nHeight,m16_dataIn.nWidth,CV_8U);
                            memcpy(cvimgIn.data,m16_dataIn.data,getsizeof(m16_dataIn._type)*m16_dataIn.nHeight*m16_dataIn.nWidth);
                            cv::filter2D(cvimgIn,cvimgOut,CV_32F,m16_filterIn,cvpoint);
                            cvimgOut.convertTo(cvimgOut,CV_32S);
                            MyconvertTo(&m16_dataIn,Mod);
                            memcpy(m16_dataIn.data,cvimgOut.data,cvimgOut.elemSize()*cvimgOut.rows*cvimgOut.cols);
                        }
                        else
                        {
                            cvimgIn=cv::Mat(m16_dataIn.nHeight,m16_dataIn.nWidth,CV_8U);
                            memcpy(cvimgIn.data,m16_dataIn.data,getsizeof(m16_dataIn._type)*m16_dataIn.nHeight*m16_dataIn.nWidth);
                            cv::filter2D(cvimgIn,cvimgOut,CV_64F,m16_filterIn,cvpoint);
                            cvimgOut.convertTo(cvimgOut,CV_32S,1.0/(pow(2,shift)));
                            MyconvertTo(&m16_dataIn,Mod);
                            memcpy(m16_dataIn.data,cvimgOut.data,cvimgOut.elemSize()*cvimgOut.rows*cvimgOut.cols);
                        }
                    }
                    break;
                    case CCV_32FC1:
                    {
                        if(shift==0)
                        {
                            cvimgIn=cv::Mat(m16_dataIn.nHeight,m16_dataIn.nWidth,CV_8U);
                            memcpy(cvimgIn.data,m16_dataIn.data,getsizeof(m16_dataIn._type)*m16_dataIn.nHeight*m16_dataIn.nWidth);
                            cv::filter2D(cvimgIn,cvimgOut,CV_32F,m16_filterIn,cvpoint);
                            MyconvertTo(&m16_dataIn,Mod);
                            memcpy(m16_dataIn.data,cvimgOut.data,cvimgOut.elemSize()*cvimgOut.rows*cvimgOut.cols);
                        }
                        else
                        {
                            cvimgIn=cv::Mat(m16_dataIn.nHeight,m16_dataIn.nWidth,CV_8U);
                            memcpy(cvimgIn.data,m16_dataIn.data,getsizeof(m16_dataIn._type)*m16_dataIn.nHeight*m16_dataIn.nWidth);
                            cv::filter2D(cvimgIn,cvimgOut,CV_64F,m16_filterIn,cvpoint);
                            cvimgOut.convertTo(cvimgOut,CV_32F,1.0/(pow(2,shift)));
                            MyconvertTo(&m16_dataIn,Mod);
                            memcpy(m16_dataIn.data,cvimgOut.data,cvimgOut.elemSize()*cvimgOut.rows*cvimgOut.cols);
                        }
                    }
                    break;
                    default:
                        return 1;
                    break;
                }
            }
            break;
            case CCV_16UC1:
            {
                switch(Mod)
                {
                    case CCV_16UC1:
                    case CCV_16SC1:
                    {
                        if(shift==0)
                        {
                            cvimgIn=cv::Mat(m16_dataIn.nHeight,m16_dataIn.nWidth,CV_16U);
                            memcpy(cvimgIn.data,m16_dataIn.data,getsizeof(m16_dataIn._type)*m16_dataIn.nHeight*m16_dataIn.nWidth);
                            cv::filter2D(cvimgIn,cvimgOut,-1,m16_filterIn,cvpoint);
                            MyconvertTo(&m16_dataIn,Mod);
                            memcpy(m16_dataIn.data,cvimgOut.data,cvimgOut.elemSize()*cvimgOut.rows*cvimgOut.cols);
                        }
                        else
                        {
                            cvimgIn=cv::Mat(m16_dataIn.nHeight,m16_dataIn.nWidth,CV_16U);
                            memcpy(cvimgIn.data,m16_dataIn.data,getsizeof(m16_dataIn._type)*m16_dataIn.nHeight*m16_dataIn.nWidth);
                            cv::filter2D(cvimgIn,cvimgOut,CV_32F,m16_filterIn,cvpoint);
                            if(Mod==CCV_16UC1)
                                cvimgOut.convertTo(cvimgOut,CV_16U,1.0/(pow(2,shift)));
                            else
                                cvimgOut.convertTo(cvimgOut,CV_16S,1.0/(pow(2,shift)));
                            MyconvertTo(&m16_dataIn,Mod);
                            memcpy(m16_dataIn.data,cvimgOut.data,cvimgOut.elemSize()*cvimgOut.rows*cvimgOut.cols);
                        }
                    }
                    break;
                    case CCV_32SC1:
                    {
                        if(shift==0)
                        {
                            cvimgIn=cv::Mat(m16_dataIn.nHeight,m16_dataIn.nWidth,CV_16U);
                            memcpy(cvimgIn.data,m16_dataIn.data,getsizeof(m16_dataIn._type)*m16_dataIn.nHeight*m16_dataIn.nWidth);
                            cv::filter2D(cvimgIn,cvimgOut,CV_32F,m16_filterIn,cvpoint);
                            cvimgOut.convertTo(cvimgOut,CV_32S);
                            MyconvertTo(&m16_dataIn,Mod);
                            memcpy(m16_dataIn.data,cvimgOut.data,cvimgOut.elemSize()*cvimgOut.rows*cvimgOut.cols);
                        }
                        else
                        {
                            cvimgIn=cv::Mat(m16_dataIn.nHeight,m16_dataIn.nWidth,CV_16U);
                            memcpy(cvimgIn.data,m16_dataIn.data,getsizeof(m16_dataIn._type)*m16_dataIn.nHeight*m16_dataIn.nWidth);
                            cv::filter2D(cvimgIn,cvimgOut,CV_64F,m16_filterIn,cvpoint);
                            cvimgOut.convertTo(cvimgOut,CV_32S,1.0/(pow(2,shift)));
                            MyconvertTo(&m16_dataIn,Mod);
                            memcpy(m16_dataIn.data,cvimgOut.data,cvimgOut.elemSize()*cvimgOut.rows*cvimgOut.cols);
                        }
                    }
                    break;
                    case CCV_32FC1:
                    {
                        if(shift==0)
                        {
                            cvimgIn=cv::Mat(m16_dataIn.nHeight,m16_dataIn.nWidth,CV_16U);
                            memcpy(cvimgIn.data,m16_dataIn.data,getsizeof(m16_dataIn._type)*m16_dataIn.nHeight*m16_dataIn.nWidth);
                            cv::filter2D(cvimgIn,cvimgOut,CV_32F,m16_filterIn,cvpoint);
                            MyconvertTo(&m16_dataIn,Mod);
                            memcpy(m16_dataIn.data,cvimgOut.data,cvimgOut.elemSize()*cvimgOut.rows*cvimgOut.cols);
                        }
                        else
                        {
                            cvimgIn=cv::Mat(m16_dataIn.nHeight,m16_dataIn.nWidth,CV_16U);
                            memcpy(cvimgIn.data,m16_dataIn.data,getsizeof(m16_dataIn._type)*m16_dataIn.nHeight*m16_dataIn.nWidth);
                            cv::filter2D(cvimgIn,cvimgOut,CV_64F,m16_filterIn,cvpoint);
                            cvimgOut.convertTo(cvimgOut,CV_32F,1.0/(pow(2,shift)));
                            MyconvertTo(&m16_dataIn,Mod);
                            memcpy(m16_dataIn.data,cvimgOut.data,cvimgOut.elemSize()*cvimgOut.rows*cvimgOut.cols);
                        }
                    }
                    break;
                    default:
                        return 1;
                    break;
                }
            }
            break;
            case CCV_16SC1:
            {
                switch(Mod)
                {
                    case CCV_16UC1:
                    case CCV_16SC1:
                    {
                        if(shift==0)
                        {
                            cvimgIn=cv::Mat(m16_dataIn.nHeight,m16_dataIn.nWidth,CV_16S);
                            memcpy(cvimgIn.data,m16_dataIn.data,getsizeof(m16_dataIn._type)*m16_dataIn.nHeight*m16_dataIn.nWidth);
                            cv::filter2D(cvimgIn,cvimgOut,-1,m16_filterIn,cvpoint);
                            MyconvertTo(&m16_dataIn,Mod);
                            memcpy(m16_dataIn.data,cvimgOut.data,cvimgOut.elemSize()*cvimgOut.rows*cvimgOut.cols);
                        }
                        else
                        {
                            cvimgIn=cv::Mat(m16_dataIn.nHeight,m16_dataIn.nWidth,CV_16S);
                            memcpy(cvimgIn.data,m16_dataIn.data,getsizeof(m16_dataIn._type)*m16_dataIn.nHeight*m16_dataIn.nWidth);
                            cv::filter2D(cvimgIn,cvimgOut,CV_32F,m16_filterIn,cvpoint);
                            if(Mod==CCV_16UC1)
                                cvimgOut.convertTo(cvimgOut,CV_16U,1.0/(pow(2,shift)));
                            else
                                cvimgOut.convertTo(cvimgOut,CV_16S,1.0/(pow(2,shift)));
                            MyconvertTo(&m16_dataIn,Mod);
                            memcpy(m16_dataIn.data,cvimgOut.data,cvimgOut.elemSize()*cvimgOut.rows*cvimgOut.cols);
                        }
                    }
                    break;
                    case CCV_32SC1:
                    {
                        if(shift==0)
                        {
                            cvimgIn=cv::Mat(m16_dataIn.nHeight,m16_dataIn.nWidth,CV_16S);
                            memcpy(cvimgIn.data,m16_dataIn.data,getsizeof(m16_dataIn._type)*m16_dataIn.nHeight*m16_dataIn.nWidth);
                            cv::filter2D(cvimgIn,cvimgOut,CV_32F,m16_filterIn,cvpoint);
                            cvimgOut.convertTo(cvimgOut,CV_32S);
                            MyconvertTo(&m16_dataIn,Mod);
                            memcpy(m16_dataIn.data,cvimgOut.data,cvimgOut.elemSize()*cvimgOut.rows*cvimgOut.cols);
                        }
                        else
                        {
                            cvimgIn=cv::Mat(m16_dataIn.nHeight,m16_dataIn.nWidth,CV_16S);
                            memcpy(cvimgIn.data,m16_dataIn.data,getsizeof(m16_dataIn._type)*m16_dataIn.nHeight*m16_dataIn.nWidth);
                            cv::filter2D(cvimgIn,cvimgOut,CV_64F,m16_filterIn,cvpoint);
                            cvimgOut.convertTo(cvimgOut,CV_32S,1.0/(pow(2,shift)));
                            MyconvertTo(&m16_dataIn,Mod);
                            memcpy(m16_dataIn.data,cvimgOut.data,cvimgOut.elemSize()*cvimgOut.rows*cvimgOut.cols);
                        }
                    }
                    break;
                    case CCV_32FC1:
                    {
                        if(shift==0)
                        {
                            cvimgIn=cv::Mat(m16_dataIn.nHeight,m16_dataIn.nWidth,CV_16S);
                            memcpy(cvimgIn.data,m16_dataIn.data,getsizeof(m16_dataIn._type)*m16_dataIn.nHeight*m16_dataIn.nWidth);
                            cv::filter2D(cvimgIn,cvimgOut,CV_32F,m16_filterIn,cvpoint);
                            MyconvertTo(&m16_dataIn,Mod);
                            memcpy(m16_dataIn.data,cvimgOut.data,cvimgOut.elemSize()*cvimgOut.rows*cvimgOut.cols);
                        }
                        else
                        {
                            cvimgIn=cv::Mat(m16_dataIn.nHeight,m16_dataIn.nWidth,CV_16S);
                            memcpy(cvimgIn.data,m16_dataIn.data,getsizeof(m16_dataIn._type)*m16_dataIn.nHeight*m16_dataIn.nWidth);
                            cv::filter2D(cvimgIn,cvimgOut,CV_64F,m16_filterIn,cvpoint);
                            cvimgOut.convertTo(cvimgOut,CV_32F,1.0/(pow(2,shift)));
                            MyconvertTo(&m16_dataIn,Mod);
                            memcpy(m16_dataIn.data,cvimgOut.data,cvimgOut.elemSize()*cvimgOut.rows*cvimgOut.cols);
                        }
                    }
                    break;
                    default:
                        return 1;
                    break;
                }
            }
            break;
            case CCV_32SC1:
            {
                switch(Mod)
                {
                    case CCV_32SC1:
                    {
                        if(shift==0)
                        {
                            cvimgIn=cv::Mat(m16_dataIn.nHeight,m16_dataIn.nWidth,CV_32S);
                            memcpy(cvimgIn.data,m16_dataIn.data,getsizeof(m16_dataIn._type)*m16_dataIn.nHeight*m16_dataIn.nWidth);
                            cvimgIn.convertTo(cvimgIn,CV_32F);
                            cv::filter2D(cvimgIn,cvimgOut,-1,m16_filterIn,cvpoint);
                            cvimgOut.convertTo(cvimgOut,CV_32S);
                            MyconvertTo(&m16_dataIn,Mod);
                            memcpy(m16_dataIn.data,cvimgOut.data,cvimgOut.elemSize()*cvimgOut.rows*cvimgOut.cols);
                        }
                        else
                        {
                            cvimgIn=cv::Mat(m16_dataIn.nHeight,m16_dataIn.nWidth,CV_32S);
                            memcpy(cvimgIn.data,m16_dataIn.data,getsizeof(m16_dataIn._type)*m16_dataIn.nHeight*m16_dataIn.nWidth);
                            cvimgIn.convertTo(cvimgIn,CV_32F);
                            cv::filter2D(cvimgIn,cvimgOut,CV_64F,m16_filterIn,cvpoint);
                            cvimgOut.convertTo(cvimgOut,CV_32S,1.0/(pow(2,shift)));
                            MyconvertTo(&m16_dataIn,Mod);
                            memcpy(m16_dataIn.data,cvimgOut.data,cvimgOut.elemSize()*cvimgOut.rows*cvimgOut.cols);
                        }
                    }
                    break;
                    case CCV_32FC1:
                    {
                        if(shift==0)
                        {
                            cvimgIn=cv::Mat(m16_dataIn.nHeight,m16_dataIn.nWidth,CV_32S);
                            memcpy(cvimgIn.data,m16_dataIn.data,getsizeof(m16_dataIn._type)*m16_dataIn.nHeight*m16_dataIn.nWidth);
                            cvimgIn.convertTo(cvimgIn,CV_32F);
                            cv::filter2D(cvimgIn,cvimgOut,-1,m16_filterIn,cvpoint);
                            MyconvertTo(&m16_dataIn,Mod);
                            memcpy(m16_dataIn.data,cvimgOut.data,cvimgOut.elemSize()*cvimgOut.rows*cvimgOut.cols);
                        }
                        else
                        {
                            cvimgIn=cv::Mat(m16_dataIn.nHeight,m16_dataIn.nWidth,CV_32S);
                            memcpy(cvimgIn.data,m16_dataIn.data,getsizeof(m16_dataIn._type)*m16_dataIn.nHeight*m16_dataIn.nWidth);
                            cvimgIn.convertTo(cvimgIn,CV_32F);
                            cv::filter2D(cvimgIn,cvimgOut,CV_64F,m16_filterIn,cvpoint);
                            cvimgOut.convertTo(cvimgOut,CV_32F,1.0/(pow(2,shift)));
                            MyconvertTo(&m16_dataIn,Mod);
                            memcpy(m16_dataIn.data,cvimgOut.data,cvimgOut.elemSize()*cvimgOut.rows*cvimgOut.cols);
                        }
                    }
                    break;
                    default:
                        return 1;
                    break;
                }
            }
            break;
            case CCV_32FC1:
            {
                switch(Mod)
                {
                    case CCV_32SC1:
                    {
                        if(shift==0)
                        {
                            cvimgIn=cv::Mat(m16_dataIn.nHeight,m16_dataIn.nWidth,CV_32F);
                            memcpy(cvimgIn.data,m16_dataIn.data,getsizeof(m16_dataIn._type)*m16_dataIn.nHeight*m16_dataIn.nWidth);
                            cv::filter2D(cvimgIn,cvimgOut,-1,m16_filterIn,cvpoint);
                            MyconvertTo(&m16_dataIn,Mod);
                            memcpy(m16_dataIn.data,cvimgOut.data,cvimgOut.elemSize()*cvimgOut.rows*cvimgOut.cols);
                        }
                        else
                        {
                            cvimgIn=cv::Mat(m16_dataIn.nHeight,m16_dataIn.nWidth,CV_32F);
                            memcpy(cvimgIn.data,m16_dataIn.data,getsizeof(m16_dataIn._type)*m16_dataIn.nHeight*m16_dataIn.nWidth);
                            cv::filter2D(cvimgIn,cvimgOut,CV_64F,m16_filterIn,cvpoint);
                            cvimgOut.convertTo(cvimgOut,CV_32S,1.0/(pow(2,shift)));
                            MyconvertTo(&m16_dataIn,Mod);
                            memcpy(m16_dataIn.data,cvimgOut.data,cvimgOut.elemSize()*cvimgOut.rows*cvimgOut.cols);
                        }
                    }
                    break;
                    case CCV_32FC1:
                    {
                        if(shift==0)
                        {
                            cvimgIn=cv::Mat(m16_dataIn.nHeight,m16_dataIn.nWidth,CV_32F);
                            memcpy(cvimgIn.data,m16_dataIn.data,getsizeof(m16_dataIn._type)*m16_dataIn.nHeight*m16_dataIn.nWidth);
                            cv::filter2D(cvimgIn,cvimgOut,-1,m16_filterIn,cvpoint);
                            MyconvertTo(&m16_dataIn,Mod);
                            memcpy(m16_dataIn.data,cvimgOut.data,cvimgOut.elemSize()*cvimgOut.rows*cvimgOut.cols);
                        }
                        else
                        {
                            cvimgIn=cv::Mat(m16_dataIn.nHeight,m16_dataIn.nWidth,CV_32F);
                            memcpy(cvimgIn.data,m16_dataIn.data,getsizeof(m16_dataIn._type)*m16_dataIn.nHeight*m16_dataIn.nWidth);
                            cv::filter2D(cvimgIn,cvimgOut,CV_64F,m16_filterIn,cvpoint);
                            cvimgOut.convertTo(cvimgOut,CV_32F,1.0/(pow(2,shift)));
                            MyconvertTo(&m16_dataIn,Mod);
                            memcpy(m16_dataIn.data,cvimgOut.data,cvimgOut.elemSize()*cvimgOut.rows*cvimgOut.cols);
                        }
                    }
                    break;
                    default:
                        return 1;
                    break;
                }
            }
            break;
            default:
                return 1;
            break;
        }

        MyCutselfRoi(&m16_dataIn,minleft,mintop,nWidth,nHeight);

        switch(matOut->_type)
        {
            case CCV_8UC1:
                for(j=m16_dataIn.starty;j<m16_dataIn.starty+m16_dataIn.height;j++)
                {
                    memcpy(&matOut->ptr_uchar[(j-m16_dataIn.starty+nStartY)*matOut->nWidth+nStartX],&m16_dataIn.ptr_uchar[j*m16_dataIn.nWidth+m16_dataIn.startx],nWidth*getsizeof(matOut->_type));
                }
            break;
            case CCV_8SC1:
                for(j=m16_dataIn.starty;j<m16_dataIn.starty+m16_dataIn.height;j++)
                {
                    memcpy(&matOut->ptr_char[(j-m16_dataIn.starty+nStartY)*matOut->nWidth+nStartX],&m16_dataIn.ptr_char[j*m16_dataIn.nWidth+m16_dataIn.startx],nWidth*getsizeof(matOut->_type));
                }
            break;
            case CCV_16UC1:
                for(j=m16_dataIn.starty;j<m16_dataIn.starty+m16_dataIn.height;j++)
                {
                    memcpy(&matOut->ptr_ushort[(j-m16_dataIn.starty+nStartY)*matOut->nWidth+nStartX],&m16_dataIn.ptr_ushort[j*m16_dataIn.nWidth+m16_dataIn.startx],nWidth*getsizeof(matOut->_type));
                }
            break;
            case CCV_16SC1:
                for(j=m16_dataIn.starty;j<m16_dataIn.starty+m16_dataIn.height;j++)
                {
                    memcpy(&matOut->ptr_short[(j-m16_dataIn.starty+nStartY)*matOut->nWidth+nStartX],&m16_dataIn.ptr_short[j*m16_dataIn.nWidth+m16_dataIn.startx],nWidth*getsizeof(matOut->_type));
                }
            break;
            case CCV_32SC1:
                for(j=m16_dataIn.starty;j<m16_dataIn.starty+m16_dataIn.height;j++)
                {
                    memcpy(&matOut->ptr_int[(j-m16_dataIn.starty+nStartY)*matOut->nWidth+nStartX],&m16_dataIn.ptr_int[j*m16_dataIn.nWidth+m16_dataIn.startx],nWidth*getsizeof(matOut->_type));
                }
            break;
            case CCV_32FC1:
                for(j=m16_dataIn.starty;j<m16_dataIn.starty+m16_dataIn.height;j++)
                {
                    memcpy(&matOut->ptr_float[(j-m16_dataIn.starty+nStartY)*matOut->nWidth+nStartX],&m16_dataIn.ptr_float[j*m16_dataIn.nWidth+m16_dataIn.startx],nWidth*getsizeof(matOut->_type));
                }
            break;
            default:
                return 1;
            break;
        }

        return 0;
    }

    Int8 Mymin_max_gray(Mat matIn,Int32 *min,Int32 *max,L_Point *minLoc,L_Point *maxLoc)
    {
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        double d_min,d_max;
        cv::Mat cvimgIn;
        cv::Mat cvRoi;
        cv::Point minpoint,maxpoint;

        if(nWidth*nHeight<=0)
            return 1;

        switch(matIn._type)
        {
            case CCV_8UC1:
            case CCV_8SC1:
            case CCV_16UC1:
            case CCV_16SC1:
            case CCV_32SC1:
            case CCV_32FC1:
            case CCV_64FC1:
                MatToCvMat(matIn,&cvimgIn);
                cvRoi=cvimgIn(cv::Rect(nStartX,nStartY,nWidth,nHeight));
                cv::minMaxLoc(cvRoi,&d_min,&d_max,&minpoint,&maxpoint);
                maxLoc->x=maxpoint.x+nStartX;
                maxLoc->y=maxpoint.y+nStartY;
                minLoc->x=minpoint.x+nStartX;
                minLoc->y=minpoint.y+nStartY;
                *min=d_min+0.5;
                *max=d_max+0.5;
           break;
           default:
                return 1;
           break;
        }
        return 0;
    }

    Int8 Mymin_max_gray_mask(Mat matIn,Int32 *min,Int32 *max,L_Point *minLoc,L_Point *maxLoc,Mat mask)
    {
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        double d_min,d_max;
        cv::Mat cv_mask;
        cv::Mat cvimgIn;
        cv::Mat cvRoi,cvRoi_mask;
        cv::Point minpoint,maxpoint;

        if(nWidth*nHeight<=0)
            return 1;
        if(0!=judgeMaskSize(matIn,mask))
            return 2;
        MatToCvMat(mask,&cv_mask);
        cvRoi_mask=cv_mask(cv::Rect(nStartX,nStartY,nWidth,nHeight));
        if(0==cv::countNonZero(cvRoi_mask))
            return 3;
        switch(matIn._type)
        {
            case CCV_8UC1:
            case CCV_8SC1:
            case CCV_16UC1:
            case CCV_16SC1:
            case CCV_32SC1:
            case CCV_32FC1:
            case CCV_64FC1:
                MatToCvMat(matIn,&cvimgIn);
                cvRoi=cvimgIn(cv::Rect(nStartX,nStartY,nWidth,nHeight));
                cv::minMaxLoc(cvRoi,&d_min,&d_max,&minpoint,&maxpoint,cvRoi_mask);
                maxLoc->x=maxpoint.x+nStartX;
                maxLoc->y=maxpoint.y+nStartY;
                minLoc->x=minpoint.x+nStartX;
                minLoc->y=minpoint.y+nStartY;
                *min=d_min+0.5;
                *max=d_max+0.5;
           break;
           default:
                return 1;
           break;
        }
        return 0;
    }

    Int8 Mymin_max_dgray(Mat matIn,double *min,double *max,L_Point *minLoc,L_Point *maxLoc)
    {
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        double d_min,d_max;
        cv::Mat cvimgIn;
        cv::Mat cvRoi;
        cv::Point minpoint,maxpoint;

        if(nWidth*nHeight<=0)
            return 1;

        switch(matIn._type)
        {
            case CCV_8UC1:
            case CCV_8SC1:
            case CCV_16UC1:
            case CCV_16SC1:
            case CCV_32SC1:
            case CCV_32FC1:
            case CCV_64FC1:
                MatToCvMat(matIn,&cvimgIn);
                cvRoi=cvimgIn(cv::Rect(nStartX,nStartY,nWidth,nHeight));
                cv::minMaxLoc(cvRoi,&d_min,&d_max,&minpoint,&maxpoint);
                maxLoc->x=maxpoint.x+nStartX;
                maxLoc->y=maxpoint.y+nStartY;
                minLoc->x=minpoint.x+nStartX;
                minLoc->y=minpoint.y+nStartY;
                *min=d_min;
                *max=d_max;
           break;
           default:
                return 1;
           break;
        }
        return 0;
    }

    Int8 Mymin_max_dgray_mask(Mat matIn,double *min,double *max,L_Point *minLoc,L_Point *maxLoc,Mat mask)
    {
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        double d_min,d_max;
        cv::Mat cv_mask;
        cv::Mat cvimgIn;
        cv::Mat cvRoi,cvRoi_mask;
        cv::Point minpoint,maxpoint;

        if(nWidth*nHeight<=0)
            return 1;
        if(0!=judgeMaskSize(matIn,mask))
            return 2;
        MatToCvMat(mask,&cv_mask);
        cvRoi_mask=cv_mask(cv::Rect(nStartX,nStartY,nWidth,nHeight));
        if(0==cv::countNonZero(cvRoi_mask))
            return 3;
        switch(matIn._type)
        {
            case CCV_8UC1:
            case CCV_8SC1:
            case CCV_16UC1:
            case CCV_16SC1:
            case CCV_32SC1:
            case CCV_32FC1:
            case CCV_64FC1:
                MatToCvMat(matIn,&cvimgIn);
                cvRoi=cvimgIn(cv::Rect(nStartX,nStartY,nWidth,nHeight));
                cv::minMaxLoc(cvRoi,&d_min,&d_max,&minpoint,&maxpoint,cvRoi_mask);
                maxLoc->x=maxpoint.x+nStartX;
                maxLoc->y=maxpoint.y+nStartY;
                minLoc->x=minpoint.x+nStartX;
                minLoc->y=minpoint.y+nStartY;
                *min=d_min;
                *max=d_max;
           break;
           default:
                return 1;
           break;
        }
        return 0;
    }

    Int8 Mybinary(Mat matIn,Mat *matOut,binarymod Mod,double color,double value1,double value2)
    {
        Int32 nnWidth=matIn.nWidth;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        Int32 num=nWidth*nHeight;
        Int32 i,j;
        Int32 i32_value1=(Int32)(value1+0.5);
        Int32 i32_value2=(Int32)(value2+0.5);
        Int32 i32_color=(Int32)(color+0.5);
        Int32 sun;
        Int32 i32_tempvalue;
        float max = 0;//
        float wk=0;//点数占图像比例
        float u=0,uk=0;//平均灰度
        Uint16 t;
        Mat matIntemp;
        Mat matOuttemp;

        matOut->nWidth=matIn.nWidth;
        matOut->nHeight=matIn.nHeight;
        matOut->startx=matIn.startx;
        matOut->starty=matIn.starty;
        matOut->width=matIn.width;
        matOut->height=matIn.height;

        if(matIn.data==matOut->data)
        {
            switch(matIn._type)
            {
                case CCV_8UC1:
                break;
                default:
                    return 1;
                break;
            }
            matIntemp=MatCreatClone(matIn,(Uint8*)u8_buffer_x1Temp6);
        }
        else
        {
            matIntemp=matIn;
        }
        MyconvertTo(matOut,CCV_8UC1);
        MatSet1col(matOut,0);
        if(i32_color>255)
            i32_color=255;
        if(i32_color<0)
            i32_color=0;
        switch(matIntemp._type)
        {
            case CCV_8UC1:
                switch(Mod)
                {
                    case MHC_BARINY_VALUE:
                        if(i32_value1>255)
                            i32_value1=255;
                        if(i32_value1<0)
                            i32_value1=0;
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            for(i=nStartX;i<nStartX+nWidth;i++)
                            {
                                if(matIntemp.ptr_uchar[j*nnWidth+i]>=i32_value1)
                                {
                                    matOut->ptr_uchar[j*nnWidth+i]=i32_color;
                                }
                            }
                        }
                    break;
                    case MHC_BARINY_VALUE_INV:
                        if(i32_value1>255)
                            i32_value1=255;
                        if(i32_value1<0)
                            i32_value1=0;
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            for(i=nStartX;i<nStartX+nWidth;i++)
                            {
                                if(matIntemp.ptr_uchar[j*nnWidth+i]<i32_value1)
                                {
                                    matOut->ptr_uchar[j*nnWidth+i]=i32_color;
                                }
                            }
                        }
                    break;
                    case MHC_BARINY_VALUE_IMG:
                        i32_value1=i32_value1-1;
                        if(i32_value1>255)
                            i32_value1=255;
                        if(i32_value1<0)
                            i32_value1=0;
                        IMG_thr_le2min_8(&matIntemp.ptr_uchar[nStartY*nnWidth],&matOut->ptr_uchar[nStartY*nnWidth],nnWidth,nHeight,i32_value1);
                        if(nStartX!=0)
                        {
                            for(j=nStartY;j<nStartY+nHeight;j++)
                            {
                                memset(&matOut->ptr_uchar[j*nnWidth],0,nStartX);
                            }
                        }
                        if(nStartX+nWidth!=nnWidth)
                        {
                            for(j=nStartY;j<nStartY+nHeight;j++)
                            {
                                memset(&matOut->ptr_uchar[j*nnWidth+nStartX+nWidth],0,nnWidth-(nStartX+nWidth));
                            }
                        }
                    break;
                    case MHC_BARINY_VALUE_INSIZE:
                        if(i32_value1>255)
                            i32_value1=255;
                        if(i32_value1<0)
                            i32_value1=0;
                        if(i32_value2>255)
                            i32_value2=255;
                        if(i32_value2<0)
                            i32_value2=0;
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            for(i=nStartX;i<nStartX+nWidth;i++)
                            {
                                if(matIntemp.ptr_uchar[j*nnWidth+i]>=i32_value1&&matIntemp.ptr_uchar[j*nnWidth+i]<i32_value2)
                                {
                                    matOut->ptr_uchar[j*nnWidth+i]=i32_color;
                                }
                                else
                                {
                                    matOut->ptr_uchar[j*nnWidth+i]=0;
                                }
                            }
                        }
                    break;
                    case MHC_BARINY_VALUE_INSIZE_INV:
                        if(i32_value1>255)
                            i32_value1=255;
                        if(i32_value1<0)
                            i32_value1=0;
                        if(i32_value2>255)
                            i32_value2=255;
                        if(i32_value2<0)
                            i32_value2=0;
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            for(i=nStartX;i<nStartX+nWidth;i++)
                            {
                                if(matIntemp.ptr_uchar[j*nnWidth+i]>=i32_value1&&matIntemp.ptr_uchar[j*nnWidth+i]<i32_value2)
                                {
                                    matOut->ptr_uchar[j*nnWidth+i]=0;
                                }
                                else
                                {
                                    matOut->ptr_uchar[j*nnWidth+i]=i32_color;
                                }
                            }
                        }
                    break;
                    case MHC_BARINY_MEAN:
                        sun=0;
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            for(i=nStartX;i<nStartX+nWidth;i++)
                            {
                                sun=sun+matIntemp.ptr_uchar[j*nnWidth+i];
                            }
                        }
                        sun=sun/(nWidth*nHeight);
                        i32_tempvalue=sun+i32_value1;
                        if(i32_tempvalue>255)
                            i32_tempvalue=255;
                        if(i32_tempvalue<0)
                            i32_tempvalue=0;
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            for(i=nStartX;i<nStartX+nWidth;i++)
                            {
                                if(matIntemp.ptr_uchar[j*nnWidth+i]>=i32_tempvalue)
                                {
                                    matOut->ptr_uchar[j*nnWidth+i]=i32_color;
                                }
                            }
                        }
                    break;
                    case MHC_BARINY_MEAN_INV:
                        sun=0;
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            for(i=nStartX;i<nStartX+nWidth;i++)
                            {
                                sun=sun+matIntemp.ptr_uchar[j*nnWidth+i];
                            }
                        }
                        sun=sun/(nWidth*nHeight);
                        i32_tempvalue=sun+i32_value1;
                        if(i32_tempvalue>255)
                            i32_tempvalue=255;
                        if(i32_tempvalue<0)
                            i32_tempvalue=0;
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            for(i=nStartX;i<nStartX+nWidth;i++)
                            {
                                if(matIntemp.ptr_uchar[j*nnWidth+i]<i32_tempvalue)
                                {
                                    matOut->ptr_uchar[j*nnWidth+i]=i32_color;
                                }
                                else
                                {
                                    matOut->ptr_uchar[j*nnWidth+i]=0;
                                }
                            }
                        }
                    break;
                    case MHC_BARINY_MEAN_IMG:
                        sun=0;
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            for(i=nStartX;i<nStartX+nWidth;i++)
                            {
                                sun=sun+matIntemp.ptr_uchar[j*nnWidth+i];
                            }
                        }
                        sun=sun/(nWidth*nHeight);
                        i32_tempvalue=sun+i32_value1;
                        i32_tempvalue=i32_tempvalue-1;
                        if(i32_tempvalue>255)
                            i32_tempvalue=255;
                        if(i32_tempvalue<0)
                            i32_tempvalue=0;
                        IMG_thr_le2min_8(&matIntemp.ptr_uchar[nStartY*nnWidth],&matOut->ptr_uchar[nStartY*nnWidth],nnWidth,nHeight,i32_tempvalue);
                        if(nStartX!=0)
                        {
                            for(j=nStartY;j<nStartY+nHeight;j++)
                            {
                                memset(&matOut->ptr_uchar[j*nnWidth],0,nStartX);
                            }
                        }
                        if(nStartX+nWidth!=nnWidth)
                        {
                            for(j=nStartY;j<nStartY+nHeight;j++)
                            {
                                memset(&matOut->ptr_uchar[j*nnWidth+nStartX+nWidth],0,nnWidth-(nStartX+nWidth));
                            }
                        }
                    break;
                    case MHC_BARINY_MEAN_C:
                        if(i32_value1>255)
                            i32_value1=255;
                        if(i32_value1<0)
                            i32_value1=0;
                        matOuttemp=MatCreat(matIntemp.nHeight,matIntemp.nWidth,CCV_8UC1,u8_buffer_x3Temp1);
                        Mymean(matIntemp,&matOuttemp,i32_value2,i32_value2);
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            for(i=nStartX;i<nStartX+nWidth;i++)
                            {
                                if(matIntemp.ptr_uchar[j*nnWidth+i]>=matOuttemp.ptr_uchar[j*nnWidth+i]+i32_value1)
                                {
                                    matOut->ptr_uchar[j*nnWidth+i]=i32_color;
                                }
                            }
                        }
                    break;
                    case MHC_BARINY_MEAN_C_INV:
                        if(i32_value1>255)
                            i32_value1=255;
                        if(i32_value1<0)
                            i32_value1=0;
                        matOuttemp=MatCreat(matIntemp.nHeight,matIntemp.nWidth,CCV_8UC1,u8_buffer_x3Temp1);
                        Mymean(matIntemp,&matOuttemp,i32_value2,i32_value2);
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            for(i=nStartX;i<nStartX+nWidth;i++)
                            {
                                if(matIntemp.ptr_uchar[j*nnWidth+i]<matOuttemp.ptr_uchar[j*nnWidth+i]+i32_value1)
                                {
                                    matOut->ptr_uchar[j*nnWidth+i]=i32_color;
                                }
                            }
                        }
                    break;
                    case MHC_BARINY_MEAN_C_IMG:
                        if(i32_value1>255)
                            i32_value1=255;
                        if(i32_value1<0)
                            i32_value1=0;
                        matOuttemp=MatCreat(matIntemp.nHeight,matIntemp.nWidth,CCV_8UC1,u8_buffer_x3Temp1);
                        Mymean(matIntemp,&matOuttemp,i32_value2,i32_value2);
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            for(i=nStartX;i<nStartX+nWidth;i++)
                            {
                                if(matIntemp.ptr_uchar[j*nnWidth+i]>=matOuttemp.ptr_uchar[j*nnWidth+i]+i32_value1)
                                {
                                    matOut->ptr_uchar[j*nnWidth+i]=matIntemp.ptr_uchar[j*nnWidth+i];
                                }
                            }
                        }
                    break;
                    case MHC_BARINY_OTSU:
                        Myhistogram(matIntemp,CV_hist);
                        for(t=0;t<256;t++)
                        {
                            CV_pp[t] = (float)CV_hist[t]/num;
                            u += t*CV_pp[t];
                        }
                        for(t=0;t<256;t++)
                        {
                            wk += CV_pp[t];
                            uk += t*CV_pp[t];
                            if(wk == 0 || wk == 1)
                                CV_g[t] = 0;
                            else
                                CV_g[t] = (u*wk - uk)*(u*wk - uk)/(wk*(1-wk));
                        }
                        sun=255;
                        for(t=0;t<256;t++)
                        {
                            if(max < CV_g[t])
                            {
                                max = CV_g[t];
                                sun = t;
                            }
                        }
                        i32_tempvalue=sun+i32_value1;
                        if(i32_tempvalue>255)
                            i32_tempvalue=255;
                        if(i32_tempvalue<0)
                            i32_tempvalue=0;
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            for(i=nStartX;i<nStartX+nWidth;i++)
                            {
                                if(matIntemp.ptr_uchar[j*nnWidth+i]>=i32_tempvalue)
                                {
                                    matOut->ptr_uchar[j*nnWidth+i]=i32_color;
                                }
                            }
                        }
                    break;
                    case MHC_BARINY_OTSU_INV:
                        Myhistogram(matIntemp,CV_hist);
                        for(t=0;t<256;t++)
                        {
                            CV_pp[t] = (float)CV_hist[t]/num;
                            u += t*CV_pp[t];
                        }
                        for(t=0;t<256;t++)
                        {
                            wk += CV_pp[t];
                            uk += t*CV_pp[t];
                            if(wk == 0 || wk == 1)
                                CV_g[t] = 0;
                            else
                                CV_g[t] = (u*wk - uk)*(u*wk - uk)/(wk*(1-wk));
                        }
                        sun=255;
                        for(t=0;t<256;t++)
                        {
                            if(max < CV_g[t])
                            {
                                max = CV_g[t];
                                sun = t;
                            }
                        }
                        i32_tempvalue=sun+i32_value1;
                        if(i32_tempvalue>255)
                            i32_tempvalue=255;
                        if(i32_tempvalue<0)
                            i32_tempvalue=0;
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            for(i=nStartX;i<nStartX+nWidth;i++)
                            {
                                if(matIntemp.ptr_uchar[j*nnWidth+i]<i32_tempvalue)
                                {
                                    matOut->ptr_uchar[j*nnWidth+i]=i32_color;
                                }
                            }
                        }
                    break;
                    case MHC_BARINY_OTSU_IMG:
                        Myhistogram(matIntemp,CV_hist);
                        for(t=0;t<256;t++)
                        {
                            CV_pp[t] = (float)CV_hist[t]/num;
                            u += t*CV_pp[t];
                        }
                        for(t=0;t<256;t++)
                        {
                            wk += CV_pp[t];
                            uk += t*CV_pp[t];
                            if(wk == 0 || wk == 1)
                                CV_g[t] = 0;
                            else
                                CV_g[t] = (u*wk - uk)*(u*wk - uk)/(wk*(1-wk));
                        }
                        sun=255;
                        for(t=0;t<256;t++)
                        {
                            if(max < CV_g[t])
                            {
                                max = CV_g[t];
                                sun = t;
                            }
                        }
                        i32_tempvalue=sun+i32_value1;
                        i32_tempvalue=i32_tempvalue-1;
                        if(i32_tempvalue>255)
                            i32_tempvalue=255;
                        if(i32_tempvalue<0)
                            i32_tempvalue=0;
                        IMG_thr_le2min_8(&matIntemp.ptr_uchar[nStartY*nnWidth],&matOut->ptr_uchar[nStartY*nnWidth],nnWidth,nHeight,i32_tempvalue);
                        if(nStartX!=0)
                        {
                            for(j=nStartY;j<nStartY+nHeight;j++)
                            {
                                memset(&matOut->ptr_uchar[j*nnWidth],0,nStartX);
                            }
                        }
                        if(nStartX+nWidth!=nnWidth)
                        {
                            for(j=nStartY;j<nStartY+nHeight;j++)
                            {
                                memset(&matOut->ptr_uchar[j*nnWidth+nStartX+nWidth],0,nnWidth-(nStartX+nWidth));
                            }
                        }
                    break;
                    default:
                        return 1;
                    break;
                }
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 Mybinaryself(Mat *matIn_Out,binarymod Mod,double color,double value1,double value2)
    {
        Int32 nnWidth=matIn_Out->nWidth;
        Int32 nStartX=matIn_Out->startx;
        Int32 nStartY=matIn_Out->starty;
        Int32 nWidth=matIn_Out->width;
        Int32 nHeight=matIn_Out->height;
        Int32 num=nWidth*nHeight;
        Int32 i,j;
        Int32 i32_value1=(Int32)(value1+0.5);
        Int32 i32_value2=(Int32)(value2+0.5);
        Int32 i32_color=(Int32)(color+0.5);
        Int32 sun;
        Int32 i32_tempvalue;
        float max = 0;
        float wk=0;
        float u=0,uk=0;
        Uint16 t;
        Mat matOuttemp;

        if(i32_color>255)
            i32_color=255;
        if(i32_color<0)
            i32_color=0;
        switch(matIn_Out->_type)
        {
            case CCV_8UC1:
                switch(Mod)
                {
                    case MHC_BARINY_VALUE:
                        if(i32_value1>255)
                            i32_value1=255;
                        if(i32_value1<0)
                            i32_value1=0;
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            for(i=nStartX;i<nStartX+nWidth;i++)
                            {
                                if(matIn_Out->ptr_uchar[j*nnWidth+i]>=i32_value1)
                                {
                                    matIn_Out->ptr_uchar[j*nnWidth+i]=i32_color;
                                }
                                else
                                {
                                    matIn_Out->ptr_uchar[j*nnWidth+i]=0;
                                }
                            }
                        }
                    break;
                    case MHC_BARINY_VALUE_INV:
                        if(i32_value1>255)
                            i32_value1=255;
                        if(i32_value1<0)
                            i32_value1=0;
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            for(i=nStartX;i<nStartX+nWidth;i++)
                            {
                                if(matIn_Out->ptr_uchar[j*nnWidth+i]<i32_value1)
                                {
                                    matIn_Out->ptr_uchar[j*nnWidth+i]=i32_color;
                                }
                                else
                                {
                                    matIn_Out->ptr_uchar[j*nnWidth+i]=0;
                                }
                            }
                        }
                    break;
                    case MHC_BARINY_VALUE_IMG:
                        i32_value1=i32_value1-1;
                        if(i32_value1>255)
                            i32_value1=255;
                        if(i32_value1<0)
                            i32_value1=0;
                        IMG_thr_le2min_8(&matIn_Out->ptr_uchar[nStartY*nnWidth],&matIn_Out->ptr_uchar[nStartY*nnWidth],nnWidth,nHeight,i32_value1);
                        if(nStartX!=0)
                        {
                            for(j=nStartY;j<nStartY+nHeight;j++)
                            {
                                memset(&matIn_Out->ptr_uchar[j*nnWidth],0,nStartX);
                            }
                        }
                        if(nStartX+nWidth!=nnWidth)
                        {
                            for(j=nStartY;j<nStartY+nHeight;j++)
                            {
                                memset(&matIn_Out->ptr_uchar[j*nnWidth+nStartX+nWidth],0,nnWidth-(nStartX+nWidth));
                            }
                        }
                    break;
                    case MHC_BARINY_VALUE_INSIZE:
                        if(i32_value1>255)
                            i32_value1=255;
                        if(i32_value1<0)
                            i32_value1=0;
                        if(i32_value2>255)
                            i32_value2=255;
                        if(i32_value2<0)
                            i32_value2=0;
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            for(i=nStartX;i<nStartX+nWidth;i++)
                            {
                                if(matIn_Out->ptr_uchar[j*nnWidth+i]>=i32_value1&&matIn_Out->ptr_uchar[j*nnWidth+i]<i32_value2)
                                {
                                    matIn_Out->ptr_uchar[j*nnWidth+i]=i32_color;
                                }
                                else
                                {
                                    matIn_Out->ptr_uchar[j*nnWidth+i]=0;
                                }
                            }
                        }
                    break;
                    case MHC_BARINY_VALUE_INSIZE_INV:
                        if(i32_value1>255)
                            i32_value1=255;
                        if(i32_value1<0)
                            i32_value1=0;
                        if(i32_value2>255)
                            i32_value2=255;
                        if(i32_value2<0)
                            i32_value2=0;
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            for(i=nStartX;i<nStartX+nWidth;i++)
                            {
                                if(matIn_Out->ptr_uchar[j*nnWidth+i]>=i32_value1&&matIn_Out->ptr_uchar[j*nnWidth+i]<i32_value2)
                                {
                                    matIn_Out->ptr_uchar[j*nnWidth+i]=0;
                                }
                                else
                                {
                                    matIn_Out->ptr_uchar[j*nnWidth+i]=i32_color;
                                }
                            }
                        }
                    break;
                    case MHC_BARINY_MEAN:
                        sun=0;
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            for(i=nStartX;i<nStartX+nWidth;i++)
                            {
                                sun=sun+matIn_Out->ptr_uchar[j*nnWidth+i];
                            }
                        }
                        sun=sun/(nWidth*nHeight);
                        i32_tempvalue=sun+i32_value1;
                        if(i32_tempvalue>255)
                            i32_tempvalue=255;
                        if(i32_tempvalue<0)
                            i32_tempvalue=0;
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            for(i=nStartX;i<nStartX+nWidth;i++)
                            {
                                if(matIn_Out->ptr_uchar[j*nnWidth+i]>=i32_tempvalue)
                                {
                                    matIn_Out->ptr_uchar[j*nnWidth+i]=i32_color;
                                }
                            }
                        }
                    break;
                    case MHC_BARINY_MEAN_INV:
                        sun=0;
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            for(i=nStartX;i<nStartX+nWidth;i++)
                            {
                                sun=sun+matIn_Out->ptr_uchar[j*nnWidth+i];
                            }
                        }
                        sun=sun/(nWidth*nHeight);
                        i32_tempvalue=sun+i32_value1;
                        if(i32_tempvalue>255)
                            i32_tempvalue=255;
                        if(i32_tempvalue<0)
                            i32_tempvalue=0;
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            for(i=nStartX;i<nStartX+nWidth;i++)
                            {
                                if(matIn_Out->ptr_uchar[j*nnWidth+i]<i32_tempvalue)
                                {
                                    matIn_Out->ptr_uchar[j*nnWidth+i]=i32_color;
                                }
                            }
                        }
                    break;
                    case MHC_BARINY_MEAN_IMG:
                        sun=0;
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            for(i=nStartX;i<nStartX+nWidth;i++)
                            {
                                sun=sun+matIn_Out->ptr_uchar[j*nnWidth+i];
                            }
                        }
                        sun=sun/(nWidth*nHeight);
                        i32_tempvalue=sun+i32_value1;
                        i32_tempvalue=i32_tempvalue-1;
                        if(i32_tempvalue>255)
                            i32_tempvalue=255;
                        if(i32_tempvalue<0)
                            i32_tempvalue=0;
                        IMG_thr_le2min_8(&matIn_Out->ptr_uchar[nStartY*nnWidth],&matIn_Out->ptr_uchar[nStartY*nnWidth],nnWidth,nHeight,i32_tempvalue);
                        if(nStartX!=0)
                        {
                            for(j=nStartY;j<nStartY+nHeight;j++)
                            {
                                memset(&matIn_Out->ptr_uchar[j*nnWidth],0,nStartX);
                            }
                        }
                        if(nStartX+nWidth!=nnWidth)
                        {
                            for(j=nStartY;j<nStartY+nHeight;j++)
                            {
                                memset(&matIn_Out->ptr_uchar[j*nnWidth+nStartX+nWidth],0,nnWidth-(nStartX+nWidth));
                            }
                        }
                    break;
                    case MHC_BARINY_MEAN_C:
                        if(i32_value1>255)
                            i32_value1=255;
                        if(i32_value1<0)
                            i32_value1=0;
                        matOuttemp=MatCreat(matIn_Out->nHeight,matIn_Out->nWidth,CCV_8UC1,u8_buffer_x3Temp1);
                        Mymean(*matIn_Out,&matOuttemp,i32_value2,i32_value2);
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            for(i=nStartX;i<nStartX+nWidth;i++)
                            {
                                if(matIn_Out->ptr_uchar[j*nnWidth+i]>=matOuttemp.ptr_uchar[j*nnWidth+i]+i32_value1)
                                {
                                    matIn_Out->ptr_uchar[j*nnWidth+i]=i32_color;
                                }
                                else
                                {
                                    matIn_Out->ptr_uchar[j*nnWidth+i]=0;
                                }
                            }
                        }
                    break;
                    case MHC_BARINY_MEAN_C_INV:
                        if(i32_value1>255)
                            i32_value1=255;
                        if(i32_value1<0)
                            i32_value1=0;
                        matOuttemp=MatCreat(matIn_Out->nHeight,matIn_Out->nWidth,CCV_8UC1,u8_buffer_x3Temp1);
                        Mymean(*matIn_Out,&matOuttemp,i32_value2,i32_value2);
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            for(i=nStartX;i<nStartX+nWidth;i++)
                            {
                                if(matIn_Out->ptr_uchar[j*nnWidth+i]<matOuttemp.ptr_uchar[j*nnWidth+i]+i32_value1)
                                {
                                    matIn_Out->ptr_uchar[j*nnWidth+i]=i32_color;
                                }
                                else
                                {
                                    matIn_Out->ptr_uchar[j*nnWidth+i]=0;
                                }
                            }
                        }
                    break;
                    case MHC_BARINY_MEAN_C_IMG:
                        if(i32_value1>255)
                            i32_value1=255;
                        if(i32_value1<0)
                            i32_value1=0;
                        matOuttemp=MatCreat(matIn_Out->nHeight,matIn_Out->nWidth,CCV_8UC1,u8_buffer_x3Temp1);
                        Mymean(*matIn_Out,&matOuttemp,i32_value2,i32_value2);
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            for(i=nStartX;i<nStartX+nWidth;i++)
                            {
                                if(matIn_Out->ptr_uchar[j*nnWidth+i]<matOuttemp.ptr_uchar[j*nnWidth+i]+i32_value1)
                                {
                                    matIn_Out->ptr_uchar[j*nnWidth+i]=0;
                                }
                            }
                        }
                    break;
                    case MHC_BARINY_OTSU:
                        Myhistogram(*matIn_Out,CV_hist);
                        for(t=0;t<256;t++)
                        {
                            CV_pp[t] = (float)CV_hist[t]/num;
                            u += t*CV_pp[t];
                        }
                        for(t=0;t<256;t++)
                        {
                            wk += CV_pp[t];
                            uk += t*CV_pp[t];
                            if(wk == 0 || wk == 1)
                                CV_g[t] = 0;
                            else
                                CV_g[t] = (u*wk - uk)*(u*wk - uk)/(wk*(1-wk));
                        }
                        sun=255;
                        for(t=0;t<256;t++)
                        {
                            if(max < CV_g[t])
                            {
                                max = CV_g[t];
                                sun = t;
                            }
                        }
                        i32_tempvalue=sun+i32_value1;
                        if(i32_tempvalue>255)
                            i32_tempvalue=255;
                        if(i32_tempvalue<0)
                            i32_tempvalue=0;
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            for(i=nStartX;i<nStartX+nWidth;i++)
                            {
                                if(matIn_Out->ptr_uchar[j*nnWidth+i]>=i32_tempvalue)
                                {
                                    matIn_Out->ptr_uchar[j*nnWidth+i]=i32_color;
                                }
                            }
                        }
                    break;
                    case MHC_BARINY_OTSU_INV:
                        Myhistogram(*matIn_Out,CV_hist);
                        for(t=0;t<256;t++)
                        {
                            CV_pp[t] = (float)CV_hist[t]/num;
                            u += t*CV_pp[t];
                        }
                        for(t=0;t<256;t++)
                        {
                            wk += CV_pp[t];
                            uk += t*CV_pp[t];
                            if(wk == 0 || wk == 1)
                                CV_g[t] = 0;
                            else
                                CV_g[t] = (u*wk - uk)*(u*wk - uk)/(wk*(1-wk));
                        }
                        sun=255;
                        for(t=0;t<256;t++)
                        {
                            if(max < CV_g[t])
                            {
                                max = CV_g[t];
                                sun = t;
                            }
                        }
                        i32_tempvalue=sun+i32_value1;
                        if(i32_tempvalue>255)
                            i32_tempvalue=255;
                        if(i32_tempvalue<0)
                            i32_tempvalue=0;
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            for(i=nStartX;i<nStartX+nWidth;i++)
                            {
                                if(matIn_Out->ptr_uchar[j*nnWidth+i]<i32_tempvalue)
                                {
                                    matIn_Out->ptr_uchar[j*nnWidth+i]=i32_color;
                                }
                            }
                        }
                    break;
                    case MHC_BARINY_OTSU_IMG:
                        Myhistogram(*matIn_Out,CV_hist);
                        for(t=0;t<256;t++)
                        {
                            CV_pp[t] = (float)CV_hist[t]/num;
                            u += t*CV_pp[t];
                        }
                        for(t=0;t<256;t++)
                        {
                            wk += CV_pp[t];
                            uk += t*CV_pp[t];
                            if(wk == 0 || wk == 1)
                                CV_g[t] = 0;
                            else
                                CV_g[t] = (u*wk - uk)*(u*wk - uk)/(wk*(1-wk));
                        }
                        sun=255;
                        for(t=0;t<256;t++)
                        {
                            if(max < CV_g[t])
                            {
                                max = CV_g[t];
                                sun = t;
                            }
                        }
                        i32_tempvalue=sun+i32_value1;
                        i32_tempvalue=i32_tempvalue-1;
                        if(i32_tempvalue>255)
                            i32_tempvalue=255;
                        if(i32_tempvalue<0)
                            i32_tempvalue=0;
                        IMG_thr_le2min_8(&matIn_Out->ptr_uchar[nStartY*nnWidth],&matIn_Out->ptr_uchar[nStartY*nnWidth],nnWidth,nHeight,i32_tempvalue);
                        if(nStartX!=0)
                        {
                            for(j=nStartY;j<nStartY+nHeight;j++)
                            {
                                memset(&matIn_Out->ptr_uchar[j*nnWidth],0,nStartX);
                            }
                        }
                        if(nStartX+nWidth!=nnWidth)
                        {
                            for(j=nStartY;j<nStartY+nHeight;j++)
                            {
                                memset(&matIn_Out->ptr_uchar[j*nnWidth+nStartX+nWidth],0,nnWidth-(nStartX+nWidth));
                            }
                        }
                    break;
                    default:
                        return 1;
                    break;
                }
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 Mybinaryval(Mat matIn,Uint8 *valueOut,binaryvalmod Mod)
    {
        Int32 nnWidth=matIn.nWidth;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        Int32 num=nWidth*nHeight;
        Int32 i,j;
        Int32 sun;
        float max = 0;
        float wk=0;
        float u=0,uk=0;
        Uint16 t;

        switch(matIn._type)
        {
            case CCV_8UC1:
                switch(Mod)
                {
                    case MHC_BARINYVAL_MEAN:
                        sun=0;
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            for(i=nStartX;i<nStartX+nWidth;i++)
                            {
                                sun=sun+matIn.ptr_uchar[j*nnWidth+i];
                            }
                        }
                        sun=sun/(nWidth*nHeight);
                        *valueOut=(Uint8)sun;
                    break;
                    case MHC_BARINYVAL_OTSU:
                        Myhistogram(matIn,CV_hist);
                        for(t=0;t<256;t++)
                        {
                            CV_pp[t] = (float)CV_hist[t]/num;
                            u += t*CV_pp[t];
                        }
                        for(t=0;t<256;t++)
                        {
                            wk += CV_pp[t];
                            uk += t*CV_pp[t];
                            if(wk == 0 || wk == 1)
                                CV_g[t] = 0;
                            else
                                CV_g[t] = (u*wk - uk)*(u*wk - uk)/(wk*(1-wk));
                        }
                        sun=255;
                        for(t=0;t<256;t++)
                        {
                            if(max < CV_g[t])
                            {
                                max = CV_g[t];
                                sun = t;
                            }
                        }
                        *valueOut=(Uint8)sun;
                    default:
                        return 1;
                    break;
                }
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 Mybinaryval_mask(Mat matIn,Mat mask,Uint8 *valueOut,binaryvalmod Mod)
    {
        Uint32 nnWidth=matIn.nWidth;
        Uint32 nStartX=matIn.startx;
        Uint32 nStartY=matIn.starty;
        Uint32 nWidth=matIn.width;
        Uint32 nHeight=matIn.height;
        Int32 num=0;
        Int32 i,j;
        Int32 sun;
        float max = 0;
        float wk=0;
        float u=0,uk=0;
        Uint16 t;

        if(0!=judgeMaskSize(matIn,mask))//掩膜不匹配
            return 1;

        switch(matIn._type)
        {
            case CCV_8UC1:
                switch(Mod)
                {
                    case MHC_BARINYVAL_MEAN:
                        sun=0;
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            for(i=nStartX;i<nStartX+nWidth;i++)
                            {
                                if(mask.ptr_uchar[j*nnWidth+i]!=0)
                                {
                                    sun=sun+matIn.ptr_uchar[j*nnWidth+i];
                                    num++;
                                }
                            }
                        }
                        if(num==0)
                            return 1;
                        sun=sun/num;
                        *valueOut=(Uint8)sun;
                    break;
                    case MHC_BARINYVAL_OTSU:
                        memset(CV_hist, 0, sizeof(CV_hist));
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            for(i=nStartX;i<nStartX+nWidth;i++)
                            {
                                if(mask.ptr_uchar[j*nnWidth+i]!=0)
                                {
                                    CV_hist[matIn.ptr_uchar[j*nnWidth+i]]++;
                                    num ++;
                                }
                            }
                        }
                        if(num==0)
                            return 1;
                        for(t=0;t<256;t++)
                        {
                            CV_pp[t] = (float)CV_hist[t]/num;
                            u += t*CV_pp[t];
                        }
                        for(t=0;t<256;t++)
                        {
                            wk += CV_pp[t];
                            uk += t*CV_pp[t];
                            if(wk == 0 || wk == 1)
                                CV_g[t] = 0;
                            else
                                CV_g[t] = (u*wk - uk)*(u*wk - uk)/(wk*(1-wk));
                        }
                        sun=255;
                        for(t=0;t<256;t++)
                        {
                            if(max < CV_g[t])
                            {
                                max = CV_g[t];
                                sun = t;
                            }
                        }
                        *valueOut=(Uint8)sun;
                    default:
                        return 1;
                    break;
                }
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 MygetMaxLine(Mat matIn,Int32 size,Int32 *valout)
    {
        Int32 *zoom=(Int32*)u8_buffer_x3Temp1;
        Int32 x,y;
        Uint32 tempsun,MAXy,MAXsun;
        Uint32 SIZE=size;
        Int32 nnHeight=matIn.nHeight;
        Int32 nnWidth=matIn.nWidth;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;

        switch(matIn._type)
        {
            case CCV_8UC1:
                memset(zoom, 0x00, nnHeight*sizeof(Int32));
                for (y = nStartY; y < nStartY + nHeight; y ++)
                {
                    for (x = nStartX; x < nStartX + nWidth; x ++)
                    {
                        zoom[y]=zoom[y]+matIn.data[y * nnWidth + x];
                    }
                }
                tempsun=0;
                for(y=nStartY;y<nStartY+SIZE*2;y++)
                {
                    tempsun=tempsun+zoom[y];
                }
                MAXsun=tempsun;
                MAXy=y-SIZE;
                while(y<nStartY + nHeight)
                {
                    tempsun=tempsun-zoom[y-SIZE*2]+zoom[y];
                    if(MAXsun<tempsun)
                    {
                        MAXsun=tempsun;
                        MAXy=y-SIZE;
                    }
                    y++;
                }
                *valout=MAXy;
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 MygetMaxRow(Mat matIn,Int32 size,Int32 *valout)
    {
        Int32 *zoom=(Int32*)u8_buffer_x3Temp1;
        Int32 x,y;
        Uint32 tempsun,MAXx,MAXsun;
        Uint32 SIZE=size;
        Int32 nnWidth=matIn.nWidth;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;

        switch(matIn._type)
        {
            case CCV_8UC1:
                memset(zoom, 0x00, nnWidth*sizeof(Int32));
                for (x = nStartX; x < nStartX + nWidth; x ++)
                {
                    for (y = nStartY; y < nStartY + nHeight; y ++)
                    {
                        zoom[x]=zoom[x]+matIn.data[y * nnWidth + x];
                    }
                }
                tempsun=0;
                for(x=nStartX;x<nStartX+SIZE*2;x++)
                {
                    tempsun=tempsun+zoom[x];
                }
                MAXsun=tempsun;
                MAXx=x-SIZE;
                while(x<nStartX + nWidth)
                {
                    tempsun=tempsun-zoom[x-SIZE*2]+zoom[x];
                    if(MAXsun<tempsun)
                    {
                        MAXsun=tempsun;
                        MAXx=x-SIZE;
                    }
                    x++;
                }
                *valout=MAXx;
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 MygetbryLine(Mat matIn,Mat *matOut,Int32 num,Int32 size)
    {
        Mat temp;
        Int32 x,y;
        Int32 dy;
        Int32 *zoom=(Int32*)u8_buffer_x1Temp1;
        Uint32 SIZE=size;
        Int32 nnHeight=matIn.nHeight;
        Int32 nnWidth=matIn.nWidth;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;

        matOut->nWidth=matIn.nWidth;
        matOut->nHeight=matIn.nHeight;
        matOut->startx=matIn.startx;
        matOut->starty=matIn.starty;
        matOut->width=matIn.width;
        matOut->height=matIn.height;

        if(matIn.data==matOut->data)
        {
            temp=MatCreatClone(matIn,u8_buffer_x3Temp1);
        }
        else
        {
            temp=matIn;
        }
        MyconvertTo(matOut,matIn._type);
        switch(matIn._type)
        {
            case CCV_8UC1:
                memset(zoom, 0x00, (nnHeight+SIZE*2)*sizeof(Int32));
                for (y = nStartY; y < nStartY + nHeight; y ++)
                {
                    for (x = nStartX; x < nStartX + nWidth; x ++)
                    {
                        if(matIn.data[y * nnWidth + x]!=0)
                        {
                            for(dy=y;dy<=y+SIZE*2;dy++)
                            {
                                zoom[dy]++;
                            }
                        }
                    }
                }
                memset(matOut->data,0,nnHeight*nnWidth);
                for (dy = nStartY+SIZE; dy < nStartY + nHeight + SIZE; dy ++)
                {
                    if(zoom[dy]>num)
                    {
                        memcpy(&matOut->data[(dy-SIZE) * nnWidth+nStartX],&temp.data[(dy-SIZE) * nnWidth+nStartX],nWidth);
                    }
                }
                break;
            default:
                return 1;
            break;
        }

        return 0;
    }

    Int8 MygetbryRow(Mat matIn,Mat *matOut,Int32 num,Int32 size)
    {
        Mat temp;
        Int32 x,y;
        Int32 dx;
        Int32 *zoom=(Int32*)u8_buffer_x1Temp1;
        Int32 SIZE=size;
        Int32 nnHeight=matIn.nHeight;
        Int32 nnWidth=matIn.nWidth;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;

        matOut->nWidth=matIn.nWidth;
        matOut->nHeight=matIn.nHeight;
        matOut->startx=matIn.startx;
        matOut->starty=matIn.starty;
        matOut->width=matIn.width;
        matOut->height=matIn.height;

        if(matIn.data==matOut->data)
        {
            temp=MatCreatClone(matIn,u8_buffer_x3Temp1);
        }
        else
        {
            temp=matIn;
        }
        MyconvertTo(matOut,matIn._type);
        switch(matIn._type)
        {
            case CCV_8UC1:
                memset(zoom, 0x00, (nnWidth+SIZE*2)*sizeof(Int32));
                for (x = nStartX; x < nStartX + nWidth; x ++)
                {
                    for (y = nStartY; y < nStartY + nHeight; y ++)
                    {
                        if(matIn.data[y * nnWidth + x]!=0)
                        {
                            for(dx=x;dx<=x+SIZE*2;dx++)
                            {
                                zoom[dx]++;
                            }
                        }
                    }
                }
                memset(matOut->data,0,nnHeight*nnWidth);
                for(dx = nStartX+SIZE; dx < nStartX + nWidth + SIZE; dx ++)
                {
                    if(zoom[dx]>num)
                    {
                        for(y = nStartY; y < nStartY + nHeight; y ++)
                        {
                            matOut->data[y * nnWidth + dx-SIZE]=temp.data[y * nnWidth + dx-SIZE];
                        }
                    }
                }
                break;
            default:
                return 1;
            break;
        }

        return 0;
    }

    Int8 MyMask_image(Mat *matIn_Out,Mat mask)
    {
        Int32 i,j;
        Int32 nnWidth=matIn_Out->nWidth;
        Int32 nStartX=matIn_Out->startx;
        Int32 nStartY=matIn_Out->starty;
        Int32 nWidth=matIn_Out->width;
        Int32 nHeight=matIn_Out->height;
        if(0!=judgeMaskSize(*matIn_Out,mask))//掩膜不匹配
            return 1;
        switch(matIn_Out->_type)
        {
            case CCV_8UC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(mask.data[j*nnWidth+i]==0)
                        {
                            matIn_Out->ptr_uchar[j*nnWidth+i]=0;
                        }
                    }
                }
            break;
            case CCV_8UC3:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(mask.data[j*nnWidth+i]==0)
                        {
                            matIn_Out->ptr_Vec3b[j*nnWidth+i].data1=0;
                            matIn_Out->ptr_Vec3b[j*nnWidth+i].data2=0;
                            matIn_Out->ptr_Vec3b[j*nnWidth+i].data3=0;
                        }
                    }
                }
            break;
            case CCV_8SC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(mask.data[j*nnWidth+i]==0)
                        {
                            matIn_Out->ptr_char[j*nnWidth+i]=0;
                        }
                    }
                }
            break;
            case CCV_8SC3:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(mask.data[j*nnWidth+i]==0)
                        {
                            matIn_Out->ptr_Vec3ib[j*nnWidth+i].data1=0;
                            matIn_Out->ptr_Vec3ib[j*nnWidth+i].data2=0;
                            matIn_Out->ptr_Vec3ib[j*nnWidth+i].data3=0;
                        }
                    }
                }
            break;
            case CCV_16UC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(mask.data[j*nnWidth+i]==0)
                        {
                            matIn_Out->ptr_ushort[j*nnWidth+i]=0;
                        }
                    }
                }
            break;
            case CCV_16UC3:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(mask.data[j*nnWidth+i]==0)
                        {
                            matIn_Out->ptr_Vec3s[j*nnWidth+i].data1=0;
                            matIn_Out->ptr_Vec3s[j*nnWidth+i].data2=0;
                            matIn_Out->ptr_Vec3s[j*nnWidth+i].data3=0;
                        }
                    }
                }
            break;
            case CCV_16SC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(mask.data[j*nnWidth+i]==0)
                        {
                            matIn_Out->ptr_short[j*nnWidth+i]=0;
                        }
                    }
                }
            break;
            case CCV_16SC3:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(mask.data[j*nnWidth+i]==0)
                        {
                            matIn_Out->ptr_Vec3w[j*nnWidth+i].data1=0;
                            matIn_Out->ptr_Vec3w[j*nnWidth+i].data2=0;
                            matIn_Out->ptr_Vec3w[j*nnWidth+i].data3=0;
                        }
                    }
                }
            break;
            case CCV_32SC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(mask.data[j*nnWidth+i]==0)
                        {
                            matIn_Out->ptr_int[j*nnWidth+i]=0;
                        }
                    }
                }
            break;
            case CCV_32SC3:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(mask.data[j*nnWidth+i]==0)
                        {
                            matIn_Out->ptr_Vec3i[j*nnWidth+i].data1=0;
                            matIn_Out->ptr_Vec3i[j*nnWidth+i].data2=0;
                            matIn_Out->ptr_Vec3i[j*nnWidth+i].data3=0;
                        }
                    }
                }
            break;
            case CCV_32FC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(mask.data[j*nnWidth+i]==0)
                        {
                            matIn_Out->ptr_float[j*nnWidth+i]=0;
                        }
                    }
                }
            break;
            case CCV_32FC3:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(mask.data[j*nnWidth+i]==0)
                        {
                            matIn_Out->ptr_Vec3f[j*nnWidth+i].data1=0;
                            matIn_Out->ptr_Vec3f[j*nnWidth+i].data2=0;
                            matIn_Out->ptr_Vec3f[j*nnWidth+i].data3=0;
                        }
                    }
                }
            break;
            case CCV_64FC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(mask.data[j*nnWidth+i]==0)
                        {
                            matIn_Out->ptr_double[j*nnWidth+i]=0;
                        }
                    }
                }
            break;
            case CCV_64FC3:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(mask.data[j*nnWidth+i]==0)
                        {
                            matIn_Out->ptr_Vec3d[j*nnWidth+i].data1=0;
                            matIn_Out->ptr_Vec3d[j*nnWidth+i].data2=0;
                            matIn_Out->ptr_Vec3d[j*nnWidth+i].data3=0;
                        }
                    }
                }
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 Mymianji_obj(Mat matIn, Int32 *mianji)
    {
        Int32 j,i;
        Int32 nnWidth=matIn.nWidth;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        Int32 i32_mianji=0;
        switch(matIn._type)
        {
            case CCV_8UC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(matIn.ptr_uchar[j*nnWidth+i]!=0)
                        {
                            i32_mianji++;
                        }
                    }
                }
                *mianji=i32_mianji;
                return 0;
            break;
            case CCV_8UC3:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(matIn.ptr_Vec3b[j*nnWidth+i].data1!=0||
                           matIn.ptr_Vec3b[j*nnWidth+i].data2!=0||
                           matIn.ptr_Vec3b[j*nnWidth+i].data3!=0)
                        {
                            i32_mianji++;
                        }
                    }
                }
                *mianji=i32_mianji;
                return 0;
            break;
            case CCV_8SC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(matIn.ptr_char[j*nnWidth+i]!=0)
                        {
                            i32_mianji++;
                        }
                    }
                }
                *mianji=i32_mianji;
                return 0;
            break;
            case CCV_8SC3:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(matIn.ptr_Vec3ib[j*nnWidth+i].data1!=0||
                           matIn.ptr_Vec3ib[j*nnWidth+i].data2!=0||
                           matIn.ptr_Vec3ib[j*nnWidth+i].data3!=0)
                        {
                            i32_mianji++;
                        }
                    }
                }
                *mianji=i32_mianji;
                return 0;
            break;
            case CCV_16UC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(matIn.ptr_ushort[j*nnWidth+i]!=0)
                        {
                            i32_mianji++;
                        }
                    }
                }
                *mianji=i32_mianji;
                return 0;
            break;
            case CCV_16UC3:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(matIn.ptr_Vec3s[j*nnWidth+i].data1!=0||
                           matIn.ptr_Vec3s[j*nnWidth+i].data2!=0||
                           matIn.ptr_Vec3s[j*nnWidth+i].data3!=0)
                        {
                            i32_mianji++;
                        }
                    }
                }
                *mianji=i32_mianji;
                return 0;
            break;
            case CCV_32SC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(matIn.ptr_int[j*nnWidth+i]!=0)
                        {
                            i32_mianji++;
                        }
                    }
                }
                *mianji=i32_mianji;
                return 0;
            break;
            case CCV_32SC3:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(matIn.ptr_Vec3i[j*nnWidth+i].data1!=0||
                           matIn.ptr_Vec3i[j*nnWidth+i].data2!=0||
                           matIn.ptr_Vec3i[j*nnWidth+i].data3!=0)
                        {
                            i32_mianji++;
                        }
                    }
                }
                *mianji=i32_mianji;
                return 0;
            break;
            case CCV_32FC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(matIn.ptr_float[j*nnWidth+i]!=0)
                        {
                            i32_mianji++;
                        }
                    }
                }
                *mianji=i32_mianji;
                return 0;
            break;
            case CCV_32FC3:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(matIn.ptr_Vec3f[j*nnWidth+i].data1!=0||
                           matIn.ptr_Vec3f[j*nnWidth+i].data2!=0||
                           matIn.ptr_Vec3f[j*nnWidth+i].data3!=0)
                        {
                            i32_mianji++;
                        }
                    }
                }
                *mianji=i32_mianji;
                return 0;
            break;
            case CCV_64FC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(matIn.ptr_double[j*nnWidth+i]!=0)
                        {
                            i32_mianji++;
                        }
                    }
                }
                *mianji=i32_mianji;
                return 0;
            break;
            case CCV_64FC3:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(matIn.ptr_Vec3d[j*nnWidth+i].data1!=0||
                           matIn.ptr_Vec3d[j*nnWidth+i].data2!=0||
                           matIn.ptr_Vec3d[j*nnWidth+i].data3!=0)
                        {
                            i32_mianji++;
                        }
                    }
                }
                *mianji=i32_mianji;
                return 0;
            break;
            default:
                return 1;
            break;
        }
    }

    Int8 MyLinenum_obj(Mat matIn,Int32 *line)
    {
        Int32 j,i;
        Int32 nnWidth=matIn.nWidth;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        Int32 i32_mianji=0;
        switch(matIn._type)
        {
            case CCV_8UC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(matIn.ptr_uchar[j*nnWidth+i]!=0)
                        {
                            i32_mianji++;
                            break;
                        }
                    }
                }
                *line=i32_mianji;
                return 0;
            break;
            case CCV_8UC3:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(matIn.ptr_Vec3b[j*nnWidth+i].data1!=0||
                           matIn.ptr_Vec3b[j*nnWidth+i].data2!=0||
                           matIn.ptr_Vec3b[j*nnWidth+i].data3!=0)
                        {
                            i32_mianji++;
                            break;
                        }
                    }
                }
                *line=i32_mianji;
                return 0;
            break;
            case CCV_8SC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(matIn.ptr_char[j*nnWidth+i]!=0)
                        {
                            i32_mianji++;
                            break;
                        }
                    }
                }
                *line=i32_mianji;
                return 0;
            break;
            case CCV_8SC3:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(matIn.ptr_Vec3ib[j*nnWidth+i].data1!=0||
                           matIn.ptr_Vec3ib[j*nnWidth+i].data2!=0||
                           matIn.ptr_Vec3ib[j*nnWidth+i].data3!=0)
                        {
                            i32_mianji++;
                            break;
                        }
                    }
                }
                *line=i32_mianji;
                return 0;
            break;
            case CCV_16UC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(matIn.ptr_ushort[j*nnWidth+i]!=0)
                        {
                            i32_mianji++;
                            break;
                        }
                    }
                }
                *line=i32_mianji;
                return 0;
            break;
            case CCV_16UC3:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(matIn.ptr_Vec3s[j*nnWidth+i].data1!=0||
                           matIn.ptr_Vec3s[j*nnWidth+i].data2!=0||
                           matIn.ptr_Vec3s[j*nnWidth+i].data3!=0)
                        {
                            i32_mianji++;
                            break;
                        }
                    }
                }
                *line=i32_mianji;
                return 0;
            break;
            case CCV_32SC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(matIn.ptr_int[j*nnWidth+i]!=0)
                        {
                            i32_mianji++;
                            break;
                        }
                    }
                }
                *line=i32_mianji;
                return 0;
            break;
            case CCV_32SC3:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(matIn.ptr_Vec3i[j*nnWidth+i].data1!=0||
                           matIn.ptr_Vec3i[j*nnWidth+i].data2!=0||
                           matIn.ptr_Vec3i[j*nnWidth+i].data3!=0)
                        {
                            i32_mianji++;
                            break;
                        }
                    }
                }
                *line=i32_mianji;
                return 0;
            break;
            case CCV_32FC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(matIn.ptr_float[j*nnWidth+i]!=0)
                        {
                            i32_mianji++;
                            break;
                        }
                    }
                }
                *line=i32_mianji;
                return 0;
            break;
            case CCV_32FC3:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(matIn.ptr_Vec3f[j*nnWidth+i].data1!=0||
                           matIn.ptr_Vec3f[j*nnWidth+i].data2!=0||
                           matIn.ptr_Vec3f[j*nnWidth+i].data3!=0)
                        {
                            i32_mianji++;
                            break;
                        }
                    }
                }
                *line=i32_mianji;
                return 0;
            break;
            case CCV_64FC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(matIn.ptr_double[j*nnWidth+i]!=0)
                        {
                            i32_mianji++;
                            break;
                        }
                    }
                }
                *line=i32_mianji;
                return 0;
            break;
            case CCV_64FC3:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(matIn.ptr_Vec3d[j*nnWidth+i].data1!=0||
                           matIn.ptr_Vec3d[j*nnWidth+i].data2!=0||
                           matIn.ptr_Vec3d[j*nnWidth+i].data3!=0)
                        {
                            i32_mianji++;
                            break;
                        }
                    }
                }
                *line=i32_mianji;
                return 0;
            break;
            default:
                return 1;
            break;
        }
    }

    Int8 MyRownum_obj(Mat matIn,Int32 *row)
    {
        Int32 j,i;
        Int32 nnWidth=matIn.nWidth;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        Int32 i32_mianji=0;
        switch(matIn._type)
        {
            case CCV_8UC1:
                for(i=nStartX;i<nStartX+nWidth;i++)
                {
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        if(matIn.ptr_uchar[j*nnWidth+i]!=0)
                        {
                            i32_mianji++;
                            break;
                        }
                    }
                }
                *row=i32_mianji;
                return 0;
            break;
            case CCV_8UC3:
                for(i=nStartX;i<nStartX+nWidth;i++)
                {
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        if(matIn.ptr_Vec3b[j*nnWidth+i].data1!=0||
                           matIn.ptr_Vec3b[j*nnWidth+i].data2!=0||
                           matIn.ptr_Vec3b[j*nnWidth+i].data3!=0)
                        {
                            i32_mianji++;
                            break;
                        }
                    }
                }
                *row=i32_mianji;
                return 0;
            break;
            case CCV_8SC1:
                for(i=nStartX;i<nStartX+nWidth;i++)
                {
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        if(matIn.ptr_char[j*nnWidth+i]!=0)
                        {
                            i32_mianji++;
                            break;
                        }
                    }
                }
                *row=i32_mianji;
                return 0;
            break;
            case CCV_8SC3:
                for(i=nStartX;i<nStartX+nWidth;i++)
                {
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        if(matIn.ptr_Vec3ib[j*nnWidth+i].data1!=0||
                           matIn.ptr_Vec3ib[j*nnWidth+i].data2!=0||
                           matIn.ptr_Vec3ib[j*nnWidth+i].data3!=0)
                        {
                            i32_mianji++;
                            break;
                        }
                    }
                }
                *row=i32_mianji;
                return 0;
            break;
            case CCV_16UC1:
                for(i=nStartX;i<nStartX+nWidth;i++)
                {
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        if(matIn.ptr_ushort[j*nnWidth+i]!=0)
                        {
                            i32_mianji++;
                            break;
                        }
                    }
                }
                *row=i32_mianji;
                return 0;
            break;
            case CCV_16UC3:
                for(i=nStartX;i<nStartX+nWidth;i++)
                {
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        if(matIn.ptr_Vec3s[j*nnWidth+i].data1!=0||
                           matIn.ptr_Vec3s[j*nnWidth+i].data2!=0||
                           matIn.ptr_Vec3s[j*nnWidth+i].data3!=0)
                        {
                            i32_mianji++;
                            break;
                        }
                    }
                }
                *row=i32_mianji;
                return 0;
            break;
            case CCV_32SC1:
                for(i=nStartX;i<nStartX+nWidth;i++)
                {
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        if(matIn.ptr_int[j*nnWidth+i]!=0)
                        {
                            i32_mianji++;
                            break;
                        }
                    }
                }
                *row=i32_mianji;
                return 0;
            break;
            case CCV_32SC3:
                for(i=nStartX;i<nStartX+nWidth;i++)
                {
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        if(matIn.ptr_Vec3i[j*nnWidth+i].data1!=0||
                           matIn.ptr_Vec3i[j*nnWidth+i].data2!=0||
                           matIn.ptr_Vec3i[j*nnWidth+i].data3!=0)
                        {
                            i32_mianji++;
                            break;
                        }
                    }
                }
                *row=i32_mianji;
                return 0;
            break;
            case CCV_32FC1:
                for(i=nStartX;i<nStartX+nWidth;i++)
                {
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        if(matIn.ptr_float[j*nnWidth+i]!=0)
                        {
                            i32_mianji++;
                            break;
                        }
                    }
                }
                *row=i32_mianji;
                return 0;
            break;
            case CCV_32FC3:
                for(i=nStartX;i<nStartX+nWidth;i++)
                {
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        if(matIn.ptr_Vec3f[j*nnWidth+i].data1!=0||
                           matIn.ptr_Vec3f[j*nnWidth+i].data2!=0||
                           matIn.ptr_Vec3f[j*nnWidth+i].data3!=0)
                        {
                            i32_mianji++;
                            break;
                        }
                    }
                }
                *row=i32_mianji;
                return 0;
            break;
            case CCV_64FC1:
                for(i=nStartX;i<nStartX+nWidth;i++)
                {
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        if(matIn.ptr_double[j*nnWidth+i]!=0)
                        {
                            i32_mianji++;
                            break;
                        }
                    }
                }
                *row=i32_mianji;
                return 0;
            break;
            case CCV_64FC3:
                for(i=nStartX;i<nStartX+nWidth;i++)
                {
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        if(matIn.ptr_Vec3d[j*nnWidth+i].data1!=0||
                           matIn.ptr_Vec3d[j*nnWidth+i].data2!=0||
                           matIn.ptr_Vec3d[j*nnWidth+i].data3!=0)
                        {
                            i32_mianji++;
                            break;
                        }
                    }
                }
                *row=i32_mianji;
                return 0;
            break;
            default:
                return 1;
            break;
        }
    }

    Int8 Mydilation_circle(Mat matIn,Mat *matOut,Uint32 size,dilaero Mod)
    {
        Int32 nnWidth=matIn.nWidth;
        Int32 nnHeight=matIn.nHeight;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;

        Mat mincut=MatCreat(nnHeight,nnWidth,CCV_8UC1,u8_buffer_x3Temp1);
        cv::Mat kernel;
        cv::Mat cvimgIn,cvimgOut;

        Int8 maskH[9]={ 1, 1, 1,
                        1, 0, 1,
                        1, 1, 1};

        Int8 maskW[9]={ 0, 1, 0,
                        1, 1, 1,
                        0, 1, 0};

        switch(matIn._type)
        {
            case CCV_8UC1:
                if(size==0)
                    MatClone(matIn,matOut);
                else
                {
                    getcloneinfo(matIn,matOut);
                    MyCutminRoi(matIn,&mincut,MHC_CUTMIN_1,nStartX,nStartY,nWidth,nHeight);
                    cvimgIn=cv::Mat(mincut.nHeight,mincut.nWidth,CV_8U);
                    memcpy(cvimgIn.data,mincut.data,getsizeof(mincut._type)*mincut.nHeight*mincut.nWidth);
                    switch(Mod)
                    {
                        case MHC_MORPH_RECT:
                            kernel=cv::Mat(3,3,CV_8U);
                            memcpy(kernel.data,maskH,9);
                        break;
                        case MHC_MORPH_ELLIPSE:
                            kernel=cv::Mat(3,3,CV_8U);
                            memcpy(kernel.data,maskW,9);
                        break;
                        default:
                            return 1;
                        break;
                    }
                    cv::dilate(cvimgIn,cvimgOut,kernel,cv::Point(-1,-1),size);
                    memcpy(mincut.data,cvimgOut.data,cvimgOut.elemSize()*cvimgOut.rows*cvimgOut.cols);
                    MyAddminRoi(*matOut,mincut,matOut,nStartX,nStartY);
                }
                return 0;
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 Mydilation_circle2(Mat matIn,Mat *matOut,Uint32 sizew,Uint32 sizeh,dilaero Mod)
    {
        Int32 nnWidth=matIn.nWidth;
        Int32 nnHeight=matIn.nHeight;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;

        Int8 maskH[9]={0, 1, 0,
                       0, 1, 0,
                       0, 1, 0};
        Int8 maskW[9]={ 0, 0, 0,
                        1, 1, 1,
                        0, 0, 0};
        Int8 mask[9]= { 0, 1, 0,
                        1, 1, 1,
                        0, 1, 0};

        Mat mincut=MatCreat(nnHeight,nnWidth,CCV_8UC1,u8_buffer_x3Temp1);
        cv::Mat kernel_H,kernel_W,kernel;
        cv::Mat cvimgIn;

        kernel_H=cv::Mat(3,3,CV_8U);
        memcpy(kernel_H.data,maskH,9);

        kernel_W=cv::Mat(3,3,CV_8U);
        memcpy(kernel_W.data,maskW,9);

        kernel=cv::Mat(3,3,CV_8U);
        memcpy(kernel.data,mask,9);

        switch(matIn._type)
        {
            case CCV_8UC1:
                if(sizew==0&&sizeh==0)
                    MatClone(matIn,matOut);
                else
                {
                    getcloneinfo(matIn,matOut);
                    MyCutminRoi(matIn,&mincut,MHC_CUTMIN_1,nStartX,nStartY,nWidth,nHeight);
                    cvimgIn=cv::Mat(mincut.nHeight,mincut.nWidth,CV_8U);
                    memcpy(cvimgIn.data,mincut.data,getsizeof(mincut._type)*mincut.nHeight*mincut.nWidth);

                    switch(Mod)
                    {
                        case MHC_MORPH_RECT:
                            if(sizew>0)
                                cv::dilate(cvimgIn,cvimgIn,kernel_W,cv::Point(-1,-1),sizew);
                            if(sizeh>0)
                                cv::dilate(cvimgIn,cvimgIn,kernel_H,cv::Point(-1,-1),sizeh);
                        break;
                        case MHC_MORPH_ELLIPSE:
                            if((Int32)sizew-1>0)
                                cv::dilate(cvimgIn,cvimgIn,kernel_W,cv::Point(-1,-1),sizew-1);
                            if((Int32)sizeh-1>0)
                                cv::dilate(cvimgIn,cvimgIn,kernel_H,cv::Point(-1,-1),sizeh-1);
                            cv::dilate(cvimgIn,cvimgIn,kernel);
                        break;
                        default:
                            return 1;
                        break;
                    }
                    memcpy(mincut.data,cvimgIn.data,cvimgIn.elemSize()*cvimgIn.rows*cvimgIn.cols);
                    MyAddminRoi(*matOut,mincut,matOut,nStartX,nStartY);
                }
                return 0;
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 Myerosion_circle(Mat matIn,Mat *matOut,Uint32 size,dilaero Mod)
    {
        Int32 nnWidth=matIn.nWidth;
        Int32 nnHeight=matIn.nHeight;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        cv::Mat kernel_rect,kernel_cross;
        cv::Mat cvimgIn;
        Int32 n=0;

        Int8 maskH[9]={ 1, 1, 1,
                        1, 0, 1,
                        1, 1, 1};

        Int8 maskW[9]={ 0, 1, 0,
                        1, 1, 1,
                        0, 1, 0};

        Mat mincut=MatCreat(nnHeight,nnWidth,CCV_8UC1,u8_buffer_x3Temp1);

        kernel_rect=cv::Mat(3,3,CV_8U);
        memcpy(kernel_rect.data,maskH,9);

        kernel_cross=cv::Mat(3,3,CV_8U);
        memcpy(kernel_cross.data,maskW,9);

        switch(matIn._type)
        {
            case CCV_8UC1:
                if(size==0)
                    MatClone(matIn,matOut);
                else
                {
                    getcloneinfo(matIn,matOut);
                    MyCutminRoi(matIn,&mincut,MHC_CUTMIN_1,nStartX,nStartY,nWidth,nHeight);
                    cvimgIn=cv::Mat(mincut.nHeight,mincut.nWidth,CV_8U);
                    memcpy(cvimgIn.data,mincut.data,getsizeof(mincut._type)*mincut.nHeight*mincut.nWidth);
                    switch(Mod)
                    {
                        case MHC_MORPH_RECT:
                            cv::erode(cvimgIn,cvimgIn,kernel_rect,cv::Point(-1,-1),size);
                        break;
                        case MHC_MORPH_ELLIPSE:
                            while(n<size)
                            {
                                if((n|0)==0)
                                    cv::erode(cvimgIn,cvimgIn,kernel_cross,cv::Point(-1,-1),1);
                                else
                                    cv::erode(cvimgIn,cvimgIn,kernel_rect,cv::Point(-1,-1),1);
                                n++;
                            }
                        break;
                        default:
                            return 1;
                        break;
                    }
                    memcpy(mincut.data,cvimgIn.data,cvimgIn.elemSize()*cvimgIn.rows*cvimgIn.cols);
                    MyAddminRoi(*matOut,mincut,matOut,nStartX,nStartY);
                }
                return 0;
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 Myerosion_circle2(Mat matIn,Mat *matOut,Uint32 sizew,Uint32 sizeh,dilaero Mod)
    {
        Int32 nnWidth=matIn.nWidth;
        Int32 nnHeight=matIn.nHeight;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;

        Int8 maskH[9]={0, 1, 0,
                       0, 1, 0,
                       0, 1, 0};
        Int8 maskW[9]={ 0, 0, 0,
                        1, 1, 1,
                        0, 0, 0};
        Int8 mask[9]= { 0, 1, 0,
                        1, 1, 1,
                        0, 1, 0};

        Mat mincut=MatCreat(nnHeight,nnWidth,CCV_8UC1,u8_buffer_x3Temp1);
        cv::Mat kernel_H,kernel_W,kernel;
        cv::Mat cvimgIn;

        kernel_H=cv::Mat(3,3,CV_8U);
        memcpy(kernel_H.data,maskH,9);

        kernel_W=cv::Mat(3,3,CV_8U);
        memcpy(kernel_W.data,maskW,9);

        kernel=cv::Mat(3,3,CV_8U);
        memcpy(kernel.data,mask,9);

        switch(matIn._type)
        {
            case CCV_8UC1:
                if(sizew==0&&sizeh==0)
                    MatClone(matIn,matOut);
                else
                {
                    getcloneinfo(matIn,matOut);
                    MyCutminRoi(matIn,&mincut,MHC_CUTMIN_1,nStartX,nStartY,nWidth,nHeight);
                    cvimgIn=cv::Mat(mincut.nHeight,mincut.nWidth,CV_8U);
                    memcpy(cvimgIn.data,mincut.data,getsizeof(mincut._type)*mincut.nHeight*mincut.nWidth);
                    switch(Mod)
                    {
                        case MHC_MORPH_RECT:
                            if(sizew>0)
                                cv::erode(cvimgIn,cvimgIn,kernel_W,cv::Point(-1,-1),sizew);
                            if(sizeh>0)
                                cv::erode(cvimgIn,cvimgIn,kernel_H,cv::Point(-1,-1),sizeh);
                        break;
                        case MHC_MORPH_ELLIPSE:

                            if((Int32)sizew-1>0)
                                cv::erode(cvimgIn,cvimgIn,kernel_W,cv::Point(-1,-1),sizew-1);
                            if((Int32)sizeh-1>0)
                                cv::erode(cvimgIn,cvimgIn,kernel_H,cv::Point(-1,-1),sizeh-1);
                            cv::erode(cvimgIn,cvimgIn,kernel);
                        break;
                        default:
                            return 1;
                        break;
                    }
                    memcpy(mincut.data,cvimgIn.data,cvimgIn.elemSize()*cvimgIn.rows*cvimgIn.cols);
                    MyAddminRoi(*matOut,mincut,matOut,nStartX,nStartY);
                }
                return 0;
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 Myconnection(Mat matIn,MyConect *ImageConectOut,Int32 value,Int32 distance,conectlt Mod,void *bufferIn)
    {
        Int32 nnWidth=matIn.nWidth;
        Int32 nnHeight=matIn.nHeight;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        Int32 numCC;
        Int32 n;
        Int32 mianji=0;
        Int32 pointnum=0;
        Int32 pointst=0;
        Uint8 *u8_data=matIn.ptr_uchar;
        VLIB_CC tempBlob;
        VLIB_CC minBlob;
        cv::Mat cvimgIn,cvimglib,stats,centroids;
        cv::Mat kernel;
        Int32 *imagelab;
        Mat mincut;

        Int8 mask[9]= { 1, 1, 1,
                        1, 0, 1,
                        1, 1, 1};
        kernel=cv::Mat(3,3,CV_8U);
        memcpy(kernel.data,mask,9);

        ImageConectOut->mianji=0;
        ImageConectOut->AllMarkPointCount=0;
        ImageConectOut->memPoint=(L_Point*)bufferIn;
        ImageConectOut->nHeight=nnHeight;
        ImageConectOut->nWidth=nnWidth;
        ImageConectOut->startx=matIn.startx;
        ImageConectOut->starty=matIn.starty;
        ImageConectOut->height=matIn.height;
        ImageConectOut->width=matIn.width;

        switch(matIn._type)
        {
            case CCV_8UC1:
                mincut=MatCreat(nnHeight,nnWidth,CCV_8UC1,u8_buffer_x3Temp1);
                MyCutminRoi(matIn,&mincut,MHC_CUTMIN_1,nStartX,nStartY,nWidth,nHeight);
                cvimgIn=cv::Mat(mincut.nHeight,mincut.nWidth,CV_8U);
                memcpy(cvimgIn.data,mincut.data,getsizeof(mincut._type)*mincut.nHeight*mincut.nWidth);
                if(distance>0)
                {
                    cv::dilate(cvimgIn,cvimgIn,kernel,cv::Point(-1,-1),distance);
                }
                switch(Mod)
                {
                    case MHC_4LT:
                        numCC=cv::connectedComponentsWithStats(cvimgIn,cvimglib,stats,centroids,4);
                    break;
                    case MHC_8LT:
                        numCC=cv::connectedComponentsWithStats(cvimgIn,cvimglib,stats,centroids,8);
                    break;
                    default:
                        return 1;
                    break;
                }
                imagelab=(Int32*)cvimglib.data;

                if(numCC<=1)
                    return 1;

                if(distance>0)
                {
                    Int32 realnum=0;
                    Int32 realmianji=0;

                    for(n=1;n<numCC;n++)
                    {
                        Int32 realPointArea=0;
                        Int32 realxTotal=0;
                        Int32 realyTotal=0;
                        Int32 i,j;

                        minBlob.xmax=0;
                        minBlob.xmin=nWidth;
                        minBlob.ymax=0;
                        minBlob.ymin=nHeight;

                        tempBlob.xmin=stats.at<int>(n,cv::CC_STAT_LEFT);
                        tempBlob.xmax=stats.at<int>(n,cv::CC_STAT_LEFT)+stats.at<int>(n,cv::CC_STAT_WIDTH)-1;
                        tempBlob.ymin=stats.at<int>(n,cv::CC_STAT_TOP);
                        tempBlob.ymax=stats.at<int>(n,cv::CC_STAT_TOP)+stats.at<int>(n,cv::CC_STAT_HEIGHT)-1;

                        for(j=tempBlob.ymin;j<=tempBlob.ymax;j++)
                        {
                            for(i=tempBlob.xmin;i<=tempBlob.xmax;i++)
                            {
                                if((imagelab[j*nWidth+i]==n)&&(u8_data[(j+nStartY)*nnWidth+(i+nStartX)]!=0))
                                {
                                    realPointArea++;
                                    realxTotal=realxTotal+i;
                                    realyTotal=realyTotal+j;
                                    if(i>minBlob.xmax)
                                    {
                                        minBlob.xmax=i;
                                    }
                                    if(i<minBlob.xmin)
                                    {
                                        minBlob.xmin=i;
                                    }
                                    if(j>minBlob.ymax)
                                    {
                                        minBlob.ymax=j;
                                    }
                                    if(j<minBlob.ymin)
                                    {
                                        minBlob.ymin=j;
                                    }
                                    ImageConectOut->memPoint[pointnum].x=i+nStartX;
                                    ImageConectOut->memPoint[pointnum].y=j+nStartY;
                                    pointnum++;
                                }
                            }
                        }
                        if(realPointArea>=value)
                        {
                            if(realnum>=MHC_MARK_POINTNUM)
                            {
                                ImageConectOut->mianji=0;
                                ImageConectOut->AllMarkPointCount=0;
                                return 1;
                            }
                            ImageConectOut->AllMarkPoint[realnum].bottom=minBlob.ymax+nStartY;
                            ImageConectOut->AllMarkPoint[realnum].top=minBlob.ymin+nStartY;
                            ImageConectOut->AllMarkPoint[realnum].left=minBlob.xmin+nStartX;
                            ImageConectOut->AllMarkPoint[realnum].right=minBlob.xmax+nStartX;
                            ImageConectOut->AllMarkPoint[realnum].color=realnum+1;
                            ImageConectOut->AllMarkPoint[realnum].PointArea=realPointArea;
                            ImageConectOut->AllMarkPoint[realnum].xTotal=realxTotal+nStartX*realPointArea;
                            ImageConectOut->AllMarkPoint[realnum].yTotal=realyTotal+nStartY*realPointArea;
                            ImageConectOut->AllMarkPoint[realnum].point=&ImageConectOut->memPoint[pointst];
                            realmianji=realmianji+realPointArea;
                            realnum++;
                        }
                        pointst=pointnum;
                    }
                    ImageConectOut->mianji=realmianji;
                    ImageConectOut->AllMarkPointCount=realnum;
                }
                else
                {
                    Int32 realnum=0;
                    for(n=1;n<numCC;n++)
                    {
                        Int32 i,j;

                        tempBlob.area=stats.at<int>(n,cv::CC_STAT_AREA);
                        if(tempBlob.area>=value)
                        {
                            if(realnum>=MHC_MARK_POINTNUM)
                            {
                                ImageConectOut->mianji=0;
                                ImageConectOut->AllMarkPointCount=0;
                                return 1;
                            }
                            tempBlob.xmin=stats.at<int>(n,cv::CC_STAT_LEFT);
                            tempBlob.xmax=stats.at<int>(n,cv::CC_STAT_LEFT)+stats.at<int>(n,cv::CC_STAT_WIDTH)-1;
                            tempBlob.ymin=stats.at<int>(n,cv::CC_STAT_TOP);
                            tempBlob.ymax=stats.at<int>(n,cv::CC_STAT_TOP)+stats.at<int>(n,cv::CC_STAT_HEIGHT)-1;
                            tempBlob.xsum=centroids.at<double>(n,0)*tempBlob.area+0.5;
                            tempBlob.ysum=centroids.at<double>(n,1)*tempBlob.area+0.5;

                            ImageConectOut->AllMarkPoint[realnum].bottom=tempBlob.ymax+nStartY;
                            ImageConectOut->AllMarkPoint[realnum].top=tempBlob.ymin+nStartY;
                            ImageConectOut->AllMarkPoint[realnum].left=tempBlob.xmin+nStartX;
                            ImageConectOut->AllMarkPoint[realnum].right=tempBlob.xmax+nStartX;
                            ImageConectOut->AllMarkPoint[realnum].PointArea=tempBlob.area;
                            ImageConectOut->AllMarkPoint[realnum].xTotal=tempBlob.xsum+nStartX*tempBlob.area;
                            ImageConectOut->AllMarkPoint[realnum].yTotal=tempBlob.ysum+nStartY*tempBlob.area;
                            ImageConectOut->AllMarkPoint[realnum].color=realnum+1;
                            mianji=mianji+tempBlob.area;
                            for(j=tempBlob.ymin;j<=tempBlob.ymax;j++)
                            {
                                for(i=tempBlob.xmin;i<=tempBlob.xmax;i++)
                                {
                                    if(imagelab[j*nWidth+i]==n)
                                    {
                                        ImageConectOut->memPoint[pointnum].x=i+nStartX;
                                        ImageConectOut->memPoint[pointnum].y=j+nStartY;
                                        pointnum++;
                                    }
                                }
                            }
                            ImageConectOut->AllMarkPoint[realnum].point=&ImageConectOut->memPoint[pointst];
                            realnum++;
                            pointst=pointnum;
                        }
                    }
                    ImageConectOut->mianji=mianji;
                    ImageConectOut->AllMarkPointCount=realnum;
                }
                return 0;
            break;
            default:
                return 1;
            break;
        }
    }

    Int8 Myconnection2(Mat matIn,MyConect *ImageConectOut,Int32 value,Int32 distancew,Int32 distanceh,dilaero distancemod,conectlt Mod,void *bufferIn)
    {
        Int32 nnWidth=matIn.nWidth;
        Int32 nnHeight=matIn.nHeight;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        Int32 numCC;
        Int32 n;
        Int32 mianji=0;
        Int32 pointnum=0;
        Int32 pointst=0;
        Uint8 *u8_data=matIn.ptr_uchar;
        VLIB_CC tempBlob;
        VLIB_CC minBlob;
        cv::Mat cvimgIn,cvimglib,stats,centroids;
        Int32 *imagelab;
        Mat mincut;
        Int8 maskH[9]={0, 1, 0,
                       0, 1, 0,
                       0, 1, 0};
        Int8 maskW[9]={ 0, 0, 0,
                        1, 1, 1,
                        0, 0, 0};
        Int8 mask[9]= { 0, 1, 0,
                        1, 1, 1,
                        0, 1, 0};

        cv::Mat kernel_H,kernel_W,kernel;

        kernel_H=cv::Mat(3,3,CV_8U);
        memcpy(kernel_H.data,maskH,9);

        kernel_W=cv::Mat(3,3,CV_8U);
        memcpy(kernel_W.data,maskW,9);

        kernel=cv::Mat(3,3,CV_8U);
        memcpy(kernel.data,mask,9);

        ImageConectOut->mianji=0;
        ImageConectOut->AllMarkPointCount=0;
        ImageConectOut->memPoint=(L_Point*)bufferIn;
        ImageConectOut->nHeight=nnHeight;
        ImageConectOut->nWidth=nnWidth;
        ImageConectOut->startx=matIn.startx;
        ImageConectOut->starty=matIn.starty;
        ImageConectOut->height=matIn.height;
        ImageConectOut->width=matIn.width;

        switch(matIn._type)
        {
            case CCV_8UC1:
                mincut=MatCreat(nnHeight,nnWidth,CCV_8UC1,u8_buffer_x3Temp1);
                MyCutminRoi(matIn,&mincut,MHC_CUTMIN_1,nStartX,nStartY,nWidth,nHeight);
                cvimgIn=cv::Mat(mincut.nHeight,mincut.nWidth,CV_8U);
                memcpy(cvimgIn.data,mincut.data,getsizeof(mincut._type)*mincut.nHeight*mincut.nWidth);
                switch(distancemod)
                {
                    case MHC_MORPH_RECT:
                        if(distancew>0)
                            cv::dilate(cvimgIn,cvimgIn,kernel_W,cv::Point(-1,-1),distancew);
                        if(distanceh>0)
                            cv::dilate(cvimgIn,cvimgIn,kernel_H,cv::Point(-1,-1),distanceh);
                    break;
                    case MHC_MORPH_ELLIPSE:
                        if((Int32)distancew-1>0)
                            cv::dilate(cvimgIn,cvimgIn,kernel_W,cv::Point(-1,-1),distancew-1);
                        if((Int32)distanceh-1>0)
                            cv::dilate(cvimgIn,cvimgIn,kernel_H,cv::Point(-1,-1),distanceh-1);
                        cv::dilate(cvimgIn,cvimgIn,kernel);
                    break;
                    default:
                        return 1;
                    break;
                }
                switch(Mod)
                {
                    case MHC_4LT:
                        numCC=cv::connectedComponentsWithStats(cvimgIn,cvimglib,stats,centroids,4);
                    break;
                    case MHC_8LT:
                        numCC=cv::connectedComponentsWithStats(cvimgIn,cvimglib,stats,centroids,8);
                    break;
                    default:
                        return 1;
                    break;
                }

                imagelab=(Int32*)cvimglib.data;

                if(numCC<=1)
                    return 1;

                if(distancew>0||distanceh>0)
                {
                    Int32 realnum=0;
                    Int32 realmianji=0;

                    for(n=1;n<numCC;n++)
                    {
                        Int32 realPointArea=0;
                        Int32 realxTotal=0;
                        Int32 realyTotal=0;
                        Int32 i,j;

                        minBlob.xmax=0;
                        minBlob.xmin=nWidth;
                        minBlob.ymax=0;
                        minBlob.ymin=nHeight;

                        tempBlob.xmin=stats.at<int>(n,cv::CC_STAT_LEFT);
                        tempBlob.xmax=stats.at<int>(n,cv::CC_STAT_LEFT)+stats.at<int>(n,cv::CC_STAT_WIDTH)-1;
                        tempBlob.ymin=stats.at<int>(n,cv::CC_STAT_TOP);
                        tempBlob.ymax=stats.at<int>(n,cv::CC_STAT_TOP)+stats.at<int>(n,cv::CC_STAT_HEIGHT)-1;

                        for(j=tempBlob.ymin;j<=tempBlob.ymax;j++)
                        {
                            for(i=tempBlob.xmin;i<=tempBlob.xmax;i++)
                            {
                                if((imagelab[j*nWidth+i]==n)&&(u8_data[(j+nStartY)*nnWidth+(i+nStartX)]!=0))
                                {
                                    realPointArea++;
                                    realxTotal=realxTotal+i;
                                    realyTotal=realyTotal+j;
                                    if(i>minBlob.xmax)
                                    {
                                        minBlob.xmax=i;
                                    }
                                    if(i<minBlob.xmin)
                                    {
                                        minBlob.xmin=i;
                                    }
                                    if(j>minBlob.ymax)
                                    {
                                        minBlob.ymax=j;
                                    }
                                    if(j<minBlob.ymin)
                                    {
                                        minBlob.ymin=j;
                                    }
                                    ImageConectOut->memPoint[pointnum].x=i+nStartX;
                                    ImageConectOut->memPoint[pointnum].y=j+nStartY;
                                    pointnum++;
                                }
                            }
                        }
                        if(realPointArea>=value)
                        {
                            if(realnum>=MHC_MARK_POINTNUM)
                            {
                                ImageConectOut->mianji=0;
                                ImageConectOut->AllMarkPointCount=0;
                                return 1;
                            }
                            ImageConectOut->AllMarkPoint[realnum].bottom=minBlob.ymax+nStartY;
                            ImageConectOut->AllMarkPoint[realnum].top=minBlob.ymin+nStartY;
                            ImageConectOut->AllMarkPoint[realnum].left=minBlob.xmin+nStartX;
                            ImageConectOut->AllMarkPoint[realnum].right=minBlob.xmax+nStartX;
                            ImageConectOut->AllMarkPoint[realnum].color=realnum+1;
                            ImageConectOut->AllMarkPoint[realnum].PointArea=realPointArea;
                            ImageConectOut->AllMarkPoint[realnum].xTotal=realxTotal+nStartX*realPointArea;
                            ImageConectOut->AllMarkPoint[realnum].yTotal=realyTotal+nStartY*realPointArea;
                            ImageConectOut->AllMarkPoint[realnum].point=&ImageConectOut->memPoint[pointst];
                            realmianji=realmianji+realPointArea;
                            realnum++;
                        }
                        pointst=pointnum;
                    }
                    ImageConectOut->mianji=realmianji;
                    ImageConectOut->AllMarkPointCount=realnum;
                }
                else
                {
                    Int32 realnum=0;
                    for(n=1;n<numCC;n++)
                    {
                        Int32 i,j;

                        tempBlob.area=stats.at<int>(n,cv::CC_STAT_AREA);
                        if(tempBlob.area>=value)
                        {
                            if(realnum>=MHC_MARK_POINTNUM)
                            {
                                ImageConectOut->mianji=0;
                                ImageConectOut->AllMarkPointCount=0;
                                return 1;
                            }
                            tempBlob.xmin=stats.at<int>(n,cv::CC_STAT_LEFT);
                            tempBlob.xmax=stats.at<int>(n,cv::CC_STAT_LEFT)+stats.at<int>(n,cv::CC_STAT_WIDTH)-1;
                            tempBlob.ymin=stats.at<int>(n,cv::CC_STAT_TOP);
                            tempBlob.ymax=stats.at<int>(n,cv::CC_STAT_TOP)+stats.at<int>(n,cv::CC_STAT_HEIGHT)-1;
                            tempBlob.xsum=centroids.at<double>(n,0)*tempBlob.area+0.5;
                            tempBlob.ysum=centroids.at<double>(n,1)*tempBlob.area+0.5;

                            ImageConectOut->AllMarkPoint[realnum].bottom=tempBlob.ymax+nStartY;
                            ImageConectOut->AllMarkPoint[realnum].top=tempBlob.ymin+nStartY;
                            ImageConectOut->AllMarkPoint[realnum].left=tempBlob.xmin+nStartX;
                            ImageConectOut->AllMarkPoint[realnum].right=tempBlob.xmax+nStartX;
                            ImageConectOut->AllMarkPoint[realnum].PointArea=tempBlob.area;
                            ImageConectOut->AllMarkPoint[realnum].xTotal=tempBlob.xsum+nStartX*tempBlob.area;
                            ImageConectOut->AllMarkPoint[realnum].yTotal=tempBlob.ysum+nStartY*tempBlob.area;
                            ImageConectOut->AllMarkPoint[realnum].color=realnum+1;
                            mianji=mianji+tempBlob.area;
                            for(j=tempBlob.ymin;j<=tempBlob.ymax;j++)
                            {
                                for(i=tempBlob.xmin;i<=tempBlob.xmax;i++)
                                {
                                    if(imagelab[j*nWidth+i]==n)
                                    {
                                        ImageConectOut->memPoint[pointnum].x=i+nStartX;
                                        ImageConectOut->memPoint[pointnum].y=j+nStartY;
                                        pointnum++;
                                    }
                                }
                            }
                            ImageConectOut->AllMarkPoint[realnum].point=&ImageConectOut->memPoint[pointst];
                            realnum++;
                            pointst=pointnum;
                        }
                    }
                    ImageConectOut->mianji=mianji;
                    ImageConectOut->AllMarkPointCount=realnum;
                }
                return 0;
            break;
            default:
                return 1;
            break;
        }     
    }

    Int8 MyfindBigstconnection(Mat matIn,Mat *matOut,Int32 value,Int32 distance,conectlt Mod,background Cod,Int32 color,VLIB_CC *PointInfo)
    {
        Int32 nnWidth=matIn.nWidth;
        Int32 nnHeight=matIn.nHeight;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        Uint8 u8_color=(Uint8)color;
        Int32 numCC;
        Int32 n;
        Int32 Maxvalue=0;
        Int32 Maxvaluen=0;
        Int32 *imagelab;
        Uint8 *u8_data;
        VLIB_CC tempBlob;
        VLIB_CC minBlob;
        Int32 i,j;
        Mat matIntemp;
        cv::Mat cvimgIn,cvimglib,stats,centroids;
        Mat mincut;
        cv::Mat kernel;

        Int8 mask[9]= { 1, 1, 1,
                        1, 0, 1,
                        1, 1, 1};
        kernel=cv::Mat(3,3,CV_8U);
        memcpy(kernel.data,mask,9);

        PointInfo->area=0;
        if(matIn.data==matOut->data)
        {
            switch(matIn._type)
            {
                case CCV_8UC1:
                break;
                default:
                    return 1;
                break;
            }
            matIntemp=MatCreatClone(matIn,(Uint8*)u8_buffer_x1Temp6);
        }
        else
        {
            matIntemp=matIn;
        }
        u8_data=matIntemp.ptr_uchar;

        switch(matIn._type)
        {
            case CCV_8UC1:
                getcloneinfo(matIn,matOut);
                switch(Cod)
                {
                    case MHC_BACK:
                        MatSet1col(matOut,0);
                    break;
                    case MHC_BACK_INV:
                        MatSet1col(matOut,color);
                    break;
                    case MHC_BACK_WNV:
                        MatSet1col(matOut,255);
                    break;
                    default:
                        return 1;
                    break;
                }
                mincut=MatCreat(nnHeight,nnWidth,CCV_8UC1,u8_buffer_x3Temp1);
                MyCutminRoi(matIntemp,&mincut,MHC_CUTMIN_1,nStartX,nStartY,nWidth,nHeight);
                cvimgIn=cv::Mat(mincut.nHeight,mincut.nWidth,CV_8U);
                memcpy(cvimgIn.data,mincut.data,getsizeof(mincut._type)*mincut.nHeight*mincut.nWidth);
                if(distance>0)
                {
                    cv::dilate(cvimgIn,cvimgIn,kernel,cv::Point(-1,-1),distance);
                }
                switch(Mod)
                {
                    case MHC_4LT:
                        numCC=cv::connectedComponentsWithStats(cvimgIn,cvimglib,stats,centroids,4);
                    break;
                    case MHC_8LT:
                        numCC=cv::connectedComponentsWithStats(cvimgIn,cvimglib,stats,centroids,8);
                    break;
                    default:
                        return 1;
                    break;
                }
                imagelab=(Int32*)cvimglib.data;

                if(numCC<=1)
                    return 1;

                if(distance>0)
                {
                    for(n=1;n<numCC;n++)
                    {
                        Int32 realPointArea=0;
                        Int32 realxTotal=0;
                        Int32 realyTotal=0;
                        Int32 i,j;

                        minBlob.xmax=0;
                        minBlob.xmin=nWidth;
                        minBlob.ymax=0;
                        minBlob.ymin=nHeight;

                        tempBlob.xmin=stats.at<int>(n,cv::CC_STAT_LEFT);
                        tempBlob.xmax=stats.at<int>(n,cv::CC_STAT_LEFT)+stats.at<int>(n,cv::CC_STAT_WIDTH)-1;
                        tempBlob.ymin=stats.at<int>(n,cv::CC_STAT_TOP);
                        tempBlob.ymax=stats.at<int>(n,cv::CC_STAT_TOP)+stats.at<int>(n,cv::CC_STAT_HEIGHT)-1;

                        for(j=tempBlob.ymin;j<=tempBlob.ymax;j++)
                        {
                            for(i=tempBlob.xmin;i<=tempBlob.xmax;i++)
                            {
                                if((imagelab[j*nWidth+i]==n)&&(u8_data[(j+nStartY)*nnWidth+(i+nStartX)]!=0))
                                {
                                    realPointArea++;
                                    realxTotal=realxTotal+i;
                                    realyTotal=realyTotal+j;
                                    if(i>minBlob.xmax)
                                    {
                                        minBlob.xmax=i;
                                    }
                                    if(i<minBlob.xmin)
                                    {
                                        minBlob.xmin=i;
                                    }
                                    if(j>minBlob.ymax)
                                    {
                                        minBlob.ymax=j;
                                    }
                                    if(j<minBlob.ymin)
                                    {
                                        minBlob.ymin=j;
                                    }
                                }
                            }
                        }
                        if(realPointArea>=Maxvalue)
                        {
                            PointInfo->area=realPointArea;
                            PointInfo->xsum=realxTotal+nStartX*realPointArea;
                            PointInfo->ysum=realyTotal+nStartY*realPointArea;
                            PointInfo->xmin=minBlob.xmin+nStartX;
                            PointInfo->xmax=minBlob.xmax+nStartX;
                            PointInfo->ymax=minBlob.ymax+nStartY;
                            PointInfo->ymin=minBlob.ymin+nStartY;
                            Maxvalue=realPointArea;
                            Maxvaluen=n;
                        }
                    }
                    if(Maxvalue<value)
                        return 1;
                    tempBlob.xmin=stats.at<int>(Maxvaluen,cv::CC_STAT_LEFT);
                    tempBlob.xmax=stats.at<int>(Maxvaluen,cv::CC_STAT_LEFT)+stats.at<int>(Maxvaluen,cv::CC_STAT_WIDTH)-1;
                    tempBlob.ymin=stats.at<int>(Maxvaluen,cv::CC_STAT_TOP);
                    tempBlob.ymax=stats.at<int>(Maxvaluen,cv::CC_STAT_TOP)+stats.at<int>(Maxvaluen,cv::CC_STAT_HEIGHT)-1;

                    switch(Cod)
                    {
                        case MHC_BACK:
                        case MHC_BACK_WNV:
                            for(j=tempBlob.ymin;j<=tempBlob.ymax;j++)
                            {
                                for(i=tempBlob.xmin;i<=tempBlob.xmax;i++)
                                {
                                    if((imagelab[j*nWidth+i]==Maxvaluen)&&(u8_data[(j+nStartY)*nnWidth+(i+nStartX)]!=0))
                                    {
                                        matOut->data[(j+nStartY)*nnWidth+(i+nStartX)]=u8_color;
                                    }
                                }
                            }
                        break;
                        case MHC_BACK_INV:
                            for(j=tempBlob.ymin;j<=tempBlob.ymax;j++)
                            {
                                for(i=tempBlob.xmin;i<=tempBlob.xmax;i++)
                                {
                                    if((imagelab[j*nWidth+i]==Maxvaluen)&&(u8_data[(j+nStartY)*nnWidth+(i+nStartX)]!=0))
                                    {
                                        matOut->data[(j+nStartY)*nnWidth+(i+nStartX)]=0;
                                    }
                                }
                            }
                        break;
                        default:
                            return 1;
                        break;
                    }
                }
                else
                {
                    for(n=1;n<numCC;n++)
                    {
                        tempBlob.area=stats.at<int>(n,cv::CC_STAT_AREA);
                        if(tempBlob.area>=Maxvalue)
                        {
                            Maxvalue=tempBlob.area;
                            Maxvaluen=n;
                        }
                    }
                    tempBlob.area=stats.at<int>(Maxvaluen,cv::CC_STAT_AREA);
                    tempBlob.xmin=stats.at<int>(Maxvaluen,cv::CC_STAT_LEFT);
                    tempBlob.xmax=stats.at<int>(Maxvaluen,cv::CC_STAT_LEFT)+stats.at<int>(Maxvaluen,cv::CC_STAT_WIDTH)-1;
                    tempBlob.ymin=stats.at<int>(Maxvaluen,cv::CC_STAT_TOP);
                    tempBlob.ymax=stats.at<int>(Maxvaluen,cv::CC_STAT_TOP)+stats.at<int>(Maxvaluen,cv::CC_STAT_HEIGHT)-1;
                    tempBlob.xsum=centroids.at<double>(n,0)*tempBlob.area+0.5;
                    tempBlob.ysum=centroids.at<double>(n,1)*tempBlob.area+0.5;
                    *PointInfo=tempBlob;
                    PointInfo->xsum=PointInfo->xsum+nStartX*PointInfo->area;
                    PointInfo->ysum=PointInfo->ysum+nStartY*PointInfo->area;
                    PointInfo->xmin=PointInfo->xmin+nStartX;
                    PointInfo->xmax=PointInfo->xmax+nStartX;
                    PointInfo->ymax=PointInfo->ymax+nStartY;
                    PointInfo->ymin=PointInfo->ymin+nStartY;

                    switch(Cod)
                    {
                        case MHC_BACK:
                        case MHC_BACK_WNV:
                            for(j=tempBlob.ymin;j<=tempBlob.ymax;j++)
                            {
                                for(i=tempBlob.xmin;i<=tempBlob.xmax;i++)
                                {
                                    if(imagelab[j*nWidth+i]==Maxvaluen)
                                    {
                                        matOut->data[(j+nStartY)*nnWidth+(i+nStartX)]=u8_color;
                                    }
                                }
                            }
                        break;
                        case MHC_BACK_INV:
                            for(j=tempBlob.ymin;j<=tempBlob.ymax;j++)
                            {
                                for(i=tempBlob.xmin;i<=tempBlob.xmax;i++)
                                {
                                    if(imagelab[j*nWidth+i]==Maxvaluen)
                                    {
                                        matOut->data[(j+nStartY)*nnWidth+(i+nStartX)]=0;
                                    }
                                }
                            }
                        break;
                        default:
                            return 1;
                        break;
                    }
                }
                return 0;
            break;
            default:
                return 1;
            break;
        }
    }

    Int8 MyfindBigstconnection2(Mat matIn,Mat *matOut,Int32 value,Int32 distancew,Int32 distanceh,dilaero distancemod,conectlt Mod,background Cod,Int32 color,VLIB_CC *PointInfo)
    {
        Int32 nnWidth=matIn.nWidth;
        Int32 nnHeight=matIn.nHeight;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        Uint8 u8_color=(Uint8)color;
        Int32 numCC;
        Int32 n;
        Int32 Maxvalue=0;
        Int32 Maxvaluen=0;
        Int32 *imagelab;
        Uint8 *u8_data;
        VLIB_CC tempBlob;
        VLIB_CC minBlob;
        Int32 i,j;
        Mat matIntemp;
        cv::Mat cvimgIn,cvimglib,stats,centroids;
        Mat mincut;

        Int8 maskH[9]={0, 1, 0,
                       0, 1, 0,
                       0, 1, 0};
        Int8 maskW[9]={ 0, 0, 0,
                        1, 1, 1,
                        0, 0, 0};
        Int8 mask[9]= { 0, 1, 0,
                        1, 1, 1,
                        0, 1, 0};

        cv::Mat kernel_H,kernel_W,kernel;

        kernel_H=cv::Mat(3,3,CV_8U);
        memcpy(kernel_H.data,maskH,9);

        kernel_W=cv::Mat(3,3,CV_8U);
        memcpy(kernel_W.data,maskW,9);

        kernel=cv::Mat(3,3,CV_8U);
        memcpy(kernel.data,mask,9);

        PointInfo->area=0;
        if(matIn.data==matOut->data)
        {
            switch(matIn._type)
            {
                case CCV_8UC1:
                break;
                default:
                    return 1;
                break;
            }
            matIntemp=MatCreatClone(matIn,(Uint8*)u8_buffer_x1Temp6);
        }
        else
        {
            matIntemp=matIn;
        }
        u8_data=matIntemp.ptr_uchar;

        switch(matIn._type)
        {
            case CCV_8UC1:
                getcloneinfo(matIn,matOut);
                switch(Cod)
                {
                    case MHC_BACK:
                        MatSet1col(matOut,0);
                    break;
                    case MHC_BACK_INV:
                        MatSet1col(matOut,color);
                    break;
                    case MHC_BACK_WNV:
                        MatSet1col(matOut,255);
                    break;
                    default:
                        return 1;
                    break;
                }
                mincut=MatCreat(nnHeight,nnWidth,CCV_8UC1,u8_buffer_x3Temp1);
                MyCutminRoi(matIntemp,&mincut,MHC_CUTMIN_1,nStartX,nStartY,nWidth,nHeight);
                cvimgIn=cv::Mat(mincut.nHeight,mincut.nWidth,CV_8U);
                memcpy(cvimgIn.data,mincut.data,getsizeof(mincut._type)*mincut.nHeight*mincut.nWidth);
                switch(distancemod)
                {
                    case MHC_MORPH_RECT:
                        if(distancew>0)
                            cv::dilate(cvimgIn,cvimgIn,kernel_W,cv::Point(-1,-1),distancew);
                        if(distanceh>0)
                            cv::dilate(cvimgIn,cvimgIn,kernel_H,cv::Point(-1,-1),distanceh);
                    break;
                    case MHC_MORPH_ELLIPSE:
                        if((Int32)distancew-1>0)
                            cv::dilate(cvimgIn,cvimgIn,kernel_W,cv::Point(-1,-1),distancew-1);
                        if((Int32)distanceh-1>0)
                            cv::dilate(cvimgIn,cvimgIn,kernel_H,cv::Point(-1,-1),distanceh-1);
                        cv::dilate(cvimgIn,cvimgIn,kernel);
                    break;
                    default:
                        return 1;
                    break;
                }
                switch(Mod)
                {
                    case MHC_4LT:
                        numCC=cv::connectedComponentsWithStats(cvimgIn,cvimglib,stats,centroids,4);
                    break;
                    case MHC_8LT:
                        numCC=cv::connectedComponentsWithStats(cvimgIn,cvimglib,stats,centroids,8);
                    break;
                    default:
                        return 1;
                    break;
                }
                imagelab=(Int32*)cvimglib.data;

                if(numCC<=1)
                    return 1;

                if(distancew>0||distanceh>0)
                {
                    for(n=1;n<numCC;n++)
                    {
                        Int32 realPointArea=0;
                        Int32 realxTotal=0;
                        Int32 realyTotal=0;
                        Int32 i,j;

                        minBlob.xmax=0;
                        minBlob.xmin=nWidth;
                        minBlob.ymax=0;
                        minBlob.ymin=nHeight;

                        tempBlob.xmin=stats.at<int>(n,cv::CC_STAT_LEFT);
                        tempBlob.xmax=stats.at<int>(n,cv::CC_STAT_LEFT)+stats.at<int>(n,cv::CC_STAT_WIDTH)-1;
                        tempBlob.ymin=stats.at<int>(n,cv::CC_STAT_TOP);
                        tempBlob.ymax=stats.at<int>(n,cv::CC_STAT_TOP)+stats.at<int>(n,cv::CC_STAT_HEIGHT)-1;

                        for(j=tempBlob.ymin;j<=tempBlob.ymax;j++)
                        {
                            for(i=tempBlob.xmin;i<=tempBlob.xmax;i++)
                            {
                                if((imagelab[j*nWidth+i]==n)&&(u8_data[(j+nStartY)*nnWidth+(i+nStartX)]!=0))
                                {
                                    realPointArea++;
                                    realxTotal=realxTotal+i;
                                    realyTotal=realyTotal+j;
                                    if(i>minBlob.xmax)
                                    {
                                        minBlob.xmax=i;
                                    }
                                    if(i<minBlob.xmin)
                                    {
                                        minBlob.xmin=i;
                                    }
                                    if(j>minBlob.ymax)
                                    {
                                        minBlob.ymax=j;
                                    }
                                    if(j<minBlob.ymin)
                                    {
                                        minBlob.ymin=j;
                                    }
                                }
                            }
                        }
                        if(realPointArea>=Maxvalue)
                        {
                            PointInfo->area=realPointArea;
                            PointInfo->xsum=realxTotal+nStartX*realPointArea;
                            PointInfo->ysum=realyTotal+nStartY*realPointArea;
                            PointInfo->xmin=minBlob.xmin+nStartX;
                            PointInfo->xmax=minBlob.xmax+nStartX;
                            PointInfo->ymax=minBlob.ymax+nStartY;
                            PointInfo->ymin=minBlob.ymin+nStartY;
                            Maxvalue=realPointArea;
                            Maxvaluen=n;
                        }
                    }
                    if(Maxvalue<value)
                        return 1;
                    tempBlob.xmin=stats.at<int>(Maxvaluen,cv::CC_STAT_LEFT);
                    tempBlob.xmax=stats.at<int>(Maxvaluen,cv::CC_STAT_LEFT)+stats.at<int>(Maxvaluen,cv::CC_STAT_WIDTH)-1;
                    tempBlob.ymin=stats.at<int>(Maxvaluen,cv::CC_STAT_TOP);
                    tempBlob.ymax=stats.at<int>(Maxvaluen,cv::CC_STAT_TOP)+stats.at<int>(Maxvaluen,cv::CC_STAT_HEIGHT)-1;

                    switch(Cod)
                    {
                        case MHC_BACK:
                        case MHC_BACK_WNV:
                            for(j=tempBlob.ymin;j<=tempBlob.ymax;j++)
                            {
                                for(i=tempBlob.xmin;i<=tempBlob.xmax;i++)
                                {
                                    if((imagelab[j*nWidth+i]==Maxvaluen)&&(u8_data[(j+nStartY)*nnWidth+(i+nStartX)]!=0))
                                    {
                                        matOut->data[(j+nStartY)*nnWidth+(i+nStartX)]=u8_color;
                                    }
                                }
                            }
                        break;
                        case MHC_BACK_INV:
                            for(j=tempBlob.ymin;j<=tempBlob.ymax;j++)
                            {
                                for(i=tempBlob.xmin;i<=tempBlob.xmax;i++)
                                {
                                    if((imagelab[j*nWidth+i]==Maxvaluen)&&(u8_data[(j+nStartY)*nnWidth+(i+nStartX)]!=0))
                                    {
                                        matOut->data[(j+nStartY)*nnWidth+(i+nStartX)]=0;
                                    }
                                }
                            }
                        break;
                        default:
                            return 1;
                        break;
                    }
                }
                else
                {
                    for(n=1;n<numCC;n++)
                    {
                        tempBlob.area=stats.at<int>(n,cv::CC_STAT_AREA);
                        if(tempBlob.area>=Maxvalue)
                        {
                            Maxvalue=tempBlob.area;
                            Maxvaluen=n;
                        }
                    }
                    tempBlob.area=stats.at<int>(Maxvaluen,cv::CC_STAT_AREA);
                    tempBlob.xmin=stats.at<int>(Maxvaluen,cv::CC_STAT_LEFT);
                    tempBlob.xmax=stats.at<int>(Maxvaluen,cv::CC_STAT_LEFT)+stats.at<int>(Maxvaluen,cv::CC_STAT_WIDTH)-1;
                    tempBlob.ymin=stats.at<int>(Maxvaluen,cv::CC_STAT_TOP);
                    tempBlob.ymax=stats.at<int>(Maxvaluen,cv::CC_STAT_TOP)+stats.at<int>(Maxvaluen,cv::CC_STAT_HEIGHT)-1;
                    tempBlob.xsum=centroids.at<double>(n,0)*tempBlob.area+0.5;
                    tempBlob.ysum=centroids.at<double>(n,1)*tempBlob.area+0.5;
                    *PointInfo=tempBlob;
                    PointInfo->xsum=PointInfo->xsum+nStartX*PointInfo->area;
                    PointInfo->ysum=PointInfo->ysum+nStartY*PointInfo->area;
                    PointInfo->xmin=PointInfo->xmin+nStartX;
                    PointInfo->xmax=PointInfo->xmax+nStartX;
                    PointInfo->ymax=PointInfo->ymax+nStartY;
                    PointInfo->ymin=PointInfo->ymin+nStartY;

                    switch(Cod)
                    {
                        case MHC_BACK:
                        case MHC_BACK_WNV:
                            for(j=tempBlob.ymin;j<=tempBlob.ymax;j++)
                            {
                                for(i=tempBlob.xmin;i<=tempBlob.xmax;i++)
                                {
                                    if(imagelab[j*nWidth+i]==Maxvaluen)
                                    {
                                        matOut->data[(j+nStartY)*nnWidth+(i+nStartX)]=u8_color;
                                    }
                                }
                            }
                        break;
                        case MHC_BACK_INV:
                            for(j=tempBlob.ymin;j<=tempBlob.ymax;j++)
                            {
                                for(i=tempBlob.xmin;i<=tempBlob.xmax;i++)
                                {
                                    if(imagelab[j*nWidth+i]==Maxvaluen)
                                    {
                                        matOut->data[(j+nStartY)*nnWidth+(i+nStartX)]=0;
                                    }
                                }
                            }
                        break;
                        default:
                            return 1;
                        break;
                    }
                }
                return 0;
            break;
            default:
                return 1;
            break;
        }
    }

    Int8 Mydeleteconnection(Mat matIn,Mat *matOut,Int32 value,Int32 distance,conectlt Mod)
    {
        Int32 nnWidth=matIn.nWidth;
        Int32 nnHeight=matIn.nHeight;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        Int32 numCC;
        Int32 n;
        Int32 *imagelab;
        Uint8 *u8_data;
        VLIB_CC tempBlob;
        Mat matIntemp;
        cv::Mat cvimgIn,cvimglib,stats,centroids;
        Mat mincut;
        cv::Mat kernel;

        Int8 mask[9]= { 1, 1, 1,
                        1, 0, 1,
                        1, 1, 1};

        kernel=cv::Mat(3,3,CV_8U);
        memcpy(kernel.data,mask,9);

        getcloneinfo(matIn,matOut);
        if(matIn.data==matOut->data)
        {
            switch(matIn._type)
            {
                case CCV_8UC1:
                break;
                default:
                    return 1;
                break;
            }
            matIntemp=MatCreatClone(matIn,(Uint8*)u8_buffer_x1Temp6);
        }
        else
        {
            matIntemp=matIn;
        }
        u8_data=matIntemp.ptr_uchar;
        memset(matOut->data,0,nnWidth*nnHeight);
        switch(matIn._type)
        {
            case CCV_8UC1:
                mincut=MatCreat(nnHeight,nnWidth,CCV_8UC1,u8_buffer_x3Temp1);
                MyCutminRoi(matIntemp,&mincut,MHC_CUTMIN_1,nStartX,nStartY,nWidth,nHeight);
                cvimgIn=cv::Mat(mincut.nHeight,mincut.nWidth,CV_8U);
                memcpy(cvimgIn.data,mincut.data,getsizeof(mincut._type)*mincut.nHeight*mincut.nWidth);
                if(distance>0)
                {
                    cv::dilate(cvimgIn,cvimgIn,kernel,cv::Point(-1,-1),distance);
                }
                switch(Mod)
                {
                    case MHC_4LT:
                        numCC=cv::connectedComponentsWithStats(cvimgIn,cvimglib,stats,centroids,4);
                    break;
                    case MHC_8LT:
                        numCC=cv::connectedComponentsWithStats(cvimgIn,cvimglib,stats,centroids,8);
                    break;
                    default:
                        return 1;
                    break;
                }
                imagelab=(Int32*)cvimglib.data;

                if(numCC<=1)
                    return 1;

                if(distance>0)
                {
                    for(n=1;n<numCC;n++)
                    {
                        Int32 realPointArea=0;
                        Int32 i,j;

                        tempBlob.xmin=stats.at<int>(n,cv::CC_STAT_LEFT);
                        tempBlob.xmax=stats.at<int>(n,cv::CC_STAT_LEFT)+stats.at<int>(n,cv::CC_STAT_WIDTH)-1;
                        tempBlob.ymin=stats.at<int>(n,cv::CC_STAT_TOP);
                        tempBlob.ymax=stats.at<int>(n,cv::CC_STAT_TOP)+stats.at<int>(n,cv::CC_STAT_HEIGHT)-1;

                        for(j=tempBlob.ymin;j<=tempBlob.ymax;j++)
                        {
                            for(i=tempBlob.xmin;i<=tempBlob.xmax;i++)
                            {
                                if((imagelab[j*nWidth+i]==n)&&(u8_data[(j+nStartY)*nnWidth+(i+nStartX)]!=0))
                                {
                                    realPointArea++;
                                }
                            }
                        }
                        if(realPointArea>=value)
                        {
                            for(j=tempBlob.ymin;j<=tempBlob.ymax;j++)
                            {
                                for(i=tempBlob.xmin;i<=tempBlob.xmax;i++)
                                {
                                    if((imagelab[j*nWidth+i]==n)&&(u8_data[(j+nStartY)*nnWidth+(i+nStartX)]!=0))
                                    {
                                        matOut->data[(j+nStartY)*nnWidth+(i+nStartX)]=255;
                                    }
                                }
                            }
                        }
                    }
                }
                else
                {
                    for(n=1;n<numCC;n++)
                    {
                        Int32 i,j;
                        tempBlob.area=stats.at<int>(n,cv::CC_STAT_AREA);
                        tempBlob.xmin=stats.at<int>(n,cv::CC_STAT_LEFT);
                        tempBlob.xmax=stats.at<int>(n,cv::CC_STAT_LEFT)+stats.at<int>(n,cv::CC_STAT_WIDTH)-1;
                        tempBlob.ymin=stats.at<int>(n,cv::CC_STAT_TOP);
                        tempBlob.ymax=stats.at<int>(n,cv::CC_STAT_TOP)+stats.at<int>(n,cv::CC_STAT_HEIGHT)-1;
                        if(tempBlob.area>=value)
                        {
                            for(j=tempBlob.ymin;j<=tempBlob.ymax;j++)
                            {
                                for(i=tempBlob.xmin;i<=tempBlob.xmax;i++)
                                {
                                    if(imagelab[j*nWidth+i]==n)
                                    {
                                        matOut->data[(j+nStartY)*nnWidth+(i+nStartX)]=255;
                                    }
                                }
                            }
                        }
                    }
                }
                return 0;
            break;
            default:
                return 1;
            break;
        }
    }

    Int8 Mydeleteconnection2(Mat matIn,Mat *matOut,Int32 value,Int32 distancew,Int32 distanceh,dilaero distancemod,conectlt Mod)
    {
        Int32 nnWidth=matIn.nWidth;
        Int32 nnHeight=matIn.nHeight;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        Int32 numCC;
        Int32 n;
        Int32 *imagelab;
        Uint8 *u8_data;
        VLIB_CC tempBlob;
        Mat matIntemp;
        cv::Mat cvimgIn,cvimglib,stats,centroids;
        Mat mincut;

        Int8 maskH[9]={0, 1, 0,
                       0, 1, 0,
                       0, 1, 0};
        Int8 maskW[9]={ 0, 0, 0,
                        1, 1, 1,
                        0, 0, 0};
        Int8 mask[9]= { 0, 1, 0,
                        1, 1, 1,
                        0, 1, 0};
        cv::Mat kernel_H,kernel_W,kernel;

        kernel_H=cv::Mat(3,3,CV_8U);
        memcpy(kernel_H.data,maskH,9);

        kernel_W=cv::Mat(3,3,CV_8U);
        memcpy(kernel_W.data,maskW,9);

        kernel=cv::Mat(3,3,CV_8U);
        memcpy(kernel.data,mask,9);

        getcloneinfo(matIn,matOut);
        if(matIn.data==matOut->data)
        {
            switch(matIn._type)
            {
                case CCV_8UC1:
                break;
                default:
                    return 1;
                break;
            }
            matIntemp=MatCreatClone(matIn,(Uint8*)u8_buffer_x1Temp6);
        }
        else
        {
            matIntemp=matIn;
        }
        u8_data=matIntemp.ptr_uchar;
        memset(matOut->data,0,nnWidth*nnHeight);
        switch(matIn._type)
        {
            case CCV_8UC1:
                mincut=MatCreat(nnHeight,nnWidth,CCV_8UC1,u8_buffer_x3Temp1);
                MyCutminRoi(matIntemp,&mincut,MHC_CUTMIN_1,nStartX,nStartY,nWidth,nHeight);
                cvimgIn=cv::Mat(mincut.nHeight,mincut.nWidth,CV_8U);
                memcpy(cvimgIn.data,mincut.data,getsizeof(mincut._type)*mincut.nHeight*mincut.nWidth);
                switch(distancemod)
                {
                    case MHC_MORPH_RECT:
                        if(distancew>0)
                            cv::dilate(cvimgIn,cvimgIn,kernel_W,cv::Point(-1,-1),distancew);
                        if(distanceh>0)
                            cv::dilate(cvimgIn,cvimgIn,kernel_H,cv::Point(-1,-1),distanceh);
                    break;
                    case MHC_MORPH_ELLIPSE:
                        if((Int32)distancew-1>0)
                            cv::dilate(cvimgIn,cvimgIn,kernel_W,cv::Point(-1,-1),distancew-1);
                        if((Int32)distanceh-1>0)
                            cv::dilate(cvimgIn,cvimgIn,kernel_H,cv::Point(-1,-1),distanceh-1);
                        cv::dilate(cvimgIn,cvimgIn,kernel);
                    break;
                    default:
                        return 1;
                    break;
                }
                switch(Mod)
                {
                    case MHC_4LT:
                        numCC=cv::connectedComponentsWithStats(cvimgIn,cvimglib,stats,centroids,4);
                    break;
                    case MHC_8LT:
                        numCC=cv::connectedComponentsWithStats(cvimgIn,cvimglib,stats,centroids,8);
                    break;
                    default:
                        return 1;
                    break;
                }
                imagelab=(Int32*)cvimglib.data;

                if(numCC<=1)
                    return 1;

                if(distancew>0||distanceh>0)
                {
                    for(n=1;n<numCC;n++)
                    {
                        Int32 realPointArea=0;
                        Int32 i,j;

                        tempBlob.xmin=stats.at<int>(n,cv::CC_STAT_LEFT);
                        tempBlob.xmax=stats.at<int>(n,cv::CC_STAT_LEFT)+stats.at<int>(n,cv::CC_STAT_WIDTH)-1;
                        tempBlob.ymin=stats.at<int>(n,cv::CC_STAT_TOP);
                        tempBlob.ymax=stats.at<int>(n,cv::CC_STAT_TOP)+stats.at<int>(n,cv::CC_STAT_HEIGHT)-1;

                        for(j=tempBlob.ymin;j<=tempBlob.ymax;j++)
                        {
                            for(i=tempBlob.xmin;i<=tempBlob.xmax;i++)
                            {
                                if((imagelab[j*nWidth+i]==n)&&(u8_data[(j+nStartY)*nnWidth+(i+nStartX)]!=0))
                                {
                                    realPointArea++;
                                }
                            }
                        }
                        if(realPointArea>=value)
                        {
                            for(j=tempBlob.ymin;j<=tempBlob.ymax;j++)
                            {
                                for(i=tempBlob.xmin;i<=tempBlob.xmax;i++)
                                {
                                    if((imagelab[j*nWidth+i]==n)&&(u8_data[(j+nStartY)*nnWidth+(i+nStartX)]!=0))
                                    {
                                        matOut->data[(j+nStartY)*nnWidth+(i+nStartX)]=255;
                                    }
                                }
                            }
                        }
                    }
                }
                else
                {
                    for(n=1;n<numCC;n++)
                    {
                        Int32 i,j;
                        tempBlob.area=stats.at<int>(n,cv::CC_STAT_AREA);
                        tempBlob.xmin=stats.at<int>(n,cv::CC_STAT_LEFT);
                        tempBlob.xmax=stats.at<int>(n,cv::CC_STAT_LEFT)+stats.at<int>(n,cv::CC_STAT_WIDTH)-1;
                        tempBlob.ymin=stats.at<int>(n,cv::CC_STAT_TOP);
                        tempBlob.ymax=stats.at<int>(n,cv::CC_STAT_TOP)+stats.at<int>(n,cv::CC_STAT_HEIGHT)-1;
                        if(tempBlob.area>=value)
                        {
                            for(j=tempBlob.ymin;j<=tempBlob.ymax;j++)
                            {
                                for(i=tempBlob.xmin;i<=tempBlob.xmax;i++)
                                {
                                    if(imagelab[j*nWidth+i]==n)
                                    {
                                        matOut->data[(j+nStartY)*nnWidth+(i+nStartX)]=255;
                                    }
                                }
                            }
                        }
                    }
                }
                return 0;
            break;
            default:
                return 1;
            break;
        }
    }

    Int8 MyLineCenter_cols(Mat matIn,Mat mask,float *dataOut,Uint8 *dataOutmask)
    {
        Int32 nnWidth=matIn.nWidth;
        Int32 nHeight=matIn.height;
        Int32 nWidth=matIn.width;
        Int32 nStartY=matIn.starty;
        Int32 nStartX=matIn.startx;
        Int32 i,j;

        memset(dataOutmask,0,nnWidth);
        for(i=nStartX;i<nStartX+nWidth;i++)
        {
            Int32 sum_valuecoor=0;
            Int32 sum_value=0;
            for(j=nStartY;j<nStartY+nHeight;j++)
            {
                if(mask.data[j*nnWidth+i]!=0)
                {
                    sum_valuecoor=sum_valuecoor+(Int32)matIn.data[j*nnWidth+i]*j;
                    sum_value=sum_value+matIn.data[j*nnWidth+i];
                    dataOut[i]=(float)sum_valuecoor/sum_value;
                    dataOutmask[i]=1;
                }
            }
        }
        return 0;
    }

    Int8 MyLineCenter_rows(Mat matIn,Mat mask,float *dataOut,Uint8 *dataOutmask)
    {
        Int32 nnWidth=matIn.nWidth;
        Int32 nHeight=matIn.height;
        Int32 nWidth=matIn.width;
        Int32 nStartY=matIn.starty;
        Int32 nStartX=matIn.startx;
        Int32 i,j;

        memset(dataOutmask,0,nnWidth);
        for(j=nStartY;j<nStartY+nHeight;j++)
        {
            Int32 sum_valuecoor=0;
            Int32 sum_value=0;
            for(i=nStartX;i<nStartX+nWidth;i++)
            {
                if(mask.data[j*nnWidth+i]!=0)
                {
                    sum_valuecoor=sum_valuecoor+(Int32)matIn.data[j*nnWidth+i]*i;
                    sum_value=sum_value+matIn.data[j*nnWidth+i];
                    dataOut[j]=(float)sum_valuecoor/sum_value;
                    dataOutmask[j]=1;
                }
            }
        }
        return 0;
    }

    Int8 MyhistoALLgram(Mat matIn,Uint32 *hisOut)
    {
        Int32 nnHeight=matIn.nHeight;
        Int32 nnWidth=matIn.nWidth;
        Int32 i,j;

        memset(hisOut,0,256*sizeof(Uint32));
        switch(matIn._type)
        {
            case CCV_8UC1:
            for(j=0;j<nnHeight;j++)
            {
                for(i=0;i<nnWidth;i++)
                {
                    hisOut[matIn.data[j*nnWidth+i]]++;
                }
            }
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 Myhistogram(Mat matIn,Uint32 *hisOut)
    {
        Int32 nHeight=matIn.height;
        Int32 nWidth=matIn.width;
        Int32 nStartY=matIn.starty;
        Int32 nStartX=matIn.startx;
        Int32 nnWidth=matIn.nWidth;
        Int32 i,j;
        memset(hisOut,0,256*sizeof(Uint32));
        switch(matIn._type)
        {
            case CCV_8UC1:
                {
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        for(i=nStartX;i<nStartX+nWidth;i++)
                        {
                            hisOut[matIn.data[j*nnWidth+i]]++;
                        }
                    }
                }
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 MyhistoMaskgram(Mat matIn,Mat mask,Uint32 *hisOut)
    {
        Int32 i,j;
        Int32 nnWidth=matIn.nWidth;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        memset(hisOut,0,sizeof(Uint32)*256);
        switch(matIn._type)
        {
            case CCV_8UC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(mask.data[j*nnWidth+i]!=0)
                        {
                            hisOut[matIn.data[j*nnWidth+i]]++;
                        }
                    }
                }
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 MyhistMatch(Mat matIn,Mat *matOut,Mat histmatIn)
    {
        Int32 i,j;
        Int32 nnWidth=matIn.nWidth;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        Int32 nSrcPixNum,nDstPixNum;
        Int32 *arraySrcNum=(Int32*)CV_hist;
        Int32 *arrayDstNum=(Int32*)CV_pp;
        float *f_arraySrcMap=(float*)CV_hist;
        float *f_arrayDstMap=(float*)CV_pp;
        Int32 *i32_arraySrcMap=(Int32*)CV_hist;
        Int32 *i32_arrayDstMap=(Int32*)CV_pp;
        Int32 *grayMatchMap=(Int32*)CV_g;
        Int32 Sun_arraySrcNum=0;
        Int32 Sun_arrayDstNum=0;

        if(matIn._type!=CCV_8UC1||histmatIn._type!=CCV_8UC1)
            return 1;

        switch(matIn._type)
        {
            case CCV_8UC1:
                Myhistogram(matIn,(Uint32*)arraySrcNum);
                Myhistogram(histmatIn,(Uint32*)arrayDstNum);
                nSrcPixNum=matIn.width*matIn.height;
                nDstPixNum=histmatIn.width*histmatIn.height;
                if(nDstPixNum!=nSrcPixNum)
                {
                    for (i=0;i<256;i++)
                    {
                        Sun_arraySrcNum=Sun_arraySrcNum+arraySrcNum[i];
                        Sun_arrayDstNum=Sun_arrayDstNum+arrayDstNum[i];
                        f_arraySrcMap[i]=(float)Sun_arraySrcNum/nSrcPixNum;
                        f_arrayDstMap[i]=(float)Sun_arrayDstNum/nDstPixNum;
                    }
                    for (i=0;i<256;i++)
                    {
                        float nValue=0;
                        float nValue_1=0;
                        Int32 k=0;
                        float nTemp=f_arraySrcMap[i];
                        for (j=0;j<256;j++)
                        {
                            if(nTemp==f_arrayDstMap[j])
                            {
                                nValue+=j;
                                k++;
                            }
                            if(nTemp<f_arrayDstMap[j])
                            {
                                nValue_1=j;
                                break;
                            }
                        }
                        if (k==0)// 离散情况下，反函数可能有些值找不到相对应的，这里去最接近的一个值
                        {
                            nValue=nValue_1;
                            k = 1;
                        }
                        grayMatchMap[i]=nValue/k;
                    }
                }
                else
                {
                    for (i=0;i<256;i++)
                    {
                        Sun_arraySrcNum=Sun_arraySrcNum+arraySrcNum[i];
                        Sun_arrayDstNum=Sun_arrayDstNum+arrayDstNum[i];
                        i32_arraySrcMap[i]=Sun_arraySrcNum;
                        i32_arrayDstMap[i]=Sun_arrayDstNum;
                    }
                    for (i=0;i<256;i++)
                    {
                        Int32 nValue=0;
                        Int32 nValue_1=0;
                        Int32 k=0;
                        Int32 nTemp=i32_arraySrcMap[i];
                        for (j=0;j<256;j++)
                        {
                            if(nTemp==i32_arrayDstMap[j])
                            {
                                nValue+=j;
                                k++;
                            }
                            if(nTemp<i32_arrayDstMap[j])
                            {
                                nValue_1=j;
                                break;
                            }
                        }
                        if (k==0)// 离散情况下，反函数可能有些值找不到相对应的，这里去最接近的一个值
                        {
                            nValue=nValue_1;
                            k = 1;
                        }
                        grayMatchMap[i]=nValue/k;
                    }
                }
                matOut->nWidth=matIn.nWidth;
                matOut->nHeight=matIn.nHeight;
                matOut->startx=matIn.startx;
                matOut->starty=matIn.starty;
                matOut->width=matIn.width;
                matOut->height=matIn.height;
                MyconvertTo(matOut,matIn._type);
                if(matOut->data!=matIn.data)
                {
                    MatSet1col(matOut,0);
                }
                else
                {
                    MyCutRoiSetZero(matOut);
                }
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        matOut->ptr_uchar[j*nnWidth+i]=grayMatchMap[matIn.ptr_uchar[j*nnWidth+i]];
                    }
                }
                break;
            default:
                return 1;
            break;
        }

        return 0;
    }

    Int8 Myregion_coloruse_label(MyConect *ImageConectIn_Out)
    {
        Int32 n,m;
        for(n=0;n<ImageConectIn_Out->AllMarkPointCount;n++)
        {
            for(m=0;m<ImageConectIn_Out->AllMarkPoint[n].PointArea;m++)
            {
                ImageConectIn_Out->AllMarkPoint[n].color=n;
            }
        }
        return 0;
    }

    Int8 Myregion_to_bin(MyConect *ImageConectIn,Mat *matOut,Int32 value)
    {
        Int32 nnWidth=ImageConectIn->nWidth;
        Int32 nStartX=ImageConectIn->startx;
        Int32 nStartY=ImageConectIn->starty;
        Int32 nWidth=ImageConectIn->width;
        Int32 nHeight=ImageConectIn->height;
        Int32 i,j;
        Int32 n,m;

        matOut->nWidth=ImageConectIn->nWidth;
        matOut->nHeight=ImageConectIn->nHeight;
        MyCutselfRoi(matOut,nStartX,nStartY,nWidth,nHeight);
        MyconvertTo(matOut,CCV_8UC1);
        MatSet1col(matOut,0);
        for(n=0;n<ImageConectIn->AllMarkPointCount;n++)
        {
            for(m=0;m<ImageConectIn->AllMarkPoint[n].PointArea;m++)
            {
                i=ImageConectIn->AllMarkPoint[n].point[m].x;
                j=ImageConectIn->AllMarkPoint[n].point[m].y;
                matOut->data[j*nnWidth+i]=value;
            }
        }
        return 0;
    }

    Int8 Myregion_to_add(MyConect *ImageConectIn,Mat *matIn_Out,Int32 color)
    {
        Int32 m,n;
        Int32 nnWidth=matIn_Out->nWidth;

        if(0!=judgeCImageSize(ImageConectIn,*matIn_Out))
            return 1;
        switch(matIn_Out->_type)
        {
            case CCV_8UC1:
                for(m=0;m<ImageConectIn->AllMarkPointCount;m++)
                {
                    for(n=0;n<ImageConectIn->AllMarkPoint[m].PointArea;n++)
                    {
                        Int32 i=ImageConectIn->AllMarkPoint[m].point[n].x;
                        Int32 j=ImageConectIn->AllMarkPoint[m].point[n].y;
                        matIn_Out->ptr_uchar[j*nnWidth+i]=(Uint8)color;
                    }
                }
            break;
            case CCV_8UC3:
                for(m=0;m<ImageConectIn->AllMarkPointCount;m++)
                {
                    for(n=0;n<ImageConectIn->AllMarkPoint[m].PointArea;n++)
                    {
                        Int32 i=ImageConectIn->AllMarkPoint[m].point[n].x;
                        Int32 j=ImageConectIn->AllMarkPoint[m].point[n].y;
                        matIn_Out->ptr_Vec3b[j*nnWidth+i].data1=(Uint8)color;
                        matIn_Out->ptr_Vec3b[j*nnWidth+i].data2=(Uint8)color;
                        matIn_Out->ptr_Vec3b[j*nnWidth+i].data3=(Uint8)color;
                    }
                }
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 Myregion_to_add3col(MyConect *ImageConectIn,Mat *matIn_Out,Int32 color1,Int32 color2,Int32 color3)
    {
        Int32 m,n;
        Int32 color=(color1+color2+color3)/3;
        Int32 nnWidth=matIn_Out->nWidth;

        if(0!=judgeCImageSize(ImageConectIn,*matIn_Out))
            return 1;
        switch(matIn_Out->_type)
        {
            case CCV_8UC1:
                for(m=0;m<ImageConectIn->AllMarkPointCount;m++)
                {
                    for(n=0;n<ImageConectIn->AllMarkPoint[m].PointArea;n++)
                    {
                        Int32 i=ImageConectIn->AllMarkPoint[m].point[n].x;
                        Int32 j=ImageConectIn->AllMarkPoint[m].point[n].y;
                        matIn_Out->ptr_uchar[j*nnWidth+i]=(Uint8)color;
                    }
                }
            break;
            case CCV_8UC3:
                for(m=0;m<ImageConectIn->AllMarkPointCount;m++)
                {
                    for(n=0;n<ImageConectIn->AllMarkPoint[m].PointArea;n++)
                    {
                        Int32 i=ImageConectIn->AllMarkPoint[m].point[n].x;
                        Int32 j=ImageConectIn->AllMarkPoint[m].point[n].y;
                        matIn_Out->ptr_Vec3b[j*nnWidth+i].data1=color1;
                        matIn_Out->ptr_Vec3b[j*nnWidth+i].data2=color2;
                        matIn_Out->ptr_Vec3b[j*nnWidth+i].data3=color3;
                    }
                }
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 Myregion_to_label(MyConect *ImageConectIn,Mat *ImageConectOutLab)
    {
        Int32 nnWidth=ImageConectIn->nWidth;
        Int32 nStartX=ImageConectIn->startx;
        Int32 nStartY=ImageConectIn->starty;
        Int32 nWidth=ImageConectIn->width;
        Int32 nHeight=ImageConectIn->height;
        Int32 i,j;
        Int32 n,m;

        ImageConectOutLab->nWidth=ImageConectIn->nWidth;
        ImageConectOutLab->nHeight=ImageConectIn->nHeight;
        MyCutselfRoi(ImageConectOutLab,nStartX,nStartY,nWidth,nHeight);
        MyconvertTo(ImageConectOutLab,CCV_8UC1);
        MatSet1col(ImageConectOutLab,0);
        for(n=0;n<ImageConectIn->AllMarkPointCount;n++)
        {
            for(m=0;m<ImageConectIn->AllMarkPoint[n].PointArea;m++)
            {
                i=ImageConectIn->AllMarkPoint[n].point[m].x;
                j=ImageConectIn->AllMarkPoint[n].point[m].y;
                ImageConectOutLab->data[j*nnWidth+i]=n+1;
            }
        }
        return 0;
    }

    Int8 Mylinegion_to_add(MyCountLine *LineIn,Mat *matIn_Out,Int32 color,linetype connectivity,Int32 thickness)
    {
        Int32 n;
        if(0!=judgeLMaskSize(LineIn,*matIn_Out))
            return 1;
        switch(matIn_Out->_type)
        {
            case CCV_8UC1:
                for(n=0;n<LineIn->linenum;n++)
                {
                    L_Point32 st,ed;
                    st.x=LineIn->line[n].st.x;
                    st.y=LineIn->line[n].st.y;
                    ed.x=LineIn->line[n].ed.x;
                    ed.y=LineIn->line[n].ed.y;
                    MyLine(matIn_Out,st,ed,color,connectivity,thickness);
                }
            case CCV_8UC3:
                for(n=0;n<LineIn->linenum;n++)
                {
                    L_Point32 st,ed;
                    st.x=LineIn->line[n].st.x;
                    st.y=LineIn->line[n].st.y;
                    ed.x=LineIn->line[n].ed.x;
                    ed.y=LineIn->line[n].ed.y;
                    MyLine3col(matIn_Out,st,ed,color,color,color,connectivity,thickness);
                }
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 Mylinegion_to_add3col(MyCountLine *LineIn,Mat *matIn_Out,Int32 color1,Int32 color2,Int32 color3,linetype connectivity,Int32 thickness)
    {
        Int32 color=(color1+color2+color3)/3;
        Int32 n;
        if(0!=judgeLMaskSize(LineIn,*matIn_Out))
            return 1;
        switch(matIn_Out->_type)
        {
            case CCV_8UC1:
                for(n=0;n<LineIn->linenum;n++)
                {
                    L_Point32 st,ed;
                    st.x=LineIn->line[n].st.x;
                    st.y=LineIn->line[n].st.y;
                    ed.x=LineIn->line[n].ed.x;
                    ed.y=LineIn->line[n].ed.y;
                    MyLine(matIn_Out,st,ed,color,connectivity,thickness);
                }
            case CCV_8UC3:
                for(n=0;n<LineIn->linenum;n++)
                {
                    L_Point32 st,ed;
                    st.x=LineIn->line[n].st.x;
                    st.y=LineIn->line[n].st.y;
                    ed.x=LineIn->line[n].ed.x;
                    ed.y=LineIn->line[n].ed.y;
                    MyLine3col(matIn_Out,st,ed,color1,color2,color3,connectivity,thickness);
                }
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int32 draw_houghrho_to_xyrho(Uint16 rhoIn,Uint32 nWidth,Uint32 nHeight)
    {
        Int32    normLength;
        Int32    diameter;
        Int32	 rho=rhoIn;
        diameter=SQRTof2_Q8 * MAX(nWidth, nHeight);
        normLength=(MHC_ROLENGTH<<16)/(SQRTof2_Q8 * MAX(nWidth, nHeight))/2;
        rho=(((rho<<16)+32768)/normLength-diameter);
        return 	rho;
    }

    Uint16 draw_xyrho_to_houghrho(Int32 rhoIn,Uint32 nWidth,Uint32 nHeight)
    {
        Int32    normLength;
        Int32    diameter;
        Int32 	 r1=rhoIn;
        Uint16	 rho;

        diameter=SQRTof2_Q8 * MAX(nWidth, nHeight);
        normLength=(MHC_ROLENGTH << 16)/(SQRTof2_Q8 * MAX(nWidth, nHeight))/2;
        rho=(Uint16)(((r1+diameter)*normLength+32768)>>16);
        return 	rho;
    }

    Int8 Mylinekb_to_gion(double *k_In,double *b_In,Int32 num,Uint32 nHeight,Uint32 nWidth,MyCountLine *LineOut)
    {
        Int32 n;
        double everTheta = CV_PI/MHC_TETARANGE;
        Mat matIn=MatCreat(nHeight,nWidth,CCV_8UC1,(Uint8*)u8_buffer_x1Temp4);

        LineOut->nHeight=nHeight;
        LineOut->nWidth=nWidth;
        LineOut->linenum=num;
        LineOut->width=nWidth;
        LineOut->height=nHeight;
        LineOut->startx=0;
        LineOut->starty=0;
        for(n=0;n<num;n++)
        {
            double rand=atan(-1/k_In[n]);
            double row=sin(rand)*b_In[n];

            L_Point32 pt1,pt2,realpt1,realpt2;
            Int16 stx,sty,edx,edy;

            LineOut->houghinfo[n].theta=(MHC_TETARANGE>>1)+rand/everTheta;
            LineOut->houghinfo[n].rho=draw_xyrho_to_houghrho(row,nWidth,nHeight);
            pt1.x=0;
            pt1.y=(Int32)(b_In[n]);
            pt2.x=nWidth;
            pt2.y=(Int32)(nWidth*k_In[n]+b_In[n]);

            MyLineComperMat4(&matIn,pt1,pt2,CV_LINE_8LT,&realpt1,&realpt2);

            stx=realpt1.x;
            sty=realpt1.y;
            edx=realpt2.x;
            edy=realpt2.y;

            LineOut->line[n].st.x=stx;
            LineOut->line[n].st.y=sty;
            LineOut->line[n].ed.x=edx;
            LineOut->line[n].ed.y=edy;
        }
        return 0;
    }

    Int8 Mylinedb_to_gion(double *X_dif,double *Y_dif,double *X_pos,double *Y_pos,Int32 num,Uint32 nHeight,Uint32 nWidth,MyCountLine *LineOut)
    {
        Int32 n;
        Int32 linelong=sqrt((float)(nWidth*nWidth+nHeight*nHeight))+1;
        double everTheta = CV_PI/MHC_TETARANGE;
        Mat matIn=MatCreat(nHeight,nWidth,CCV_8UC1,(Uint8*)u8_buffer_x1Temp4);

        LineOut->nHeight=nHeight;
        LineOut->nWidth=nWidth;
        LineOut->linenum=num;
        LineOut->width=nWidth;
        LineOut->height=nHeight;
        LineOut->startx=0;
        LineOut->starty=0;

        for(n=0;n<num;n++)
        { 
            L_Point32 pt1,pt2,realpt1,realpt2;
            Int16 stx,sty,edx,edy;


            pt1.x=(X_pos[n]+X_dif[n]*linelong)+0.5;
            pt1.y=(Y_pos[n]+Y_dif[n]*linelong)+0.5;
            pt2.x=(X_pos[n]-X_dif[n]*linelong)+0.5;
            pt2.y=(Y_pos[n]-Y_dif[n]*linelong)+0.5;

            MyLineComperMat4(&matIn,pt1,pt2,CV_LINE_8LT,&realpt1,&realpt2);

            stx=realpt1.x;
            sty=realpt1.y;
            edx=realpt2.x;
            edy=realpt2.y;

            LineOut->line[n].st.x=stx;
            LineOut->line[n].st.y=sty;
            LineOut->line[n].ed.x=edx;
            LineOut->line[n].ed.y=edy;

            if(stx==edx)
            {
                LineOut->houghinfo[n].theta=MHC_TETARANGE/2;
                LineOut->houghinfo[n].rho=draw_xyrho_to_houghrho(X_pos[n],nWidth,nHeight);
            }
            else
            {
                double k_In=Y_dif[n]/X_dif[n],b_In=-k_In*X_pos[n]+Y_pos[n];
                double rand=atan(-1/k_In);
                double row=sin(rand)*b_In;
                LineOut->houghinfo[n].theta=(MHC_TETARANGE>>1)+rand/everTheta;
                LineOut->houghinfo[n].rho=draw_xyrho_to_houghrho(row,nWidth,nHeight);
            }
        }

        return 0;
    }

    Int8 Mymat_to_binself(Mat *matIn_Out,double value)
    {
        Int32 nnWidth=matIn_Out->nWidth;
        Int32 nStartX=matIn_Out->startx;
        Int32 nStartY=matIn_Out->starty;
        Int32 nWidth=matIn_Out->width;
        Int32 nHeight=matIn_Out->height;
        Int32 i,j;

        Uint8 *u8_data;
        Int8 *i8_data;
        Uint16 *u16_data;
        Int16 *i16_data;
        Int32 *i32_data;
        float *f_data;
        double *d_data;
        Vec3b *u8_3data;
        Vec3ib *i8_3data;
        Vec3s *u16_3data;
        Vec3w *i16_3data;
        Vec3i *i32_3data;
        Vec3f *f_3data;
        Vec3d *d_3data;
        Int32 i32_value=(Int32)(value+0.5);
        float f_value=(float)value;

        switch(matIn_Out->_type)
        {
            case CCV_8UC1:
                u8_data=matIn_Out->ptr_uchar;
                if(i32_value==255)
                {
                    IMG_thr_gt2max_8(&u8_data[nStartY*nnWidth],&u8_data[nStartY*nnWidth],nnWidth,nHeight,0);
                }
                else
                {
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        for(i=nStartX;i<nStartX+nWidth;i++)
                        {
                            if(u8_data[j*nnWidth+i]!=0)
                            {
                                u8_data[j*nnWidth+i]=(Uint8)i32_value;
                            }
                        }
                    }
                }
            break;
            case CCV_8UC3:
                u8_3data=matIn_Out->ptr_Vec3b;
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(u8_3data[j*nnWidth+i].data1!=0||
                           u8_3data[j*nnWidth+i].data2!=0||
                           u8_3data[j*nnWidth+i].data3!=0)
                        {
                            u8_3data[j*nnWidth+i].data1=(Uint8)i32_value;
                            u8_3data[j*nnWidth+i].data2=(Uint8)i32_value;
                            u8_3data[j*nnWidth+i].data3=(Uint8)i32_value;
                        }
                    }
                }
            break;
            case CCV_8SC1:
                i8_data=matIn_Out->ptr_char;
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(i8_data[j*nnWidth+i]!=0)
                        {
                            i8_data[j*nnWidth+i]=(Int8)i32_value;
                        }
                    }
                }
            break;
            case CCV_8SC3:
                i8_3data=matIn_Out->ptr_Vec3ib;
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(i8_3data[j*nnWidth+i].data1!=0||
                           i8_3data[j*nnWidth+i].data2!=0||
                           i8_3data[j*nnWidth+i].data3!=0)
                        {
                            i8_3data[j*nnWidth+i].data1=(Int8)i32_value;
                            i8_3data[j*nnWidth+i].data2=(Int8)i32_value;
                            i8_3data[j*nnWidth+i].data3=(Int8)i32_value;
                        }
                    }
                }
            break;
            case CCV_16UC1:
                u16_data=matIn_Out->ptr_ushort;
                if(i32_value==0xffff)
                {
                    IMG_thr_gt2max_16(&u16_data[nStartY*nnWidth],&u16_data[nStartY*nnWidth],nnWidth,nHeight,0);
                }
                else
                {
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        for(i=nStartX;i<nStartX+nWidth;i++)
                        {
                            if(u16_data[j*nnWidth+i]!=0)
                            {
                                u16_data[j*nnWidth+i]=(Uint16)i32_value;
                            }
                        }
                    }
                }
            break;
            case CCV_16UC3:
                u16_3data=matIn_Out->ptr_Vec3s;
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(u16_3data[j*nnWidth+i].data1!=0||
                           u16_3data[j*nnWidth+i].data2!=0||
                           u16_3data[j*nnWidth+i].data3!=0)
                        {
                            u16_3data[j*nnWidth+i].data1=(Uint16)i32_value;
                            u16_3data[j*nnWidth+i].data2=(Uint16)i32_value;
                            u16_3data[j*nnWidth+i].data3=(Uint16)i32_value;
                        }
                    }
                }
            break;
            case CCV_16SC1:
                i16_data=matIn_Out->ptr_short;
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(i16_data[j*nnWidth+i]!=0)
                        {
                            i16_data[j*nnWidth+i]=(Int16)i32_value;
                        }
                    }
                }
            break;
            case CCV_16SC3:
                i16_3data=matIn_Out->ptr_Vec3w;
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(i16_3data[j*nnWidth+i].data1!=0||
                           i16_3data[j*nnWidth+i].data2!=0||
                           i16_3data[j*nnWidth+i].data3!=0)
                        {
                            i16_3data[j*nnWidth+i].data1=(Int16)i32_value;
                            i16_3data[j*nnWidth+i].data2=(Int16)i32_value;
                            i16_3data[j*nnWidth+i].data3=(Int16)i32_value;
                        }
                    }
                }
            break;
            case CCV_32SC1:
                i32_data=matIn_Out->ptr_int;
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(i32_data[j*nnWidth+i]!=0)
                        {
                            i32_data[j*nnWidth+i]=(Int32)i32_value;
                        }
                    }
                }
            break;
            case CCV_32SC3:
                i32_3data=matIn_Out->ptr_Vec3i;
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(i32_3data[j*nnWidth+i].data1!=0||
                           i32_3data[j*nnWidth+i].data2!=0||
                           i32_3data[j*nnWidth+i].data3!=0)
                        {
                            i32_3data[j*nnWidth+i].data1=(Int32)i32_value;
                            i32_3data[j*nnWidth+i].data2=(Int32)i32_value;
                            i32_3data[j*nnWidth+i].data3=(Int32)i32_value;
                        }
                    }
                }
            break;
            case CCV_32FC1:
                f_data=matIn_Out->ptr_float;
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(f_data[j*nnWidth+i]!=0)
                        {
                            f_data[j*nnWidth+i]=f_value;
                        }
                    }
                }
            break;
            case CCV_32FC3:
                f_3data=matIn_Out->ptr_Vec3f;
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(f_3data[j*nnWidth+i].data1!=0||
                           f_3data[j*nnWidth+i].data2!=0||
                           f_3data[j*nnWidth+i].data3!=0)
                        {
                            f_3data[j*nnWidth+i].data1=f_value;
                            f_3data[j*nnWidth+i].data2=f_value;
                            f_3data[j*nnWidth+i].data3=f_value;
                        }
                    }
                }
            break;
            case CCV_64FC1:
                d_data=matIn_Out->ptr_double;
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(d_data[j*nnWidth+i]!=0)
                        {
                            d_data[j*nnWidth+i]=value;
                        }
                    }
                }
            break;
            case CCV_64FC3:
                d_3data=matIn_Out->ptr_Vec3d;
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(d_3data[j*nnWidth+i].data1!=0||
                           d_3data[j*nnWidth+i].data2!=0||
                           d_3data[j*nnWidth+i].data3!=0)
                        {
                            d_3data[j*nnWidth+i].data1=value;
                            d_3data[j*nnWidth+i].data2=value;
                            d_3data[j*nnWidth+i].data3=value;
                        }
                    }
                }
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 Mymat_to_bin(Mat matIn,Mat *matOut,double value)
    {
        Int32 nnWidth=matIn.nWidth;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        Int32 i,j;

        Uint8 *u8_data;
        Int8 *i8_data;
        Uint16 *u16_data;
        Int16 *i16_data;
        Int32 *i32_data;
        float *f_data;
        double *d_data;
        Vec3b *u8_3data;
        Vec3ib *i8_3data;
        Vec3s *u16_3data;
        Vec3w *i16_3data;
        Vec3i *i32_3data;
        Vec3f *f_3data;
        Vec3d *d_3data;
        Int32 i32_value=(Int32)(value+0.5);
        float f_value=(float)value;

        getcloneinfo(matIn,matOut);

        switch(matIn._type)
        {
            case CCV_8UC1:
                u8_data=matIn.ptr_uchar;
                if(i32_value==255)
                {
                    IMG_thr_gt2max_8(&u8_data[nStartY*nnWidth],&matOut->ptr_uchar[nStartY*nnWidth],nnWidth,nHeight,0);
                }
                else
                {
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        for(i=nStartX;i<nStartX+nWidth;i++)
                        {
                            if(u8_data[j*nnWidth+i]!=0)
                            {
                                matOut->ptr_uchar[j*nnWidth+i]=(Uint8)i32_value;
                            }
                        }
                    }
                }
            break;
            case CCV_8UC3:
                u8_3data=matIn.ptr_Vec3b;
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(u8_3data[j*nnWidth+i].data1!=0||
                           u8_3data[j*nnWidth+i].data2!=0||
                           u8_3data[j*nnWidth+i].data3!=0)
                        {
                            matOut->ptr_Vec3b[j*nnWidth+i].data1=(Uint8)i32_value;
                            matOut->ptr_Vec3b[j*nnWidth+i].data2=(Uint8)i32_value;
                            matOut->ptr_Vec3b[j*nnWidth+i].data3=(Uint8)i32_value;
                        }
                    }
                }
            break;
            case CCV_8SC1:
                i8_data=matIn.ptr_char;
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(i8_data[j*nnWidth+i]!=0)
                        {
                            matOut->ptr_char[j*nnWidth+i]=(Int8)i32_value;
                        }
                    }
                }
            break;
            case CCV_8SC3:
                i8_3data=matIn.ptr_Vec3ib;
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(i8_3data[j*nnWidth+i].data1!=0||
                           i8_3data[j*nnWidth+i].data2!=0||
                           i8_3data[j*nnWidth+i].data3!=0)
                        {
                            matOut->ptr_Vec3ib[j*nnWidth+i].data1=(Int8)i32_value;
                            matOut->ptr_Vec3ib[j*nnWidth+i].data2=(Int8)i32_value;
                            matOut->ptr_Vec3ib[j*nnWidth+i].data3=(Int8)i32_value;
                        }
                    }
                }
            break;
            case CCV_16UC1:
                u16_data=matIn.ptr_ushort;
                if(i32_value==0xffff)
                {
                    IMG_thr_gt2max_16(&u16_data[nStartY*nnWidth],&matOut->ptr_ushort[nStartY*nnWidth],nnWidth,nHeight,0);
                }
                else
                {
                    for(j=nStartY;j<nStartY+nHeight;j++)
                    {
                        for(i=nStartX;i<nStartX+nWidth;i++)
                        {
                            if(u16_data[j*nnWidth+i]!=0)
                            {
                                matOut->ptr_ushort[j*nnWidth+i]=(Uint16)i32_value;
                            }
                        }
                    }
                }
            break;
            case CCV_16UC3:
                u16_3data=matIn.ptr_Vec3s;
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(u16_3data[j*nnWidth+i].data1!=0||
                           u16_3data[j*nnWidth+i].data2!=0||
                           u16_3data[j*nnWidth+i].data3!=0)
                        {
                            matOut->ptr_Vec3s[j*nnWidth+i].data1=(Uint16)i32_value;
                            matOut->ptr_Vec3s[j*nnWidth+i].data2=(Uint16)i32_value;
                            matOut->ptr_Vec3s[j*nnWidth+i].data3=(Uint16)i32_value;
                        }
                    }
                }
            break;
            case CCV_16SC1:
                i16_data=matIn.ptr_short;
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(i16_data[j*nnWidth+i]!=0)
                        {
                            matOut->ptr_short[j*nnWidth+i]=(Int16)i32_value;
                        }
                    }
                }
            break;
            case CCV_16SC3:
                i16_3data=matIn.ptr_Vec3w;
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(i16_3data[j*nnWidth+i].data1!=0||
                           i16_3data[j*nnWidth+i].data2!=0||
                           i16_3data[j*nnWidth+i].data3!=0)
                        {
                            matOut->ptr_Vec3w[j*nnWidth+i].data1=(Int16)i32_value;
                            matOut->ptr_Vec3w[j*nnWidth+i].data2=(Int16)i32_value;
                            matOut->ptr_Vec3w[j*nnWidth+i].data3=(Int16)i32_value;
                        }
                    }
                }
            break;
            case CCV_32SC1:
                i32_data=matIn.ptr_int;
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(i32_data[j*nnWidth+i]!=0)
                        {
                            matOut->ptr_int[j*nnWidth+i]=(Int32)i32_value;
                        }
                    }
                }
            break;
            case CCV_32SC3:
                i32_3data=matIn.ptr_Vec3i;
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(i32_3data[j*nnWidth+i].data1!=0||
                           i32_3data[j*nnWidth+i].data2!=0||
                           i32_3data[j*nnWidth+i].data3!=0)
                        {
                            matOut->ptr_Vec3i[j*nnWidth+i].data1=(Int32)i32_value;
                            matOut->ptr_Vec3i[j*nnWidth+i].data2=(Int32)i32_value;
                            matOut->ptr_Vec3i[j*nnWidth+i].data3=(Int32)i32_value;
                        }
                    }
                }
            break;
            case CCV_32FC1:
                f_data=matIn.ptr_float;
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(f_data[j*nnWidth+i]!=0)
                        {
                            matOut->ptr_float[j*nnWidth+i]=f_value;
                        }
                    }
                }
            break;
            case CCV_32FC3:
                f_3data=matIn.ptr_Vec3f;
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(f_3data[j*nnWidth+i].data1!=0||
                           f_3data[j*nnWidth+i].data2!=0||
                           f_3data[j*nnWidth+i].data3!=0)
                        {
                            matOut->ptr_Vec3f[j*nnWidth+i].data1=f_value;
                            matOut->ptr_Vec3f[j*nnWidth+i].data2=f_value;
                            matOut->ptr_Vec3f[j*nnWidth+i].data3=f_value;
                        }
                    }
                }
            break;
            case CCV_64FC1:
                d_data=matIn.ptr_double;
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(d_data[j*nnWidth+i]!=0)
                        {
                            matOut->ptr_double[j*nnWidth+i]=value;
                        }
                    }
                }
            break;
            case CCV_64FC3:
                d_3data=matIn.ptr_Vec3d;
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(d_3data[j*nnWidth+i].data1!=0||
                           d_3data[j*nnWidth+i].data2!=0||
                           d_3data[j*nnWidth+i].data3!=0)
                        {
                            matOut->ptr_Vec3d[j*nnWidth+i].data1=value;
                            matOut->ptr_Vec3d[j*nnWidth+i].data2=value;
                            matOut->ptr_Vec3d[j*nnWidth+i].data3=value;
                        }
                    }
                }
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 Mymat_to_bin3colself(Mat *matIn_Out,double value1,double value2,double value3)
    {
        Int32 nnWidth=matIn_Out->nWidth;
        Int32 nStartX=matIn_Out->startx;
        Int32 nStartY=matIn_Out->starty;
        Int32 nWidth=matIn_Out->width;
        Int32 nHeight=matIn_Out->height;
        Int32 i,j;

        Uint8 *u8_data;
        Int8 *i8_data;
        Uint16 *u16_data;
        Int16 *i16_data;
        Int32 *i32_data;
        float *f_data;
        double *d_data;
        Vec3b *u8_3data;
        Vec3ib *i8_3data;
        Vec3s *u16_3data;
        Vec3w *i16_3data;
        Vec3i *i32_3data;
        Vec3f *f_3data;
        Vec3d *d_3data;
        Int32 i32_value=(Int32)(value1+value2+value3)/3;
        float f_value=(float)(value1+value2+value3)/3;
        double value=(value1+value2+value3)/3;
        Int32 i32_value1=(Int32)(value1+0.5);
        Int32 i32_value2=(Int32)(value2+0.5);
        Int32 i32_value3=(Int32)(value3+0.5);
        float f_value1=(float)value1;
        float f_value2=(float)value2;
        float f_value3=(float)value3;

        switch(matIn_Out->_type)
        {
            case CCV_8UC1:
                u8_data=matIn_Out->ptr_uchar;
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(u8_data[j*nnWidth+i]!=0)
                        {
                            u8_data[j*nnWidth+i]=(Uint8)i32_value;
                        }
                    }
                }
            break;
            case CCV_8UC3:
                u8_3data=matIn_Out->ptr_Vec3b;
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(u8_3data[j*nnWidth+i].data1!=0||
                           u8_3data[j*nnWidth+i].data2!=0||
                           u8_3data[j*nnWidth+i].data3!=0)
                        {
                            u8_3data[j*nnWidth+i].data1=(Uint8)i32_value1;
                            u8_3data[j*nnWidth+i].data2=(Uint8)i32_value2;
                            u8_3data[j*nnWidth+i].data3=(Uint8)i32_value3;
                        }
                    }
                }
            break;
            case CCV_8SC1:
                i8_data=matIn_Out->ptr_char;
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(i8_data[j*nnWidth+i]!=0)
                        {
                            i8_data[j*nnWidth+i]=(Int8)i32_value;
                        }
                    }
                }
            break;
            case CCV_8SC3:
                i8_3data=matIn_Out->ptr_Vec3ib;
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(i8_3data[j*nnWidth+i].data1!=0||
                           i8_3data[j*nnWidth+i].data2!=0||
                           i8_3data[j*nnWidth+i].data3!=0)
                        {
                            i8_3data[j*nnWidth+i].data1=(Int8)i32_value1;
                            i8_3data[j*nnWidth+i].data2=(Int8)i32_value2;
                            i8_3data[j*nnWidth+i].data3=(Int8)i32_value3;
                        }
                    }
                }
            break;
            case CCV_16UC1:
                u16_data=matIn_Out->ptr_ushort;
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(u16_data[j*nnWidth+i]!=0)
                        {
                            u16_data[j*nnWidth+i]=(Uint16)i32_value;
                        }
                    }
                }
            break;
            case CCV_16UC3:
                u16_3data=matIn_Out->ptr_Vec3s;
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(u16_3data[j*nnWidth+i].data1!=0||
                           u16_3data[j*nnWidth+i].data2!=0||
                           u16_3data[j*nnWidth+i].data3!=0)
                        {
                            u16_3data[j*nnWidth+i].data1=(Uint16)i32_value1;
                            u16_3data[j*nnWidth+i].data2=(Uint16)i32_value2;
                            u16_3data[j*nnWidth+i].data3=(Uint16)i32_value3;
                        }
                    }
                }
            break;
            case CCV_16SC1:
                i16_data=matIn_Out->ptr_short;
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(i16_data[j*nnWidth+i]!=0)
                        {
                            i16_data[j*nnWidth+i]=(Int16)i32_value;
                        }
                    }
                }
            break;
            case CCV_16SC3:
                i16_3data=matIn_Out->ptr_Vec3w;
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(i16_3data[j*nnWidth+i].data1!=0||
                           i16_3data[j*nnWidth+i].data2!=0||
                           i16_3data[j*nnWidth+i].data3!=0)
                        {
                            i16_3data[j*nnWidth+i].data1=(Int16)i32_value1;
                            i16_3data[j*nnWidth+i].data2=(Int16)i32_value2;
                            i16_3data[j*nnWidth+i].data3=(Int16)i32_value3;
                        }
                    }
                }
            break;
            case CCV_32SC1:
                i32_data=matIn_Out->ptr_int;
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(i32_data[j*nnWidth+i]!=0)
                        {
                            i32_data[j*nnWidth+i]=(Int32)i32_value;
                        }
                    }
                }
            break;
            case CCV_32SC3:
                i32_3data=matIn_Out->ptr_Vec3i;
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(i32_3data[j*nnWidth+i].data1!=0||
                           i32_3data[j*nnWidth+i].data2!=0||
                           i32_3data[j*nnWidth+i].data3!=0)
                        {
                            i32_3data[j*nnWidth+i].data1=(Int32)i32_value1;
                            i32_3data[j*nnWidth+i].data2=(Int32)i32_value2;
                            i32_3data[j*nnWidth+i].data3=(Int32)i32_value3;
                        }
                    }
                }
            break;
            case CCV_32FC1:
                f_data=matIn_Out->ptr_float;
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(f_data[j*nnWidth+i]!=0)
                        {
                            f_data[j*nnWidth+i]=f_value;
                        }
                    }
                }
            break;
            case CCV_32FC3:
                f_3data=matIn_Out->ptr_Vec3f;
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(f_3data[j*nnWidth+i].data1!=0||
                           f_3data[j*nnWidth+i].data2!=0||
                           f_3data[j*nnWidth+i].data3!=0)
                        {
                            f_3data[j*nnWidth+i].data1=f_value1;
                            f_3data[j*nnWidth+i].data2=f_value2;
                            f_3data[j*nnWidth+i].data3=f_value3;
                        }
                    }
                }
            break;
            case CCV_64FC1:
                d_data=matIn_Out->ptr_double;
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(d_data[j*nnWidth+i]!=0)
                        {
                            d_data[j*nnWidth+i]=value;
                        }
                    }
                }
            break;
            case CCV_64FC3:
                d_3data=matIn_Out->ptr_Vec3d;
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(d_3data[j*nnWidth+i].data1!=0||
                           d_3data[j*nnWidth+i].data2!=0||
                           d_3data[j*nnWidth+i].data3!=0)
                        {
                            d_3data[j*nnWidth+i].data1=value1;
                            d_3data[j*nnWidth+i].data2=value2;
                            d_3data[j*nnWidth+i].data3=value3;
                        }
                    }
                }
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 MyCopyObj(MyConect *ImageConectIn,MyConect *ImageConectOut,void *bufferIn)
    {
        Int32 aa,bb;
        Int32 Index,num;

        if(ImageConectIn==ImageConectOut)
            return 0;

        ImageConectOut->nHeight=ImageConectIn->nHeight;
        ImageConectOut->nWidth=ImageConectIn->nWidth;
        ImageConectOut->nHeight=ImageConectIn->nHeight;
        ImageConectOut->nWidth=ImageConectIn->nWidth;
        ImageConectOut->startx=ImageConectIn->startx;
        ImageConectOut->starty=ImageConectIn->starty;
        ImageConectOut->height=ImageConectIn->height;
        ImageConectOut->width=ImageConectIn->width;

        ImageConectOut->AllMarkPointCount=0;
        ImageConectOut->mianji=0;
        ImageConectOut->memPoint=(L_Point*)bufferIn;
        aa=0;
        bb=0;
        for(Index=0; Index<ImageConectIn->AllMarkPointCount; Index++)
        {
            aa=0;
            for(num=0; num<ImageConectIn->AllMarkPoint[Index].PointArea; num++)
            {
                ImageConectOut->memPoint[aa+bb].x=ImageConectIn->AllMarkPoint[Index].point[num].x;
                ImageConectOut->memPoint[aa+bb].y=ImageConectIn->AllMarkPoint[Index].point[num].y;
                aa++;
            }
            ImageConectOut->AllMarkPoint[Index].color=ImageConectIn->AllMarkPoint[Index].color;
            ImageConectOut->AllMarkPoint[Index].left=ImageConectIn->AllMarkPoint[Index].left;
            ImageConectOut->AllMarkPoint[Index].right=ImageConectIn->AllMarkPoint[Index].right;
            ImageConectOut->AllMarkPoint[Index].top=ImageConectIn->AllMarkPoint[Index].top;
            ImageConectOut->AllMarkPoint[Index].bottom=ImageConectIn->AllMarkPoint[Index].bottom;
            ImageConectOut->AllMarkPoint[Index].xTotal=ImageConectIn->AllMarkPoint[Index].xTotal;
            ImageConectOut->AllMarkPoint[Index].yTotal=ImageConectIn->AllMarkPoint[Index].yTotal;
            ImageConectOut->AllMarkPoint[Index].PointArea=ImageConectIn->AllMarkPoint[Index].PointArea;
            ImageConectOut->AllMarkPoint[Index].point=&(ImageConectOut->memPoint[bb]);
            bb=aa+bb;
        }
        ImageConectOut->AllMarkPointCount=ImageConectIn->AllMarkPointCount;
        ImageConectOut->mianji=bb;
        return 0;
    }

    Int8 MyCopyObjQuick(MyConect *ImageConectIn,MyConect *ImageConectOut)
    {
        if(ImageConectIn==ImageConectOut)
            return 0;
        *ImageConectOut=*ImageConectIn;
        return 0;
    }

    Int8 Myselect_shape(MyConect *ImageConectIn,MyConect *ImageConectOut,myselect Mod,double value1,double value2)
    {
        Int32 n,m=0;
        Int32 i32_val1=(Int32)value1,i32_val2=(Int32)value2;
        Int32 mianji=0;
        if(ImageConectOut!=ImageConectIn)
        {
            ImageConectOut->mianji=0;
            ImageConectOut->AllMarkPointCount=0;
            ImageConectOut->nHeight=ImageConectIn->nHeight;
            ImageConectOut->nWidth=ImageConectIn->nWidth;
            ImageConectOut->startx=ImageConectIn->startx;
            ImageConectOut->starty=ImageConectIn->starty;
            ImageConectOut->height=ImageConectIn->height;
            ImageConectOut->width=ImageConectIn->width;
            ImageConectOut->memPoint=ImageConectIn->memPoint;
        }
        else
        {
            MyCopyObjQuick(ImageConectIn,&conect_buffer1);
            ImageConectOut->mianji=0;
            ImageConectOut->AllMarkPointCount=0;
        }
        switch(Mod)
        {
            case MHC_CONNECT_WIDTH:
                if(ImageConectOut!=ImageConectIn)
                {
                    for(n=0;n<ImageConectIn->AllMarkPointCount;n++)
                    {
                        Int32 left=ImageConectIn->AllMarkPoint[n].left;
                        Int32 right=ImageConectIn->AllMarkPoint[n].right;
                        Int32 width=right-left+1;
                        if(width>i32_val1&&width<=i32_val2)
                        {
                            ImageConectOut->AllMarkPoint[m]=ImageConectIn->AllMarkPoint[n];
                            mianji=mianji+ImageConectIn->AllMarkPoint[n].PointArea;
                            m++;
                        }
                    }
                }
                else
                {
                    for(n=0;n<conect_buffer1.AllMarkPointCount;n++)
                    {
                        Int32 left=conect_buffer1.AllMarkPoint[n].left;
                        Int32 right=conect_buffer1.AllMarkPoint[n].right;
                        Int32 width=right-left+1;
                        if(width>i32_val1&&width<=i32_val2)
                        {
                            ImageConectOut->AllMarkPoint[m]=conect_buffer1.AllMarkPoint[n];
                            mianji=mianji+conect_buffer1.AllMarkPoint[n].PointArea;
                            m++;
                        }
                    }
                }
            break;
            case MHC_CONNECT_HEIGHT:
                if(ImageConectOut!=ImageConectIn)
                {
                    for(n=0;n<ImageConectIn->AllMarkPointCount;n++)
                    {
                        Int32 top=ImageConectIn->AllMarkPoint[n].top;
                        Int32 bottom=ImageConectIn->AllMarkPoint[n].bottom;
                        Int32 height=bottom-top+1;
                        if(height>i32_val1&&height<=i32_val2)
                        {
                            ImageConectOut->AllMarkPoint[m]=ImageConectIn->AllMarkPoint[n];
                            mianji=mianji+ImageConectIn->AllMarkPoint[n].PointArea;
                            m++;
                        }
                    }
                }
                else
                {
                    for(n=0;n<conect_buffer1.AllMarkPointCount;n++)
                    {
                        Int32 top=conect_buffer1.AllMarkPoint[n].top;
                        Int32 bottom=conect_buffer1.AllMarkPoint[n].bottom;
                        Int32 height=bottom-top+1;
                        if(height>i32_val1&&height<=i32_val2)
                        {
                            ImageConectOut->AllMarkPoint[m]=conect_buffer1.AllMarkPoint[n];
                            mianji=mianji+conect_buffer1.AllMarkPoint[n].PointArea;
                            m++;
                        }
                    }
                }
            break;
            case MHC_CONNECT_WIDTH_HEIGHT:
                if(ImageConectOut!=ImageConectIn)
                {
                    for(n=0;n<ImageConectIn->AllMarkPointCount;n++)
                    {
                        Int32 left=ImageConectIn->AllMarkPoint[n].left;
                        Int32 right=ImageConectIn->AllMarkPoint[n].right;
                        Int32 width=right-left+1;
                        Int32 top=ImageConectIn->AllMarkPoint[n].top;
                        Int32 bottom=ImageConectIn->AllMarkPoint[n].bottom;
                        Int32 height=bottom-top+1;
                        if((height>i32_val1&&height<=i32_val2)||(width>i32_val1&&width<=i32_val2))
                        {
                            ImageConectOut->AllMarkPoint[m]=ImageConectIn->AllMarkPoint[n];
                            mianji=mianji+ImageConectIn->AllMarkPoint[n].PointArea;
                            m++;
                        }
                    }
                }
                else
                {
                    for(n=0;n<conect_buffer1.AllMarkPointCount;n++)
                    {
                        Int32 left=ImageConectIn->AllMarkPoint[n].left;
                        Int32 right=ImageConectIn->AllMarkPoint[n].right;
                        Int32 width=right-left+1;
                        Int32 top=conect_buffer1.AllMarkPoint[n].top;
                        Int32 bottom=conect_buffer1.AllMarkPoint[n].bottom;
                        Int32 height=bottom-top+1;
                        if((height>i32_val1&&height<=i32_val2)||(width>i32_val1&&width<=i32_val2))
                        {
                            ImageConectOut->AllMarkPoint[m]=conect_buffer1.AllMarkPoint[n];
                            mianji=mianji+conect_buffer1.AllMarkPoint[n].PointArea;
                            m++;
                        }
                    }
                }
            break;
            case MHC_CONNECT_DIAGONAL:
                if(ImageConectOut!=ImageConectIn)
                {
                    for(n=0;n<ImageConectIn->AllMarkPointCount;n++)
                    {
                        Int32 left=ImageConectIn->AllMarkPoint[n].left;
                        Int32 right=ImageConectIn->AllMarkPoint[n].right;
                        Int32 width=right-left+1;
                        Int32 top=ImageConectIn->AllMarkPoint[n].top;
                        Int32 bottom=ImageConectIn->AllMarkPoint[n].bottom;
                        Int32 height=bottom-top+1;
                        Int32 dis=width*width+height*height;
                        if(dis>i32_val1*i32_val1&&dis<=i32_val2*i32_val2)
                        {
                            ImageConectOut->AllMarkPoint[m]=ImageConectIn->AllMarkPoint[n];
                            mianji=mianji+ImageConectIn->AllMarkPoint[n].PointArea;
                            m++;
                        }
                    }
                }
                else
                {
                    for(n=0;n<conect_buffer1.AllMarkPointCount;n++)
                    {
                        Int32 left=ImageConectIn->AllMarkPoint[n].left;
                        Int32 right=ImageConectIn->AllMarkPoint[n].right;
                        Int32 width=right-left+1;
                        Int32 top=conect_buffer1.AllMarkPoint[n].top;
                        Int32 bottom=conect_buffer1.AllMarkPoint[n].bottom;
                        Int32 height=bottom-top+1;
                        Int32 dis=width*width+height*height;
                        if(dis>i32_val1*i32_val1&&dis<=i32_val2*i32_val2)
                        {
                            ImageConectOut->AllMarkPoint[m]=conect_buffer1.AllMarkPoint[n];
                            mianji=mianji+conect_buffer1.AllMarkPoint[n].PointArea;
                            m++;
                        }
                    }
                }
            break;
            case MHC_CONNECT_MIANJI:
                if(ImageConectOut!=ImageConectIn)
                {
                    for(n=0;n<ImageConectIn->AllMarkPointCount;n++)
                    {
                        Int32 mianji=ImageConectIn->AllMarkPoint[n].PointArea;
                        if(mianji>i32_val1&&mianji<=i32_val2)
                        {
                            ImageConectOut->AllMarkPoint[m]=ImageConectIn->AllMarkPoint[n];
                            mianji=mianji+ImageConectIn->AllMarkPoint[n].PointArea;
                            m++;
                        }
                    }
                }
                else
                {
                    for(n=0;n<conect_buffer1.AllMarkPointCount;n++)
                    {
                        Int32 mianji=conect_buffer1.AllMarkPoint[n].PointArea;
                        if(mianji>i32_val1&&mianji<=i32_val2)
                        {
                            ImageConectOut->AllMarkPoint[m]=conect_buffer1.AllMarkPoint[n];
                            mianji=mianji+conect_buffer1.AllMarkPoint[n].PointArea;
                            m++;
                        }
                    }
                }
            break;
            case MHC_WEIGHT_X_ROOM:
                if(ImageConectOut!=ImageConectIn)
                {
                    for(n=0;n<ImageConectIn->AllMarkPointCount;n++)
                    {
                        Int32 X=ImageConectIn->AllMarkPoint[n].xTotal/ImageConectIn->AllMarkPoint[n].PointArea;
                        if(X>i32_val1&&X<=i32_val2)
                        {
                            ImageConectOut->AllMarkPoint[m]=ImageConectIn->AllMarkPoint[n];
                            mianji=mianji+ImageConectIn->AllMarkPoint[n].PointArea;
                            m++;
                        }
                    }
                }
                else
                {
                    for(n=0;n<conect_buffer1.AllMarkPointCount;n++)
                    {
                        Int32 X=conect_buffer1.AllMarkPoint[n].xTotal/conect_buffer1.AllMarkPoint[n].PointArea;
                        if(X>i32_val1&&X<=i32_val2)
                        {
                            ImageConectOut->AllMarkPoint[m]=conect_buffer1.AllMarkPoint[n];
                            mianji=mianji+conect_buffer1.AllMarkPoint[n].PointArea;
                            m++;
                        }
                    }
                }
            break;
            case MHC_WEIGHT_Y_ROOM:
                if(ImageConectOut!=ImageConectIn)
                {
                    for(n=0;n<ImageConectIn->AllMarkPointCount;n++)
                    {
                        Int32 Y=ImageConectIn->AllMarkPoint[n].yTotal/ImageConectIn->AllMarkPoint[n].PointArea;
                        if(Y>i32_val1&&Y<=i32_val2)
                        {
                            ImageConectOut->AllMarkPoint[m]=ImageConectIn->AllMarkPoint[n];
                            mianji=mianji+ImageConectIn->AllMarkPoint[n].PointArea;
                            m++;
                        }
                    }
                }
                else
                {
                    for(n=0;n<conect_buffer1.AllMarkPointCount;n++)
                    {
                        Int32 Y=conect_buffer1.AllMarkPoint[n].yTotal/conect_buffer1.AllMarkPoint[n].PointArea;
                        if(Y>i32_val1&&Y<=i32_val2)
                        {
                            ImageConectOut->AllMarkPoint[m]=conect_buffer1.AllMarkPoint[n];
                            mianji=mianji+conect_buffer1.AllMarkPoint[n].PointArea;
                            m++;
                        }
                    }
                }
            break;
            default:
                return 1;
            break;
        }
        ImageConectOut->AllMarkPointCount=m;
        ImageConectOut->mianji=mianji;
        return 0;
    }

    Int8 Mysort_region(MyConect *ImageConectIn,MyConect *ImageConectOut,sortregion Mod)
    {
        Int32 mianji=0;
        Int32 Index;
        Int32 AllMarkPointCount=0;
        if(ImageConectOut!=ImageConectIn)
        {
            ImageConectOut->mianji=0;
            ImageConectOut->AllMarkPointCount=0;
            ImageConectOut->nHeight=ImageConectIn->nHeight;
            ImageConectOut->nWidth=ImageConectIn->nWidth;
            ImageConectOut->startx=ImageConectIn->startx;
            ImageConectOut->starty=ImageConectIn->starty;
            ImageConectOut->height=ImageConectIn->height;
            ImageConectOut->width=ImageConectIn->width;
            ImageConectOut->memPoint=ImageConectIn->memPoint;

            switch(Mod)
            {
                case MHC_MIANJI_PAIXU:
                    for(Index=0; Index<ImageConectIn->AllMarkPointCount; Index++)
                    {
                        paixu_conect[Index].value=ImageConectIn->AllMarkPoint[Index].PointArea;
                        paixu_conect[Index].i=Index;
                    }
                    QuickSortC(paixu_conect,ImageConectIn->AllMarkPointCount);
                break;
                case MHC_LEFTTORIGHT_PAIXU:
                    for(Index=0; Index<ImageConectIn->AllMarkPointCount; Index++)
                    {
                        paixu_conect[Index].value=(float)ImageConectIn->AllMarkPoint[Index].xTotal/ImageConectIn->AllMarkPoint[Index].PointArea;
                        paixu_conect[Index].i=Index;
                    }
                    QuickSortC(paixu_conect,ImageConectIn->AllMarkPointCount);
                break;
                case MHC_RIGHTTOLEFT_PAIXU:
                    for(Index=0; Index<ImageConectIn->AllMarkPointCount; Index++)
                    {
                        paixu_conect[Index].value=(float)ImageConectIn->AllMarkPoint[Index].xTotal/ImageConectIn->AllMarkPoint[Index].PointArea;
                        paixu_conect[Index].i=Index;
                    }
                    QuickSortB(paixu_conect,ImageConectIn->AllMarkPointCount);
                break;
                case MHC_TOPTOBOTTOM_PAIXU:
                    for(Index=0; Index<ImageConectIn->AllMarkPointCount; Index++)
                    {
                        paixu_conect[Index].value=(float)ImageConectIn->AllMarkPoint[Index].yTotal/ImageConectIn->AllMarkPoint[Index].PointArea;
                        paixu_conect[Index].i=Index;
                    }
                    QuickSortC(paixu_conect,ImageConectIn->AllMarkPointCount);
                break;
                case MHC_BOTTOMTOTOP_PAIXU:
                    for(Index=0; Index<ImageConectIn->AllMarkPointCount; Index++)
                    {
                        paixu_conect[Index].value=(float)ImageConectIn->AllMarkPoint[Index].yTotal/ImageConectIn->AllMarkPoint[Index].PointArea;
                        paixu_conect[Index].i=Index;
                    }
                    QuickSortB(paixu_conect,ImageConectIn->AllMarkPointCount);
                break;
                case MHC_LEFT_LEFTTORIGHT_PAIXU:
                    for(Index=0; Index<ImageConectIn->AllMarkPointCount; Index++)
                    {
                        paixu_conect[Index].value=(float)ImageConectIn->AllMarkPoint[Index].left;
                        paixu_conect[Index].i=Index;
                    }
                    QuickSortC(paixu_conect,ImageConectIn->AllMarkPointCount);
                break;
                case MHC_RIGHT_LEFTTORIGHT_PAIXU:
                    for(Index=0; Index<ImageConectIn->AllMarkPointCount; Index++)
                    {
                        paixu_conect[Index].value=(float)ImageConectIn->AllMarkPoint[Index].left;
                        paixu_conect[Index].i=Index;
                    }
                    QuickSortC(paixu_conect,ImageConectIn->AllMarkPointCount);
                break;
                case MHC_LEFT_RIGHTTOLEFT_PAIXU:
                    for(Index=0; Index<ImageConectIn->AllMarkPointCount; Index++)
                    {
                        paixu_conect[Index].value=(float)ImageConectIn->AllMarkPoint[Index].left;
                        paixu_conect[Index].i=Index;
                    }
                    QuickSortB(paixu_conect,ImageConectIn->AllMarkPointCount);
                break;
                case MHC_RIGHT_RIGHTTOLEFT_PAIXU:
                    for(Index=0; Index<ImageConectIn->AllMarkPointCount; Index++)
                    {
                        paixu_conect[Index].value=(float)ImageConectIn->AllMarkPoint[Index].right;
                        paixu_conect[Index].i=Index;
                    }
                    QuickSortB(paixu_conect,ImageConectIn->AllMarkPointCount);
                break;
                case MHC_TOP_TOPTOBOTTOM_PAIXU:
                    for(Index=0; Index<ImageConectIn->AllMarkPointCount; Index++)
                    {
                        paixu_conect[Index].value=(float)ImageConectIn->AllMarkPoint[Index].top;
                        paixu_conect[Index].i=Index;
                    }
                    QuickSortC(paixu_conect,ImageConectIn->AllMarkPointCount);
                break;
                case MHC_BOTTOM_TOPTOBOTTOM_PAIXU:
                    for(Index=0; Index<ImageConectIn->AllMarkPointCount; Index++)
                    {
                        paixu_conect[Index].value=(float)ImageConectIn->AllMarkPoint[Index].bottom;
                        paixu_conect[Index].i=Index;
                    }
                    QuickSortC(paixu_conect,ImageConectIn->AllMarkPointCount);
                break;
                case MHC_TOP_BOTTOMTOTOP_PAIXU:
                    for(Index=0; Index<ImageConectIn->AllMarkPointCount; Index++)
                    {
                        paixu_conect[Index].value=(float)ImageConectIn->AllMarkPoint[Index].top;
                        paixu_conect[Index].i=Index;
                    }
                    QuickSortB(paixu_conect,ImageConectIn->AllMarkPointCount);
                break;
                case MHC_BOTTOM_BOTTOMTOTOP_PAIXU:
                    for(Index=0; Index<ImageConectIn->AllMarkPointCount; Index++)
                    {
                        paixu_conect[Index].value=(float)ImageConectIn->AllMarkPoint[Index].bottom;
                        paixu_conect[Index].i=Index;
                    }
                    QuickSortB(paixu_conect,ImageConectIn->AllMarkPointCount);
                break;
                case MHC_WIDTH_PAIXU:
                    for(Index=0; Index<ImageConectIn->AllMarkPointCount; Index++)
                    {
                        paixu_conect[Index].value=ImageConectIn->AllMarkPoint[Index].right-ImageConectIn->AllMarkPoint[Index].left;
                        paixu_conect[Index].i=Index;
                    }
                    QuickSortC(paixu_conect,ImageConectIn->AllMarkPointCount);
                break;
                case MHC_HEIGHT_PAIXU:
                    for(Index=0; Index<ImageConectIn->AllMarkPointCount; Index++)
                    {
                        paixu_conect[Index].value=ImageConectIn->AllMarkPoint[Index].bottom-ImageConectIn->AllMarkPoint[Index].top;
                        paixu_conect[Index].i=Index;
                    }
                    QuickSortC(paixu_conect,ImageConectIn->AllMarkPointCount);
                break;
                case MHC_COLOR_PAIXU:
                    for(Index=0; Index<ImageConectIn->AllMarkPointCount; Index++)
                    {
                        paixu_conect[Index].value=ImageConectIn->AllMarkPoint[Index].color;
                        paixu_conect[Index].i=Index;
                    }
                    QuickSortC(paixu_conect,ImageConectIn->AllMarkPointCount);
                break;
                default:
                    return 1;
                break;
            }
        }
        else
        {
            MyCopyObjQuick(ImageConectIn,&conect_buffer3);
            ImageConectOut->mianji=0;
            ImageConectOut->AllMarkPointCount=0;

            switch(Mod)
            {
                case MHC_MIANJI_PAIXU:
                    for(Index=0; Index<conect_buffer3.AllMarkPointCount; Index++)
                    {
                        paixu_conect[Index].value=conect_buffer3.AllMarkPoint[Index].PointArea;
                        paixu_conect[Index].i=Index;
                    }
                    QuickSortC(paixu_conect,conect_buffer3.AllMarkPointCount);
                break;
                case MHC_LEFTTORIGHT_PAIXU:
                    for(Index=0; Index<conect_buffer3.AllMarkPointCount; Index++)
                    {
                        paixu_conect[Index].value=(float)conect_buffer3.AllMarkPoint[Index].xTotal/conect_buffer3.AllMarkPoint[Index].PointArea;
                        paixu_conect[Index].i=Index;
                    }
                    QuickSortC(paixu_conect,conect_buffer3.AllMarkPointCount);
                break;
                case MHC_RIGHTTOLEFT_PAIXU:
                    for(Index=0; Index<conect_buffer3.AllMarkPointCount; Index++)
                    {
                        paixu_conect[Index].value=(float)conect_buffer3.AllMarkPoint[Index].xTotal/conect_buffer3.AllMarkPoint[Index].PointArea;
                        paixu_conect[Index].i=Index;
                    }
                    QuickSortB(paixu_conect,conect_buffer3.AllMarkPointCount);
                break;
                case MHC_TOPTOBOTTOM_PAIXU:
                    for(Index=0; Index<conect_buffer3.AllMarkPointCount; Index++)
                    {
                        paixu_conect[Index].value=(float)conect_buffer3.AllMarkPoint[Index].yTotal/conect_buffer3.AllMarkPoint[Index].PointArea;
                        paixu_conect[Index].i=Index;
                    }
                    QuickSortC(paixu_conect,conect_buffer3.AllMarkPointCount);
                break;
                case MHC_BOTTOMTOTOP_PAIXU:
                    for(Index=0; Index<conect_buffer3.AllMarkPointCount; Index++)
                    {
                        paixu_conect[Index].value=(float)conect_buffer3.AllMarkPoint[Index].yTotal/conect_buffer3.AllMarkPoint[Index].PointArea;
                        paixu_conect[Index].i=Index;
                    }
                    QuickSortB(paixu_conect,conect_buffer3.AllMarkPointCount);
                break;
                case MHC_LEFT_LEFTTORIGHT_PAIXU:
                    for(Index=0; Index<conect_buffer3.AllMarkPointCount; Index++)
                    {
                        paixu_conect[Index].value=(float)conect_buffer3.AllMarkPoint[Index].left;
                        paixu_conect[Index].i=Index;
                    }
                    QuickSortC(paixu_conect,conect_buffer3.AllMarkPointCount);
                break;
                case MHC_RIGHT_LEFTTORIGHT_PAIXU:
                    for(Index=0; Index<conect_buffer3.AllMarkPointCount; Index++)
                    {
                        paixu_conect[Index].value=(float)conect_buffer3.AllMarkPoint[Index].left;
                        paixu_conect[Index].i=Index;
                    }
                    QuickSortC(paixu_conect,conect_buffer3.AllMarkPointCount);
                break;
                case MHC_LEFT_RIGHTTOLEFT_PAIXU:
                    for(Index=0; Index<conect_buffer3.AllMarkPointCount; Index++)
                    {
                        paixu_conect[Index].value=(float)conect_buffer3.AllMarkPoint[Index].left;
                        paixu_conect[Index].i=Index;
                    }
                    QuickSortB(paixu_conect,conect_buffer3.AllMarkPointCount);
                break;
                case MHC_RIGHT_RIGHTTOLEFT_PAIXU:
                    for(Index=0; Index<conect_buffer3.AllMarkPointCount; Index++)
                    {
                        paixu_conect[Index].value=(float)conect_buffer3.AllMarkPoint[Index].right;
                        paixu_conect[Index].i=Index;
                    }
                    QuickSortB(paixu_conect,conect_buffer3.AllMarkPointCount);
                break;
                case MHC_TOP_TOPTOBOTTOM_PAIXU:
                    for(Index=0; Index<conect_buffer3.AllMarkPointCount; Index++)
                    {
                        paixu_conect[Index].value=(float)conect_buffer3.AllMarkPoint[Index].top;
                        paixu_conect[Index].i=Index;
                    }
                    QuickSortC(paixu_conect,conect_buffer3.AllMarkPointCount);
                break;
                case MHC_BOTTOM_TOPTOBOTTOM_PAIXU:
                    for(Index=0; Index<conect_buffer3.AllMarkPointCount; Index++)
                    {
                        paixu_conect[Index].value=(float)conect_buffer3.AllMarkPoint[Index].bottom;
                        paixu_conect[Index].i=Index;
                    }
                    QuickSortC(paixu_conect,conect_buffer3.AllMarkPointCount);
                break;
                case MHC_TOP_BOTTOMTOTOP_PAIXU:
                    for(Index=0; Index<conect_buffer3.AllMarkPointCount; Index++)
                    {
                        paixu_conect[Index].value=(float)conect_buffer3.AllMarkPoint[Index].top;
                        paixu_conect[Index].i=Index;
                    }
                    QuickSortB(paixu_conect,conect_buffer3.AllMarkPointCount);
                break;
                case MHC_BOTTOM_BOTTOMTOTOP_PAIXU:
                    for(Index=0; Index<conect_buffer3.AllMarkPointCount; Index++)
                    {
                        paixu_conect[Index].value=(float)conect_buffer3.AllMarkPoint[Index].bottom;
                        paixu_conect[Index].i=Index;
                    }
                    QuickSortB(paixu_conect,conect_buffer3.AllMarkPointCount);
                break;
                case MHC_WIDTH_PAIXU:
                    for(Index=0; Index<conect_buffer3.AllMarkPointCount; Index++)
                    {
                        paixu_conect[Index].value=conect_buffer3.AllMarkPoint[Index].right-conect_buffer3.AllMarkPoint[Index].left;
                        paixu_conect[Index].i=Index;
                    }
                    QuickSortC(paixu_conect,conect_buffer3.AllMarkPointCount);
                break;
                case MHC_HEIGHT_PAIXU:
                    for(Index=0; Index<conect_buffer3.AllMarkPointCount; Index++)
                    {
                        paixu_conect[Index].value=conect_buffer3.AllMarkPoint[Index].bottom-conect_buffer3.AllMarkPoint[Index].top;
                        paixu_conect[Index].i=Index;
                    }
                    QuickSortC(paixu_conect,conect_buffer3.AllMarkPointCount);
                break;
                case MHC_COLOR_PAIXU:
                    for(Index=0; Index<conect_buffer3.AllMarkPointCount; Index++)
                    {
                        paixu_conect[Index].value=conect_buffer3.AllMarkPoint[Index].color;
                        paixu_conect[Index].i=Index;
                    }
                    QuickSortC(paixu_conect,conect_buffer3.AllMarkPointCount);
                break;
                default:
                    return 1;
                break;
            }
        }

        if(ImageConectOut!=ImageConectIn)
        {
            for(Index=0; Index<ImageConectIn->AllMarkPointCount; Index++)
            {
                Int32 i=paixu_conect[Index].i;
                ImageConectOut->AllMarkPoint[AllMarkPointCount]=ImageConectIn->AllMarkPoint[i];
                AllMarkPointCount++;
                mianji=mianji+ImageConectIn->AllMarkPoint[i].PointArea;
            }
        }
        else
        {
            for(Index=0; Index<conect_buffer3.AllMarkPointCount; Index++)
            {
                Int32 i=paixu_conect[Index].i;
                ImageConectOut->AllMarkPoint[AllMarkPointCount]=conect_buffer3.AllMarkPoint[i];
                AllMarkPointCount++;
                mianji=mianji+conect_buffer3.AllMarkPoint[i].PointArea;
            }
        }
        ImageConectOut->AllMarkPointCount=AllMarkPointCount;
        ImageConectOut->mianji=mianji;
        return 0;
    }

    Int8 Mysort_region_matIn(MyConect *ImageConectIn,Mat matIn,MyConect *ImageConectOut)
    {
        Int32 mianji=0;
        Int32 Index;
        Int32 AllMarkPointCount=0;

        if(0!=judgeCMaskSize(ImageConectIn,matIn))
            return 1;

        if(ImageConectOut!=ImageConectIn)
        {
            ImageConectOut->mianji=0;
            ImageConectOut->AllMarkPointCount=0;
            ImageConectOut->nHeight=ImageConectIn->nHeight;
            ImageConectOut->nWidth=ImageConectIn->nWidth;
            ImageConectOut->startx=ImageConectIn->startx;
            ImageConectOut->starty=ImageConectIn->starty;
            ImageConectOut->height=ImageConectIn->height;
            ImageConectOut->width=ImageConectIn->width;
            ImageConectOut->memPoint=ImageConectIn->memPoint;

            for(Index=0; Index<ImageConectIn->AllMarkPointCount; Index++)
            {
                Int32 n;
                Int32 bry=0;
                for(n=0;n<ImageConectIn->AllMarkPoint[Index].PointArea;n++)
                {
                    Int32 x=ImageConectIn->AllMarkPoint[Index].point[n].x;
                    Int32 y=ImageConectIn->AllMarkPoint[Index].point[n].y;
                    bry=bry+matIn.data[y*matIn.nWidth+x];
                }
                paixu_conect[Index].value=(float)bry/ImageConectIn->AllMarkPoint[Index].PointArea;
                paixu_conect[Index].i=Index;
            }
            QuickSortC(paixu_conect,ImageConectIn->AllMarkPointCount);
        }
        else
        {
            MyCopyObjQuick(ImageConectIn,&conect_buffer3);
            ImageConectOut->mianji=0;
            ImageConectOut->AllMarkPointCount=0;

            for(Index=0; Index<conect_buffer3.AllMarkPointCount; Index++)
            {
                Int32 n;
                Int32 bry=0;
                for(n=0;n<conect_buffer3.AllMarkPoint[Index].PointArea;n++)
                {
                    Int32 x=conect_buffer3.AllMarkPoint[Index].point[n].x;
                    Int32 y=conect_buffer3.AllMarkPoint[Index].point[n].y;
                    bry=bry+matIn.data[y*matIn.nWidth+x];
                }
                paixu_conect[Index].value=(float)bry/conect_buffer3.AllMarkPoint[Index].PointArea;
                paixu_conect[Index].i=Index;
            }
            QuickSortC(paixu_conect,conect_buffer3.AllMarkPointCount);
        }

        if(ImageConectOut!=ImageConectIn)
        {
            for(Index=0; Index<ImageConectIn->AllMarkPointCount; Index++)
            {
                Int32 i=paixu_conect[Index].i;
                ImageConectOut->AllMarkPoint[AllMarkPointCount]=ImageConectIn->AllMarkPoint[i];
                AllMarkPointCount++;
                mianji=mianji+ImageConectIn->AllMarkPoint[i].PointArea;
            }
        }
        else
        {
            for(Index=0; Index<conect_buffer3.AllMarkPointCount; Index++)
            {
                Int32 i=paixu_conect[Index].i;
                ImageConectOut->AllMarkPoint[AllMarkPointCount]=conect_buffer3.AllMarkPoint[i];
                AllMarkPointCount++;
                mianji=mianji+conect_buffer3.AllMarkPoint[i].PointArea;
            }
        }
        ImageConectOut->AllMarkPointCount=AllMarkPointCount;
        ImageConectOut->mianji=mianji;

        return 0;
    }

    Int8 Myselect_obj(MyConect *ImageConectIn,MyConect *ImageConectOut,Int32 Index)
    {
        Int32 nWidth=ImageConectIn->nWidth;
        Int32 nHeight=ImageConectIn->nHeight;

        ImageConectOut->nWidth=nWidth;
        ImageConectOut->nHeight=nHeight;
        ImageConectOut->nHeight=ImageConectIn->nHeight;
        ImageConectOut->nWidth=ImageConectIn->nWidth;
        ImageConectOut->startx=ImageConectIn->startx;
        ImageConectOut->starty=ImageConectIn->starty;
        ImageConectOut->height=ImageConectIn->height;
        ImageConectOut->width=ImageConectIn->width;
        ImageConectOut->memPoint=ImageConectIn->memPoint;
        if(Index>=ImageConectIn->AllMarkPointCount)
            return 1;
        ImageConectOut->AllMarkPoint[0]=ImageConectIn->AllMarkPoint[Index];
        ImageConectOut->mianji=ImageConectIn->AllMarkPoint[Index].PointArea;
        ImageConectOut->AllMarkPointCount=1;
        return 0;
    }

    Int8 Mysmallest_rectangle(MyConect *ImageConectIn,Int32 *LeftOut,Int32 *RightOut,Int32 *TopOut,Int32 *BottomOut)
    {
        Int32 i;
        if(ImageConectIn->AllMarkPointCount==0)
            return 1;
        *LeftOut=ImageConectIn->AllMarkPoint[0].left;
        *RightOut=ImageConectIn->AllMarkPoint[0].right;
        *TopOut=ImageConectIn->AllMarkPoint[0].top;
        *BottomOut=ImageConectIn->AllMarkPoint[0].bottom;
        for(i=1;i<ImageConectIn->AllMarkPointCount;i++)
        {
            if(*LeftOut>ImageConectIn->AllMarkPoint[i].left)
                *LeftOut=ImageConectIn->AllMarkPoint[i].left;
            if(*RightOut<ImageConectIn->AllMarkPoint[i].right)
                *RightOut=ImageConectIn->AllMarkPoint[i].right;
            if(*TopOut>ImageConectIn->AllMarkPoint[i].top)
                *TopOut=ImageConectIn->AllMarkPoint[i].top;
            if(*BottomOut<ImageConectIn->AllMarkPoint[i].bottom)
                *BottomOut=ImageConectIn->AllMarkPoint[i].bottom;
        }
        return 0;
    }

    Int8 Mymatsmallest_rectangle(Mat matIn,Int32 *LeftOut,Int32 *RightOut,Int32 *TopOut,Int32 *BottomOut)
    {
        Int32 nnWidth=matIn.nWidth;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        Int32 i,j;
        Uint8 nTopOut=0;
        Uint8 nBottomOut=0;
        Uint8 nLeftOut=0;
        Uint8 nRightOut=0;

        for(j=nStartY;j<nStartY+nHeight;j++)
        {
            for(i=nStartX;i<nStartX+nWidth;i++)
            {
                if(matIn.data[j*nnWidth+i]!=0)
                {
                    *TopOut=j;
                    nTopOut=1;
                    break;
                }
            }
            if(nTopOut==1)
            {
                break;
            }
        }
        for(j=nStartY+nHeight-1;j>=nStartY;j--)
        {
            for(i=nStartX;i<nStartX+nWidth;i++)
            {
                if(matIn.data[j*nnWidth+i]!=0)
                {
                    *BottomOut=j;
                    nBottomOut=1;
                    break;
                }
            }
            if(nBottomOut==1)
            {
                break;
            }
        }
        for(i=nStartX;i<nStartX+nWidth;i++)
        {
            for(j=nStartY;j<nStartY+nHeight;j++)
            {
                if(matIn.data[j*nnWidth+i]!=0)
                {
                    *LeftOut=i;
                    nLeftOut=1;
                    break;
                }
            }
            if(nLeftOut==1)
            {
                break;
            }
        }
        for(i=nStartX+nWidth-1;i>=nStartX;i--)
        {
            for(j=nStartY;j<nStartY+nHeight;j++)
            {
                if(matIn.data[j*nnWidth+i]!=0)
                {
                    *RightOut=i;
                    nRightOut=1;
                    break;
                }
            }
            if(nRightOut==1)
            {
                break;
            }
        }
        if(nRightOut!=1||nLeftOut!=1||nBottomOut!=1||nTopOut!=1)
        {
            return 1;
        }
        return 0;
    }

    Int8 MyGet_region_info(MyConect *ImageConectIn,region_info Mod,Int32 *dataOut)
    {
        Int32 sum=0;
        Int32 n;
        switch(Mod)
        {
            case MHC_HEIGHT_TOTAL:
                for(n=0;n<ImageConectIn->AllMarkPointCount;n++)
                {
                    sum=sum+(ImageConectIn->AllMarkPoint[n].bottom-ImageConectIn->AllMarkPoint[n].top+1);
                }
            break;
            case MHC_WIDTH_TOTAL:
                for(n=0;n<ImageConectIn->AllMarkPointCount;n++)
                {
                    sum=sum+(ImageConectIn->AllMarkPoint[n].right-ImageConectIn->AllMarkPoint[n].left+1);
                }
            break;
            default:
                return 1;
            break;
        }
        *dataOut=sum;
        return 0;
    }

    Int8 MyMat_sqare_line(Mat matIn,sqaretype Mod,L_line *lineOut,houghlineinfo *houghinfoOut)
    {
        Int32 nnWidth=matIn.nWidth;
        Int32 nnHeight=matIn.nHeight;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        Int32 i,j;
        Int32 *i32_bufferX=(Int32*)u8_buffer_x3Temp1;
        Int32 *i32_bufferY=(Int32*)u8_buffer_x1Temp1;
        Int32 N=0;
        double sumxx,sumx,sumy,sumxy;
        double K[1],R[1];
        MyCountLine linetemp;
        double Dxx = 0, Dxy = 0, Dyy = 0;
        double lambda;
        double den;
        double a,b,c;
        double dx,dy;
        Int32 headsumx=0,tailsumx=0;
        Int32 headsumy=0,tailsumy=0;
        Int32 _1_4halfN;
        Mat Hough;
        std::vector<cv::Point2f> points;
        cv::Vec4f lines;

        switch(matIn._type)
        {
            case CCV_8UC1:
                switch(Mod)
                {
                    case MHC_LINE_SQARE:
                    case MHC_VAR_SQARE:
                    case MHC_HEADTAIL_SQARE:
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            for(i=nStartX;i<nStartX+nWidth;i++)
                            {
                                if(matIn.data[j*nnWidth+i]!=0)
                                {
                                    i32_bufferX[N]=i;
                                    i32_bufferY[N++]=j;
                                }
                            }
                        }
                    break;
                    case MHC_HOUGH_SQARE:
                    break;
                    case MHC_MIXDIS_SQARE:
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            for(i=nStartX;i<nStartX+nWidth;i++)
                            {
                                if(matIn.data[j*nnWidth+i]!=0)
                                {
                                    cv::Point2f point(i,j);
                                    points.push_back(point);
                                }
                            }
                        }
                    break;
                    default:
                        return 1;
                    break;
                }
                switch(Mod)
                {
                    case MHC_LINE_SQARE:
                        if(N==0)
                            return 1;
                        sumx=i64_calculatesumx(i32_bufferX,N);
                        sumy=i64_calculatesumx(i32_bufferY,N);
                        sumxy=i64_calculatesumxy(i32_bufferX,i32_bufferY,N);
                        sumxx=i64_calculatesquare(i32_bufferX,N);
                        if(N*sumxx-sumx*sumx!=0)
                        {
                            K[0]=(float)((double)(N*sumxy-sumx*sumy)/(double)(N*sumxx-sumx*sumx));
                            R[0]=(float)((double)(sumxx*sumy-sumx*sumxy)/(double)(N*sumxx-sumx*sumx));
                            Mylinekb_to_gion(K,R,1,nnHeight,nnWidth,&linetemp);
                            *lineOut=linetemp.line[0];
                            *houghinfoOut=linetemp.houghinfo[0];
                        }
                        else
                        {
                            lineOut->st.x=sumx/N;
                            lineOut->st.y=0;
                            lineOut->ed.x=sumx/N;
                            lineOut->ed.y=nnHeight-1;
                            houghinfoOut->theta=MHC_TETARANGE/2;
                            houghinfoOut->rho=draw_xyrho_to_houghrho(sumx/N,nnWidth,nnHeight);
                        }
                    break;
                    case MHC_VAR_SQARE:
                        if(N==0)
                            return 1;
                        sumx=i64_calculatesumx(i32_bufferX,N);
                        sumy=i64_calculatesumx(i32_bufferY,N);
                        sumx/=N;
                        sumy/=N;

                        for(i = 0; i < N; i++)
                        {
                            Dxx += (i32_bufferX[i] - sumx) * (i32_bufferX[i] - sumx);
                            Dxy += (i32_bufferX[i] - sumx) * (i32_bufferY[i] - sumy);
                            Dyy += (i32_bufferY[i] - sumy) * (i32_bufferY[i] - sumy);
                        }
                        lambda = ((Dxx + Dyy) - sqrt((double)((Dxx - Dyy) * (Dxx - Dyy) + 4 * Dxy * Dxy))) / 2.0;

                        if(N<MHC_MIX_NUM_VAR_SQARE)
                        {
                            if(fabs(lambda - Dxx)>0)
                            {
                                den = sqrt((double)(Dxy * Dxy +(lambda - Dxx) * (lambda - Dxx)));
                                a = Dxy / den;
                                b =(lambda - Dxx) / den;
                                c = - a * sumx - b * sumy;
                                K[0] = -a/b;
                                R[0] = -c/b;
                                Mylinekb_to_gion(K,R,1,nnHeight,nnWidth,&linetemp);
                                *lineOut=linetemp.line[0];
                                *houghinfoOut=linetemp.houghinfo[0];
                                if(fabs(lambda - Dxx)<=10)
                                {
                                    double a1=1,b1=0,c1=sumx;
                                    double deta1=0,deta2=0;
                                    for(i=0;i<N;i++)
                                    {
                                        deta1+=(i32_bufferX[i]-(-b*i32_bufferY[i]-c)/a)*(i32_bufferX[i]-(-b*i32_bufferY[i]-c)/a);
                                        deta2+=(i32_bufferX[i]-(-b1*i32_bufferY[i]-c1)/a1)*(i32_bufferX[i]-(-b1*i32_bufferY[i]-c1)/a1);
                                    }
                                    if(deta1>deta2)
                                    {
                                        lineOut->st.x=sumx;
                                        lineOut->st.y=0;
                                        lineOut->ed.x=sumx;
                                        lineOut->ed.y=nnHeight-1;
                                        houghinfoOut->theta=MHC_TETARANGE/2;
                                        houghinfoOut->rho=draw_xyrho_to_houghrho(sumx,nnWidth,nnHeight);
                                    }
                                }
                            }
                            else
                            {
                                lineOut->st.x=sumx;
                                lineOut->st.y=0;
                                lineOut->ed.x=sumx;
                                lineOut->ed.y=nnHeight-1;
                                houghinfoOut->theta=MHC_TETARANGE/2;
                                houghinfoOut->rho=draw_xyrho_to_houghrho(sumx,nnWidth,nnHeight);
                            }

                        }
                        else
                        {
                            if(fabs(lambda - Dxx)>0)
                            {
                                den = sqrt((double)(Dxy * Dxy +(lambda - Dxx) * (lambda - Dxx)));
                                a = Dxy / den;
                                b =(lambda - Dxx) / den;
                                c = - a * sumx - b * sumy;
                                K[0] = -a/b;
                                R[0] = -c/b;
                                Mylinekb_to_gion(K,R,1,nnHeight,nnWidth,&linetemp);
                                *lineOut=linetemp.line[0];
                                *houghinfoOut=linetemp.houghinfo[0];
                                if(fabs(lambda - Dxx)<=100)
                                {
                                    double a1=1,b1=0,c1=sumx;
                                    double deta1=0,deta2=0;
                                    for(i=0;i<N;i++)
                                    {
                                        deta1+=(i32_bufferX[i]-(-b*i32_bufferY[i]-c)/a)*(i32_bufferX[i]-(-b*i32_bufferY[i]-c)/a);
                                        deta2+=(i32_bufferX[i]-(-b1*i32_bufferY[i]-c1)/a1)*(i32_bufferX[i]-(-b1*i32_bufferY[i]-c1)/a1);
                                    }
                                    if(deta1>deta2)
                                    {
                                        lineOut->st.x=sumx;
                                        lineOut->st.y=0;
                                        lineOut->ed.x=sumx;
                                        lineOut->ed.y=nnHeight-1;
                                        houghinfoOut->theta=MHC_TETARANGE/2;
                                        houghinfoOut->rho=draw_xyrho_to_houghrho(sumx,nnWidth,nnHeight);
                                    }
                                }
                            }
                            else
                            {
                                lineOut->st.x=sumx;
                                lineOut->st.y=0;
                                lineOut->ed.x=sumx;
                                lineOut->ed.y=nnHeight-1;
                                houghinfoOut->theta=MHC_TETARANGE/2;
                                houghinfoOut->rho=draw_xyrho_to_houghrho(sumx,nnWidth,nnHeight);
                            }
                        }
                    break;
                    case MHC_HEADTAIL_SQARE:
                        if(N==0)
                            return 1;
                        _1_4halfN=(N>>2);
                        for(i=0;i<=_1_4halfN;i++)
                        {
                            headsumx=headsumx+i32_bufferX[i];
                            headsumy=headsumy+i32_bufferY[i];
                        }
                        headsumx=headsumx/(_1_4halfN+1);
                        headsumy=headsumy/(_1_4halfN+1);
                        for(i=N-_1_4halfN-1;i<N;i++)
                        {
                            tailsumx=tailsumx+i32_bufferX[i];
                            tailsumy=tailsumy+i32_bufferY[i];
                        }
                        tailsumx=tailsumx/(_1_4halfN+1);
                        tailsumy=tailsumy/(_1_4halfN+1);

                        dy=headsumy-tailsumy;
                        dx=headsumx-tailsumx;
                        if(dx!=0)
                        {
                            K[0]=dy/dx;
                            R[0]=headsumy-headsumx*K[0];
                            Mylinekb_to_gion(K,R,1,nnHeight,nnWidth,&linetemp);
                            *lineOut=linetemp.line[0];
                            *houghinfoOut=linetemp.houghinfo[0];
                        }
                        else
                        {
                            lineOut->st.x=headsumx;
                            lineOut->st.y=0;
                            lineOut->ed.x=headsumx;
                            lineOut->ed.y=nnHeight-1;
                            houghinfoOut->theta=MHC_TETARANGE/2;
                            houghinfoOut->rho=draw_xyrho_to_houghrho(headsumx,nnWidth,nnHeight);
                        }
                    break;
                    case MHC_HOUGH_SQARE:
                        Hough=HoughCreat(u8_buffer_x1Temp1);
                        if(0!=MyMat_to_Hough(matIn,&Hough))
                            return 1;
                        if(0!=MyHough_to_maxline(Hough,nnWidth,nnHeight,&linetemp))
                            return 1;
                        *lineOut=linetemp.line[0];
                        *houghinfoOut=linetemp.houghinfo[0];
                    break;
                    case MHC_MIXDIS_SQARE:
                        if(points.size()==0)
                            return 1;
                        cv::fitLine(points,lines,cv::DIST_L2,0,0.01,0.01);
                        if(fabs((double)lines[0])>0.000001)
                        {
                            double X[1],X_dif[1],Y[1],Y_dif[1];
                            X_dif[0]=lines[0];
                            Y_dif[0]=lines[1];
                            X[0]=lines[2];
                            Y[0]=lines[3];
                            Mylinedb_to_gion(X_dif,Y_dif,X,Y,1,nnHeight,nnWidth,&linetemp);
                            *lineOut=linetemp.line[0];
                            *houghinfoOut=linetemp.houghinfo[0];
                        }
                        else
                        {
                            lineOut->st.x=lines[2];
                            lineOut->st.y=0;
                            lineOut->ed.x=lines[2];
                            lineOut->ed.y=nnHeight-1;
                            houghinfoOut->theta=MHC_TETARANGE/2;
                            houghinfoOut->rho=draw_xyrho_to_houghrho(lines[2],nnWidth,nnHeight);
                        }
                    break;
                    default:
                        return 1;
                    break;
                }
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 MyMat_masksqare_line(Mat matIn,Mat mask,sqaretype Mod,L_line *lineOut,houghlineinfo *houghinfoOut)
    {
        Int32 nnWidth=matIn.nWidth;
        Int32 nnHeight=matIn.nHeight;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        Int32 i,j;
        Int32 *i32_bufferX=(Int32*)u8_buffer_x3Temp1;
        Int32 *i32_bufferY=(Int32*)u8_buffer_x1Temp1;
        Uint16 *pEdgeMapList=(Uint16*)u8_buffer_x3Temp1;
        Uint16 pEdgeMapListNum=0;
        Int32 N=0;
        double sumxx,sumx,sumy,sumxy;
        double K[1],R[1];
        MyCountLine linetemp;
        double Dxx = 0, Dxy = 0, Dyy = 0;
        double lambda;
        double den;
        double a,b,c;
        double dx,dy;
        Int32 headsumx=0,tailsumx=0;
        Int32 headsumy=0,tailsumy=0;
        Int32 _1_4halfN;
        Mat Hough;
        std::vector<cv::Point2f> points;
        cv::Vec4f lines;

        if(0!=judgeMaskSize(matIn,mask))//��Ĥ��ƥ��
            return 1;

        switch(matIn._type)
        {
            case CCV_8UC1:
                switch(Mod)
                {
                    case MHC_LINE_SQARE:
                    case MHC_VAR_SQARE:
                    case MHC_HEADTAIL_SQARE:
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            for(i=nStartX;i<nStartX+nWidth;i++)
                            {
                                if(matIn.data[j*nnWidth+i]!=0&&mask.data[j*nnWidth+i]!=0)
                                {
                                    i32_bufferX[N]=i;
                                    i32_bufferY[N++]=j;
                                }
                            }
                        }
                    break;
                    case MHC_HOUGH_SQARE:
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            for(i=nStartX;i<nStartX+nWidth;i++)
                            {
                                if(matIn.data[j*nnWidth+i]!=0&&mask.data[j*nnWidth+i]!=0)
                                {
                                    pEdgeMapList[pEdgeMapListNum*2]=(Uint16)i;
                                    pEdgeMapList[pEdgeMapListNum*2+1]=(Uint16)j;
                                    pEdgeMapListNum++;
                                }
                            }
                        }
                    break;
                    case MHC_MIXDIS_SQARE:
                        for(j=nStartY;j<nStartY+nHeight;j++)
                        {
                            for(i=nStartX;i<nStartX+nWidth;i++)
                            {
                                if(matIn.data[j*nnWidth+i]!=0&&mask.data[j*nnWidth+i]!=0)
                                {
                                    cv::Point2f point(i,j);
                                    points.push_back(point);
                                }
                            }
                        }
                    break;
                    default:
                        return 1;
                    break;
                }
                switch(Mod)
                {
                    case MHC_LINE_SQARE:
                        if(N==0)
                            return 1;
                        sumx=i64_calculatesumx(i32_bufferX,N);
                        sumy=i64_calculatesumx(i32_bufferY,N);
                        sumxy=i64_calculatesumxy(i32_bufferX,i32_bufferY,N);
                        sumxx=i64_calculatesquare(i32_bufferX,N);
                        if(N*sumxx-sumx*sumx!=0)
                        {
                            K[0]=(float)((double)(N*sumxy-sumx*sumy)/(double)(N*sumxx-sumx*sumx));
                            R[0]=(float)((double)(sumxx*sumy-sumx*sumxy)/(double)(N*sumxx-sumx*sumx));
                            Mylinekb_to_gion(K,R,1,nnHeight,nnWidth,&linetemp);
                            *lineOut=linetemp.line[0];
                            *houghinfoOut=linetemp.houghinfo[0];
                        }
                        else
                        {
                            lineOut->st.x=sumx/N;
                            lineOut->st.y=0;
                            lineOut->ed.x=sumx/N;
                            lineOut->ed.y=nnHeight-1;
                            houghinfoOut->theta=MHC_TETARANGE/2;
                            houghinfoOut->rho=draw_xyrho_to_houghrho(sumx/N,nnWidth,nnHeight);
                        }
                    break;
                    case MHC_VAR_SQARE:
                        if(N==0)
                            return 1;
                        sumx=i64_calculatesumx(i32_bufferX,N);
                        sumy=i64_calculatesumx(i32_bufferY,N);
                        sumx/=N;
                        sumy/=N;
                        for(i = 0; i < N; i++)
                        {
                            Dxx += (i32_bufferX[i] - sumx) * (i32_bufferX[i] - sumx);
                            Dxy += (i32_bufferX[i] - sumx) * (i32_bufferY[i] - sumy);
                            Dyy += (i32_bufferY[i] - sumy) * (i32_bufferY[i] - sumy);
                        }
                        lambda = ((Dxx + Dyy) - sqrt((double)((Dxx - Dyy) * (Dxx - Dyy) + 4 * Dxy * Dxy))) / 2.0;

                        if(N<MHC_MIX_NUM_VAR_SQARE)
                        {
                            if(fabs(lambda - Dxx)>0)
                            {
                                den = sqrt((double)(Dxy * Dxy +(lambda - Dxx) * (lambda - Dxx)));
                                a = Dxy / den;
                                b =(lambda - Dxx) / den;
                                c = - a * sumx - b * sumy;
                                K[0] = -a/b;
                                R[0] = -c/b;
                                Mylinekb_to_gion(K,R,1,nnHeight,nnWidth,&linetemp);
                                *lineOut=linetemp.line[0];
                                *houghinfoOut=linetemp.houghinfo[0];
                                if(fabs(lambda - Dxx)<=10)
                                {
                                    double a1=1,b1=0,c1=sumx;
                                    double deta1=0,deta2=0;
                                    for(i=0;i<N;i++)
                                    {
                                        deta1+=(i32_bufferX[i]-(-b*i32_bufferY[i]-c)/a)*(i32_bufferX[i]-(-b*i32_bufferY[i]-c)/a);
                                        deta2+=(i32_bufferX[i]-(-b1*i32_bufferY[i]-c1)/a1)*(i32_bufferX[i]-(-b1*i32_bufferY[i]-c1)/a1);
                                    }
                                    if(deta1>deta2)
                                    {
                                        lineOut->st.x=sumx;
                                        lineOut->st.y=0;
                                        lineOut->ed.x=sumx;
                                        lineOut->ed.y=nnHeight-1;
                                        houghinfoOut->theta=MHC_TETARANGE/2;
                                        houghinfoOut->rho=draw_xyrho_to_houghrho(sumx,nnWidth,nnHeight);
                                    }
                                }
                            }
                            else
                            {
                                lineOut->st.x=sumx;
                                lineOut->st.y=0;
                                lineOut->ed.x=sumx;
                                lineOut->ed.y=nnHeight-1;
                                houghinfoOut->theta=MHC_TETARANGE/2;
                                houghinfoOut->rho=draw_xyrho_to_houghrho(sumx,nnWidth,nnHeight);
                            }
                        }
                        else
                        {
                            if(fabs(lambda - Dxx)>0)
                            {
                                den = sqrt((double)(Dxy * Dxy +(lambda - Dxx) * (lambda - Dxx)));
                                a = Dxy / den;
                                b =(lambda - Dxx) / den;
                                c = - a * sumx - b * sumy;
                                K[0] = -a/b;
                                R[0] = -c/b;
                                Mylinekb_to_gion(K,R,1,nnHeight,nnWidth,&linetemp);
                                *lineOut=linetemp.line[0];
                                *houghinfoOut=linetemp.houghinfo[0];
                                if(fabs(lambda - Dxx)<=100)
                                {
                                    double a1=1,b1=0,c1=sumx;
                                    double deta1=0,deta2=0;
                                    for(i=0;i<N;i++)
                                    {
                                        deta1+=(i32_bufferX[i]-(-b*i32_bufferY[i]-c)/a)*(i32_bufferX[i]-(-b*i32_bufferY[i]-c)/a);
                                        deta2+=(i32_bufferX[i]-(-b1*i32_bufferY[i]-c1)/a1)*(i32_bufferX[i]-(-b1*i32_bufferY[i]-c1)/a1);
                                    }
                                    if(deta1>deta2)
                                    {
                                        lineOut->st.x=sumx;
                                        lineOut->st.y=0;
                                        lineOut->ed.x=sumx;
                                        lineOut->ed.y=nnHeight-1;
                                        houghinfoOut->theta=MHC_TETARANGE/2;
                                        houghinfoOut->rho=draw_xyrho_to_houghrho(sumx,nnWidth,nnHeight);
                                    }
                                }
                            }
                            else
                            {
                                lineOut->st.x=sumx;
                                lineOut->st.y=0;
                                lineOut->ed.x=sumx;
                                lineOut->ed.y=nnHeight-1;
                                houghinfoOut->theta=MHC_TETARANGE/2;
                                houghinfoOut->rho=draw_xyrho_to_houghrho(sumx,nnWidth,nnHeight);
                            }
                        }
                    break;
                    case MHC_HEADTAIL_SQARE:
                        if(N==0)
                            return 1;
                        _1_4halfN=(N>>2);
                        for(i=0;i<=_1_4halfN;i++)
                        {
                            headsumx=headsumx+i32_bufferX[i];
                            headsumy=headsumy+i32_bufferY[i];
                        }
                        headsumx=headsumx/(_1_4halfN+1);
                        headsumy=headsumy/(_1_4halfN+1);
                        for(i=N-_1_4halfN-1;i<N;i++)
                        {
                            tailsumx=tailsumx+i32_bufferX[i];
                            tailsumy=tailsumy+i32_bufferY[i];
                        }
                        tailsumx=tailsumx/(_1_4halfN+1);
                        tailsumy=tailsumy/(_1_4halfN+1);

                        dy=headsumy-tailsumy;
                        dx=headsumx-tailsumx;
                        if(dx!=0)
                        {
                            K[0]=dy/dx;
                            R[0]=headsumy-headsumx*K[0];
                            Mylinekb_to_gion(K,R,1,nnHeight,nnWidth,&linetemp);
                            *lineOut=linetemp.line[0];
                            *houghinfoOut=linetemp.houghinfo[0];
                        }
                        else
                        {
                            lineOut->st.x=headsumx;
                            lineOut->st.y=0;
                            lineOut->ed.x=headsumx;
                            lineOut->ed.y=nnHeight-1;
                            houghinfoOut->theta=MHC_TETARANGE/2;
                            houghinfoOut->rho=draw_xyrho_to_houghrho(headsumx,nnWidth,nnHeight);
                        }
                    break;
                    case MHC_HOUGH_SQARE:
                        if(pEdgeMapListNum==0)
                            return 1;
                        Hough=HoughCreat(u8_buffer_x1Temp1);
                        MyPoint_to_Hough(pEdgeMapList,nnWidth,nnHeight,pEdgeMapListNum,&Hough);
                        if(0!=MyHough_to_maxline(Hough,nnWidth,nnHeight,&linetemp))
                            return 1;
                        *lineOut=linetemp.line[0];
                        *houghinfoOut=linetemp.houghinfo[0];
                    break;
                    case MHC_MIXDIS_SQARE:
                        if(points.size()==0)
                            return 1;
                        cv::fitLine(points,lines,cv::DIST_L2,0,0.01,0.01);
                        if(fabs((double)lines[0])>0.000001)
                        {
                            double X[1],X_dif[1],Y[1],Y_dif[1];
                            X_dif[0]=lines[0];
                            Y_dif[0]=lines[1];
                            X[0]=lines[2];
                            Y[0]=lines[3];
                            Mylinedb_to_gion(X_dif,Y_dif,X,Y,1,nnHeight,nnWidth,&linetemp);
                            *lineOut=linetemp.line[0];
                            *houghinfoOut=linetemp.houghinfo[0];
                        }
                        else
                        {
                            lineOut->st.x=lines[2];
                            lineOut->st.y=0;
                            lineOut->ed.x=lines[2];
                            lineOut->ed.y=nnHeight-1;
                            houghinfoOut->theta=MHC_TETARANGE/2;
                            houghinfoOut->rho=draw_xyrho_to_houghrho(lines[2],nnWidth,nnHeight);
                        }
                    break;
                    default:
                        return 1;
                    break;
                }
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 MyConect_sqare_line(MyConect *ImageConectIn,sqaretype Mod,L_line *lineOut,houghlineinfo *houghinfoOut)
    {
        Int32 nnHeight=ImageConectIn->nHeight;
        Int32 nnWidth=ImageConectIn->nWidth;
        Int32 i,j;
        Int32 *i32_bufferX=(Int32*)u8_buffer_x3Temp1;
        Int32 *i32_bufferY=(Int32*)u8_buffer_x1Temp1;
        Uint16 *pEdgeMapList=(Uint16*)u8_buffer_x3Temp1;
        Uint16 pEdgeMapListNum;
        Int32 N=0;
        double sumxx,sumx,sumy,sumxy;
        double K[1],R[1];
        MyCountLine linetemp;
        double Dxx = 0, Dxy = 0, Dyy = 0;
        double lambda;
        double den;
        double a,b,c;
        double dx,dy;
        Int32 headsumx=0,tailsumx=0;
        Int32 headsumy=0,tailsumy=0;
        Int32 _1_4halfN;
        Mat Hough;
        std::vector<cv::Point2f> points;
        cv::Vec4f lines;

        switch(Mod)
        {
            case MHC_LINE_SQARE:
            case MHC_VAR_SQARE:
            case MHC_HEADTAIL_SQARE:
                for(j=0;j<ImageConectIn->AllMarkPointCount;j++)
                {
                    for(i=0;i<ImageConectIn->AllMarkPoint[j].PointArea;i++)
                    {
                        i32_bufferX[N]=ImageConectIn->AllMarkPoint[j].point[i].x;
                        i32_bufferY[N++]=ImageConectIn->AllMarkPoint[j].point[i].y;
                    }
                }
            break;
            case MHC_HOUGH_SQARE:
                for(j=0;j<ImageConectIn->AllMarkPointCount;j++)
                {
                    for(i=0;i<ImageConectIn->AllMarkPoint[j].PointArea;i++)
                    {
                        pEdgeMapList[N++]=(Uint16)ImageConectIn->AllMarkPoint[j].point[i].x;
                        pEdgeMapList[N++]=(Uint16)ImageConectIn->AllMarkPoint[j].point[i].y;
                    }
                }
                pEdgeMapListNum=ImageConectIn->mianji;
            break;
            case MHC_MIXDIS_SQARE:
                for(j=0;j<ImageConectIn->AllMarkPointCount;j++)
                {
                    for(i=0;i<ImageConectIn->AllMarkPoint[j].PointArea;i++)
                    {
                        cv::Point2f point(ImageConectIn->AllMarkPoint[j].point[i].x,ImageConectIn->AllMarkPoint[j].point[i].y);
                        points.push_back(point);
                    }
                }   
            break;
            default:
                return 1;
            break;
        }

        switch(Mod)
        {
            case MHC_LINE_SQARE:
                if(N==0)
                    return 1;
                sumx=i64_calculatesumx(i32_bufferX,N);
                sumy=i64_calculatesumx(i32_bufferY,N);
                sumxy=i64_calculatesumxy(i32_bufferX,i32_bufferY,N);
                sumxx=i64_calculatesquare(i32_bufferX,N);
                if(N*sumxx-sumx*sumx!=0)
                {
                    K[0]=(float)((double)(N*sumxy-sumx*sumy)/(double)(N*sumxx-sumx*sumx));
                    R[0]=(float)((double)(sumxx*sumy-sumx*sumxy)/(double)(N*sumxx-sumx*sumx));
                    Mylinekb_to_gion(K,R,1,nnHeight,nnWidth,&linetemp);
                    *lineOut=linetemp.line[0];
                    *houghinfoOut=linetemp.houghinfo[0];
                }
                else
                {
                    lineOut->st.x=sumx/N;
                    lineOut->st.y=0;
                    lineOut->ed.x=sumx/N;
                    lineOut->ed.y=nnHeight-1;
                    houghinfoOut->theta=MHC_TETARANGE/2;
                    houghinfoOut->rho=draw_xyrho_to_houghrho(sumx/N,nnWidth,nnHeight);
                }
            break;
            case MHC_VAR_SQARE:
                if(N==0)
                    return 1;
                sumx=i64_calculatesumx(i32_bufferX,N);
                sumy=i64_calculatesumx(i32_bufferY,N);
                sumx/=N;
                sumy/=N;
                for(i = 0; i < N; i++)
                {
                    Dxx += (i32_bufferX[i] - sumx) * (i32_bufferX[i] - sumx);
                    Dxy += (i32_bufferX[i] - sumx) * (i32_bufferY[i] - sumy);
                    Dyy += (i32_bufferY[i] - sumy) * (i32_bufferY[i] - sumy);
                }
                lambda = ((Dxx + Dyy) - sqrt((double)((Dxx - Dyy) * (Dxx - Dyy) + 4 * Dxy * Dxy))) / 2.0;

                if(N<MHC_MIX_NUM_VAR_SQARE)
                {
                    if(fabs(lambda - Dxx)>0)
                    {
                        den = sqrt((double)(Dxy * Dxy + (lambda - Dxx) *(lambda - Dxx)));
                        a = Dxy / den;
                        b = (lambda - Dxx) / den;
                        c = - a * sumx - b * sumy;
                        K[0] = -a/b;
                        R[0] = -c/b;
                        Mylinekb_to_gion(K,R,1,nnHeight,nnWidth,&linetemp);
                        *lineOut=linetemp.line[0];
                        *houghinfoOut=linetemp.houghinfo[0];
                        if(fabs(lambda - Dxx)<=10)
                        {
                            double a1=1,b1=0,c1=sumx;
                            double deta1=0,deta2=0;
                            for(i=0;i<N;i++)
                            {
                                deta1+=(i32_bufferX[i]-(-b*i32_bufferY[i]-c)/a)*(i32_bufferX[i]-(-b*i32_bufferY[i]-c)/a);
                                deta2+=(i32_bufferX[i]-(-b1*i32_bufferY[i]-c1)/a1)*(i32_bufferX[i]-(-b1*i32_bufferY[i]-c1)/a1);
                            }
                            if(deta1>deta2)
                            {
                                lineOut->st.x=sumx;
                                lineOut->st.y=0;
                                lineOut->ed.x=sumx;
                                lineOut->ed.y=nnHeight-1;
                                houghinfoOut->theta=MHC_TETARANGE/2;
                                houghinfoOut->rho=draw_xyrho_to_houghrho(sumx,nnWidth,nnHeight);
                            }
                        }
                    }
                    else
                    {
                        lineOut->st.x=sumx;
                        lineOut->st.y=0;
                        lineOut->ed.x=sumx;
                        lineOut->ed.y=nnHeight-1;
                        houghinfoOut->theta=MHC_TETARANGE/2;
                        houghinfoOut->rho=draw_xyrho_to_houghrho(sumx,nnWidth,nnHeight);
                    }
                }
                else
                {
                    if(fabs(lambda - Dxx)>0)
                    {
                        den = sqrt((double)(Dxy * Dxy + (lambda - Dxx) *(lambda - Dxx)));
                        a = Dxy / den;
                        b = (lambda - Dxx) / den;
                        c = - a * sumx - b * sumy;
                        K[0] = -a/b;
                        R[0] = -c/b;
                        Mylinekb_to_gion(K,R,1,nnHeight,nnWidth,&linetemp);
                        *lineOut=linetemp.line[0];
                        *houghinfoOut=linetemp.houghinfo[0];
                        if(fabs(lambda - Dxx)<=100)
                        {
                            double a1=1,b1=0,c1=sumx;
                            double deta1=0,deta2=0;
                            for(i=0;i<N;i++)
                            {
                                deta1+=(i32_bufferX[i]-(-b*i32_bufferY[i]-c)/a)*(i32_bufferX[i]-(-b*i32_bufferY[i]-c)/a);
                                deta2+=(i32_bufferX[i]-(-b1*i32_bufferY[i]-c1)/a1)*(i32_bufferX[i]-(-b1*i32_bufferY[i]-c1)/a1);
                            }
                            if(deta1>deta2)
                            {
                                lineOut->st.x=sumx;
                                lineOut->st.y=0;
                                lineOut->ed.x=sumx;
                                lineOut->ed.y=nnHeight-1;
                                houghinfoOut->theta=MHC_TETARANGE/2;
                                houghinfoOut->rho=draw_xyrho_to_houghrho(sumx,nnWidth,nnHeight);
                            }
                        }
                    }
                    else
                    {
                        lineOut->st.x=sumx;
                        lineOut->st.y=0;
                        lineOut->ed.x=sumx;
                        lineOut->ed.y=nnHeight-1;
                        houghinfoOut->theta=MHC_TETARANGE/2;
                        houghinfoOut->rho=draw_xyrho_to_houghrho(sumx,nnWidth,nnHeight);
                    }
                }
            break;
            case MHC_HEADTAIL_SQARE:
                if(N==0)
                    return 1;
                _1_4halfN=(N>>2);
                for(i=0;i<=_1_4halfN;i++)
                {
                    headsumx=headsumx+i32_bufferX[i];
                    headsumy=headsumy+i32_bufferY[i];
                }
                headsumx=headsumx/(_1_4halfN+1);
                headsumy=headsumy/(_1_4halfN+1);
                for(i=N-_1_4halfN-1;i<N;i++)
                {
                    tailsumx=tailsumx+i32_bufferX[i];
                    tailsumy=tailsumy+i32_bufferY[i];
                }
                tailsumx=tailsumx/(_1_4halfN+1);
                tailsumy=tailsumy/(_1_4halfN+1);

                dy=headsumy-tailsumy;
                dx=headsumx-tailsumx;
                if(dx!=0)
                {
                    K[0]=dy/dx;
                    R[0]=headsumy-headsumx*K[0];
                    Mylinekb_to_gion(K,R,1,nnHeight,nnWidth,&linetemp);
                    *lineOut=linetemp.line[0];
                    *houghinfoOut=linetemp.houghinfo[0];
                }
                else
                {
                    lineOut->st.x=headsumx;
                    lineOut->st.y=0;
                    lineOut->ed.x=headsumx;
                    lineOut->ed.y=nnHeight-1;
                    houghinfoOut->theta=MHC_TETARANGE/2;
                    houghinfoOut->rho=draw_xyrho_to_houghrho(headsumx,nnWidth,nnHeight);
                }
            break;
            case MHC_HOUGH_SQARE:
                if(pEdgeMapListNum==0)
                    return 1;
                Hough=HoughCreat(u8_buffer_x1Temp1);
                MyPoint_to_Hough(pEdgeMapList,nnWidth,nnHeight,pEdgeMapListNum,&Hough);
                if(0!=MyHough_to_maxline(Hough,nnWidth,nnHeight,&linetemp))
                    return 1;
                *lineOut=linetemp.line[0];
                *houghinfoOut=linetemp.houghinfo[0];
            break;
            case MHC_MIXDIS_SQARE:
                if(points.size()==0)
                    return 1;
                cv::fitLine(points,lines,cv::DIST_L2,0,0.01,0.01);
                if(fabs((double)lines[0])>0.000001)
                {
                    double X[1],X_dif[1],Y[1],Y_dif[1];
                    X_dif[0]=lines[0];
                    Y_dif[0]=lines[1];
                    X[0]=lines[2];
                    Y[0]=lines[3];
                    Mylinedb_to_gion(X_dif,Y_dif,X,Y,1,nnHeight,nnWidth,&linetemp);
                    *lineOut=linetemp.line[0];
                    *houghinfoOut=linetemp.houghinfo[0];
                }
                else
                {
                    lineOut->st.x=lines[2];
                    lineOut->st.y=0;
                    lineOut->ed.x=lines[2];
                    lineOut->ed.y=nnHeight-1;
                    houghinfoOut->theta=MHC_TETARANGE/2;
                    houghinfoOut->rho=draw_xyrho_to_houghrho(lines[2],nnWidth,nnHeight);
                }
            break;
            default:
                return 1;
            break;
        }

        return 0;
    }

    Int8 MyConectmove_sqare_line(MyConect *ImageConectIn,sqaretype Mod,Int32 movex,Int32 movey,L_line *lineOut,houghlineinfo *houghinfoOut)
    {
        Int32 nnHeight=ImageConectIn->nHeight;
        Int32 nnWidth=ImageConectIn->nWidth;
        Int32 i,j;
        Int32 *i32_bufferX=(Int32*)u8_buffer_x3Temp1;
        Int32 *i32_bufferY=(Int32*)u8_buffer_x1Temp1;
        Uint16 *pEdgeMapList=(Uint16*)u8_buffer_x3Temp1;
        Uint16 pEdgeMapListNum;
        Int32 N=0;
        double sumxx,sumx,sumy,sumxy;
        double K[1],R[1];
        MyCountLine linetemp;
        double Dxx = 0, Dxy = 0, Dyy = 0;
        double lambda;
        double den;
        double a,b,c;
        double dx,dy;
        Int32 headsumx=0,tailsumx=0;
        Int32 headsumy=0,tailsumy=0;
        Int32 _1_4halfN;
        Mat Hough;
        std::vector<cv::Point2f> points;
        cv::Vec4f lines;

        switch(Mod)
        {
            case MHC_LINE_SQARE:
            case MHC_VAR_SQARE:
            case MHC_HEADTAIL_SQARE:
                for(j=0;j<ImageConectIn->AllMarkPointCount;j++)
                {
                    for(i=0;i<ImageConectIn->AllMarkPoint[j].PointArea;i++)
                    {
                        i32_bufferX[N]=ImageConectIn->AllMarkPoint[j].point[i].x+movex;
                        i32_bufferY[N++]=ImageConectIn->AllMarkPoint[j].point[i].y+movey;
                    }
                }
            break;
            case MHC_HOUGH_SQARE:
                for(j=0;j<ImageConectIn->AllMarkPointCount;j++)
                {
                    for(i=0;i<ImageConectIn->AllMarkPoint[j].PointArea;i++)
                    {
                        pEdgeMapList[N++]=(Uint16)ImageConectIn->AllMarkPoint[j].point[i].x+movex;
                        pEdgeMapList[N++]=(Uint16)ImageConectIn->AllMarkPoint[j].point[i].y+movey;
                    }
                }
                pEdgeMapListNum=ImageConectIn->mianji;
            break;
            case MHC_MIXDIS_SQARE:
                for(j=0;j<ImageConectIn->AllMarkPointCount;j++)
                {
                    for(i=0;i<ImageConectIn->AllMarkPoint[j].PointArea;i++)
                    {
                        cv::Point2f point(ImageConectIn->AllMarkPoint[j].point[i].x+movex,ImageConectIn->AllMarkPoint[j].point[i].y+movey);
                        points.push_back(point);
                    }
                }   
            break;
            default:
                return 1;
            break;
        }

        switch(Mod)
        {
            case MHC_LINE_SQARE:
                if(N==0)
                    return 1;
                sumx=i64_calculatesumx(i32_bufferX,N);
                sumy=i64_calculatesumx(i32_bufferY,N);
                sumxy=i64_calculatesumxy(i32_bufferX,i32_bufferY,N);
                sumxx=i64_calculatesquare(i32_bufferX,N);
                if(N*sumxx-sumx*sumx!=0)
                {
                    K[0]=(float)((double)(N*sumxy-sumx*sumy)/(double)(N*sumxx-sumx*sumx));
                    R[0]=(float)((double)(sumxx*sumy-sumx*sumxy)/(double)(N*sumxx-sumx*sumx));
                    Mylinekb_to_gion(K,R,1,nnHeight,nnWidth,&linetemp);
                    *lineOut=linetemp.line[0];
                    *houghinfoOut=linetemp.houghinfo[0];
                }
                else
                {
                    lineOut->st.x=sumx/N;
                    lineOut->st.y=0;
                    lineOut->ed.x=sumx/N;
                    lineOut->ed.y=nnHeight-1;
                    houghinfoOut->theta=MHC_TETARANGE/2;
                    houghinfoOut->rho=draw_xyrho_to_houghrho(sumx/N,nnWidth,nnHeight);
                }
            break;
            case MHC_VAR_SQARE:
                if(N==0)
                    return 1;
                sumx=i64_calculatesumx(i32_bufferX,N);
                sumy=i64_calculatesumx(i32_bufferY,N);
                sumx/=N;
                sumy/=N;
                for(i = 0; i < N; i++)
                {
                    Dxx += (i32_bufferX[i] - sumx) * (i32_bufferX[i] - sumx);
                    Dxy += (i32_bufferX[i] - sumx) * (i32_bufferY[i] - sumy);
                    Dyy += (i32_bufferY[i] - sumy) * (i32_bufferY[i] - sumy);
                }
                lambda = ((Dxx + Dyy) - sqrt((double)((Dxx - Dyy) * (Dxx - Dyy) + 4 * Dxy * Dxy))) / 2.0;

                if(N<MHC_MIX_NUM_VAR_SQARE)
                {
                    if(fabs(lambda - Dxx)>0)
                    {
                        den = sqrt((double)(Dxy * Dxy + (lambda - Dxx) * (lambda - Dxx)));
                        a = Dxy / den;
                        b = (lambda - Dxx) / den;
                        c = - a * sumx - b * sumy;
                        K[0] = -a/b;
                        R[0] = -c/b;
                        Mylinekb_to_gion(K,R,1,nnHeight,nnWidth,&linetemp);
                        *lineOut=linetemp.line[0];
                        *houghinfoOut=linetemp.houghinfo[0];

                        if(fabs(lambda - Dxx)<=10)
                        {
                            double a1=1,b1=0,c1=sumx;
                            double deta1=0,deta2=0;
                            for(i=0;i<N;i++)
                            {
                                deta1+=(i32_bufferX[i]-(-b*i32_bufferY[i]-c)/a)*(i32_bufferX[i]-(-b*i32_bufferY[i]-c)/a);
                                deta2+=(i32_bufferX[i]-(-b1*i32_bufferY[i]-c1)/a1)*(i32_bufferX[i]-(-b1*i32_bufferY[i]-c1)/a1);
                            }
                            if(deta1>deta2)
                            {
                                lineOut->st.x=sumx;
                                lineOut->st.y=0;
                                lineOut->ed.x=sumx;
                                lineOut->ed.y=nnHeight-1;
                                houghinfoOut->theta=MHC_TETARANGE/2;
                                houghinfoOut->rho=draw_xyrho_to_houghrho(sumx,nnWidth,nnHeight);
                            }
                        }
                    }
                    else
                    {
                        lineOut->st.x=sumx;
                        lineOut->st.y=0;
                        lineOut->ed.x=sumx;
                        lineOut->ed.y=nnHeight-1;
                        houghinfoOut->theta=MHC_TETARANGE/2;
                        houghinfoOut->rho=draw_xyrho_to_houghrho(sumx,nnWidth,nnHeight);
                    }
                }
                else
                {
                    if(fabs(lambda - Dxx)>0)
                    {
                        den = sqrt((double)(Dxy * Dxy + (lambda - Dxx) * (lambda - Dxx)));
                        a = Dxy / den;
                        b = (lambda - Dxx) / den;
                        c = - a * sumx - b * sumy;
                        K[0] = -a/b;
                        R[0] = -c/b;
                        Mylinekb_to_gion(K,R,1,nnHeight,nnWidth,&linetemp);
                        *lineOut=linetemp.line[0];
                        *houghinfoOut=linetemp.houghinfo[0];
                        if(fabs(lambda - Dxx)<=100)
                        {
                            double a1=1,b1=0,c1=sumx;
                            double deta1=0,deta2=0;
                            for(i=0;i<N;i++)
                            {
                                deta1+=(i32_bufferX[i]-(-b*i32_bufferY[i]-c)/a)*(i32_bufferX[i]-(-b*i32_bufferY[i]-c)/a);
                                deta2+=(i32_bufferX[i]-(-b1*i32_bufferY[i]-c1)/a1)*(i32_bufferX[i]-(-b1*i32_bufferY[i]-c1)/a1);
                            }
                            if(deta1>deta2)
                            {
                                lineOut->st.x=sumx;
                                lineOut->st.y=0;
                                lineOut->ed.x=sumx;
                                lineOut->ed.y=nnHeight-1;
                                houghinfoOut->theta=MHC_TETARANGE/2;
                                houghinfoOut->rho=draw_xyrho_to_houghrho(sumx,nnWidth,nnHeight);
                            }
                        }
                    }
                    else
                    {
                        lineOut->st.x=sumx;
                        lineOut->st.y=0;
                        lineOut->ed.x=sumx;
                        lineOut->ed.y=nnHeight-1;
                        houghinfoOut->theta=MHC_TETARANGE/2;
                        houghinfoOut->rho=draw_xyrho_to_houghrho(sumx,nnWidth,nnHeight);
                    }
                }
            break;
            case MHC_HEADTAIL_SQARE:
                if(N==0)
                    return 1;
                _1_4halfN=(N>>2);
                for(i=0;i<=_1_4halfN;i++)
                {
                    headsumx=headsumx+i32_bufferX[i];
                    headsumy=headsumy+i32_bufferY[i];
                }
                headsumx=headsumx/(_1_4halfN+1);
                headsumy=headsumy/(_1_4halfN+1);
                for(i=N-_1_4halfN-1;i<N;i++)
                {
                    tailsumx=tailsumx+i32_bufferX[i];
                    tailsumy=tailsumy+i32_bufferY[i];
                }
                tailsumx=tailsumx/(_1_4halfN+1);
                tailsumy=tailsumy/(_1_4halfN+1);

                dy=headsumy-tailsumy;
                dx=headsumx-tailsumx;
                if(dx!=0)
                {
                    K[0]=dy/dx;
                    R[0]=headsumy-headsumx*K[0];
                    Mylinekb_to_gion(K,R,1,nnHeight,nnWidth,&linetemp);
                    *lineOut=linetemp.line[0];
                    *houghinfoOut=linetemp.houghinfo[0];
                }
                else
                {
                    lineOut->st.x=headsumx;
                    lineOut->st.y=0;
                    lineOut->ed.x=headsumx;
                    lineOut->ed.y=nnHeight-1;
                    houghinfoOut->theta=MHC_TETARANGE/2;
                    houghinfoOut->rho=draw_xyrho_to_houghrho(headsumx,nnWidth,nnHeight);
                }
            break;
            case MHC_HOUGH_SQARE:
                if(pEdgeMapListNum==0)
                    return 1;
                Hough=HoughCreat(u8_buffer_x1Temp1);
                MyPoint_to_Hough(pEdgeMapList,nnWidth,nnHeight,pEdgeMapListNum,&Hough);
                if(0!=MyHough_to_maxline(Hough,nnWidth,nnHeight,&linetemp))
                    return 1;
                *lineOut=linetemp.line[0];
                *houghinfoOut=linetemp.houghinfo[0];
            break;
            case MHC_MIXDIS_SQARE:
                if(points.size()==0)
                    return 1;
                cv::fitLine(points,lines,cv::DIST_L2,0,0.01,0.01);
                if(fabs((double)lines[0])>0.000001)
                {
                    double X[1],X_dif[1],Y[1],Y_dif[1];
                    X_dif[0]=lines[0];
                    Y_dif[0]=lines[1];
                    X[0]=lines[2];
                    Y[0]=lines[3];
                    Mylinedb_to_gion(X_dif,Y_dif,X,Y,1,nnHeight,nnWidth,&linetemp);
                    *lineOut=linetemp.line[0];
                    *houghinfoOut=linetemp.houghinfo[0];
                }
                else
                {
                    lineOut->st.x=lines[2];
                    lineOut->st.y=0;
                    lineOut->ed.x=lines[2];
                    lineOut->ed.y=nnHeight-1;
                    houghinfoOut->theta=MHC_TETARANGE/2;
                    houghinfoOut->rho=draw_xyrho_to_houghrho(lines[2],nnWidth,nnHeight);
                }
            break;
            default:
                return 1;
            break;
        }

        return 0;
    }

    Int8 MyData_sqare_line(Int32 *dataXIn,Int32 *dataYIn,Int32 num,Int32 nWidth,Int32 nHeight,sqaretype Mod,L_line *lineOut,houghlineinfo *houghinfoOut)
    {
        Int32 nnWidth=nWidth;
        Int32 nnHeight=nHeight;
        Int32 *i32_bufferX=(Int32*)dataXIn;
        Int32 *i32_bufferY=(Int32*)dataYIn;
        Uint16 *pEdgeMapList=(Uint16*)u8_buffer_x1Temp2;
        Uint16 pEdgeMapListNum;
        Int32 N=num;
        double sumxx,sumx,sumy,sumxy;
        double K[1],R[1];
        MyCountLine linetemp;
        Int32 i;
        double Dxx = 0, Dxy = 0, Dyy = 0;
        double lambda;
        double den;
        double a,b,c;
        double dx,dy;
        Int32 headsumx=0,tailsumx=0;
        Int32 headsumy=0,tailsumy=0;
        Int32 _1_4halfN;
        Mat Hough;
        std::vector<cv::Point2f> points;
        cv::Vec4f lines;

        switch(Mod)
        {
            case MHC_LINE_SQARE:
            case MHC_VAR_SQARE:
            case MHC_HEADTAIL_SQARE:
            break;
            case MHC_HOUGH_SQARE:
                for(i=0;i<N;i++)
                {
                    pEdgeMapList[i*2]=(Uint16)dataXIn[i];
                    pEdgeMapList[i*2+1]=(Uint16)dataYIn[i];
                }
                pEdgeMapListNum=N;
            break;
            case MHC_MIXDIS_SQARE:
                for(i=0;i<N;i++)
                {
                    cv::Point2f point(dataXIn[i],dataYIn[i]);
                    points.push_back(point);
                }
            break;
            default:
                return 1;
            break;
        }
        switch(Mod)
        {
            case MHC_LINE_SQARE:
                if(N==0)
                    return 1;
                sumx=i64_calculatesumx(i32_bufferX,N);
                sumy=i64_calculatesumx(i32_bufferY,N);
                sumxy=i64_calculatesumxy(i32_bufferX,i32_bufferY,N);
                sumxx=i64_calculatesquare(i32_bufferX,N);
                if(N*sumxx-sumx*sumx!=0)
                {
                    K[0]=(float)((double)(N*sumxy-sumx*sumy)/(double)(N*sumxx-sumx*sumx));
                    R[0]=(float)((double)(sumxx*sumy-sumx*sumxy)/(double)(N*sumxx-sumx*sumx));
                    Mylinekb_to_gion(K,R,1,nnHeight,nnWidth,&linetemp);
                    *lineOut=linetemp.line[0];
                    *houghinfoOut=linetemp.houghinfo[0];
                }
                else
                {
                    lineOut->st.x=sumx/N;
                    lineOut->st.y=0;
                    lineOut->ed.x=sumx/N;
                    lineOut->ed.y=nnHeight-1;
                    houghinfoOut->theta=MHC_TETARANGE/2;
                    houghinfoOut->rho=draw_xyrho_to_houghrho(sumx/N,nnWidth,nnHeight);
                }
            break;
            case MHC_VAR_SQARE:
                if(N==0)
                    return 1;
                sumx=i64_calculatesumx(i32_bufferX,N);
                sumy=i64_calculatesumx(i32_bufferY,N);
                sumx/=N;
                sumy/=N;
                for(i = 0; i < N; i++)
                {
                    Dxx += (i32_bufferX[i] - sumx) * (i32_bufferX[i] - sumx);
                    Dxy += (i32_bufferX[i] - sumx) * (i32_bufferY[i] - sumy);
                    Dyy += (i32_bufferY[i] - sumy) * (i32_bufferY[i] - sumy);
                }
                lambda = ((Dxx + Dyy) - sqrt((double)((Dxx - Dyy) * (Dxx - Dyy) + 4 * Dxy * Dxy))) / 2.0;

                if(N<MHC_MIX_NUM_VAR_SQARE)
                {
                    if(fabs(lambda - Dxx)>0)
                    {
                        den = sqrt((double)(Dxy * Dxy + (lambda - Dxx) * (lambda - Dxx)));
                        a = Dxy / den;
                        b = (lambda - Dxx) / den;
                        c = - a * sumx - b * sumy;
                        K[0] = -a/b;
                        R[0] = -c/b;
                        Mylinekb_to_gion(K,R,1,nnHeight,nnWidth,&linetemp);
                        *lineOut=linetemp.line[0];
                        *houghinfoOut=linetemp.houghinfo[0];
                        if(fabs(lambda - Dxx)<=10)
                        {
                            double a1=1,b1=0,c1=sumx;
                            double deta1=0,deta2=0;
                            for(i=0;i<N;i++)
                            {
                                deta1+=(i32_bufferX[i]-(-b*i32_bufferY[i]-c)/a)*(i32_bufferX[i]-(-b*i32_bufferY[i]-c)/a);
                                deta2+=(i32_bufferX[i]-(-b1*i32_bufferY[i]-c1)/a1)*(i32_bufferX[i]-(-b1*i32_bufferY[i]-c1)/a1);
                            }
                            if(deta1>deta2)
                            {
                                lineOut->st.x=sumx;
                                lineOut->st.y=0;
                                lineOut->ed.x=sumx;
                                lineOut->ed.y=nnHeight-1;
                                houghinfoOut->theta=MHC_TETARANGE/2;
                                houghinfoOut->rho=draw_xyrho_to_houghrho(sumx,nnWidth,nnHeight);
                            }
                        }
                    }
                    else
                    {
                        lineOut->st.x=sumx;
                        lineOut->st.y=0;
                        lineOut->ed.x=sumx;
                        lineOut->ed.y=nnHeight-1;
                        houghinfoOut->theta=MHC_TETARANGE/2;
                        houghinfoOut->rho=draw_xyrho_to_houghrho(sumx,nnWidth,nnHeight);
                    }
                }
                else
                {
                    if(fabs(lambda - Dxx)>0)
                    {
                        den = sqrt((double)(Dxy * Dxy + (lambda - Dxx) * (lambda - Dxx)));
                        a = Dxy / den;
                        b = (lambda - Dxx) / den;
                        c = - a * sumx - b * sumy;
                        K[0] = -a/b;
                        R[0] = -c/b;
                        Mylinekb_to_gion(K,R,1,nnHeight,nnWidth,&linetemp);
                        *lineOut=linetemp.line[0];
                        *houghinfoOut=linetemp.houghinfo[0];

                        if(fabs(lambda - Dxx)<=100)
                        {
                            double a1=1,b1=0,c1=sumx;
                            double deta1=0,deta2=0;
                            for(i=0;i<N;i++)
                            {
                                deta1+=(i32_bufferX[i]-(-b*i32_bufferY[i]-c)/a)*(i32_bufferX[i]-(-b*i32_bufferY[i]-c)/a);
                                deta2+=(i32_bufferX[i]-(-b1*i32_bufferY[i]-c1)/a1)*(i32_bufferX[i]-(-b1*i32_bufferY[i]-c1)/a1);
                            }
                            if(deta1>deta2)
                            {
                                lineOut->st.x=sumx;
                                lineOut->st.y=0;
                                lineOut->ed.x=sumx;
                                lineOut->ed.y=nnHeight-1;
                                houghinfoOut->theta=MHC_TETARANGE/2;
                                houghinfoOut->rho=draw_xyrho_to_houghrho(sumx,nnWidth,nnHeight);
                            }
                        }
                    }
                    else
                    {
                        lineOut->st.x=sumx;
                        lineOut->st.y=0;
                        lineOut->ed.x=sumx;
                        lineOut->ed.y=nnHeight-1;
                        houghinfoOut->theta=MHC_TETARANGE/2;
                        houghinfoOut->rho=draw_xyrho_to_houghrho(sumx,nnWidth,nnHeight);
                    }
                }
            break;
            case MHC_HEADTAIL_SQARE:
                if(N==0)
                    return 1;
                _1_4halfN=(N>>3);
                for(i=0;i<=_1_4halfN;i++)
                {
                    headsumx=headsumx+i32_bufferX[i];
                    headsumy=headsumy+i32_bufferY[i];
                }
                headsumx=headsumx/(_1_4halfN+1);
                headsumy=headsumy/(_1_4halfN+1);
                for(i=N-_1_4halfN-1;i<N;i++)
                {
                    tailsumx=tailsumx+i32_bufferX[i];
                    tailsumy=tailsumy+i32_bufferY[i];
                }
                tailsumx=tailsumx/(_1_4halfN+1);
                tailsumy=tailsumy/(_1_4halfN+1);

                dy=headsumy-tailsumy;
                dx=headsumx-tailsumx;
                if(dx!=0)
                {
                    K[0]=dy/dx;
                    R[0]=headsumy-headsumx*K[0];
                    Mylinekb_to_gion(K,R,1,nnHeight,nnWidth,&linetemp);
                    *lineOut=linetemp.line[0];
                    *houghinfoOut=linetemp.houghinfo[0];
                }
                else
                {
                    lineOut->st.x=headsumx;
                    lineOut->st.y=0;
                    lineOut->ed.x=headsumx;
                    lineOut->ed.y=nnHeight-1;
                    houghinfoOut->theta=MHC_TETARANGE/2;
                    houghinfoOut->rho=draw_xyrho_to_houghrho(headsumx,nnWidth,nnHeight);
                }
            break;
            case MHC_HOUGH_SQARE:
                if(pEdgeMapListNum==0)
                    return 1;
                Hough=HoughCreat(u8_buffer_x1Temp1);
                MyPoint_to_Hough(pEdgeMapList,nnWidth,nnHeight,pEdgeMapListNum,&Hough);
                if(0!=MyHough_to_maxline(Hough,nnWidth,nnHeight,&linetemp))
                    return 1;
                *lineOut=linetemp.line[0];
                *houghinfoOut=linetemp.houghinfo[0];
            break;
            case MHC_MIXDIS_SQARE:
                if(points.size()==0)
                    return 1;
                cv::fitLine(points,lines,cv::DIST_L2,0,0.01,0.01);
                if(fabs((double)lines[0])>0.000001)
                {
                    double X[1],X_dif[1],Y[1],Y_dif[1];
                    X_dif[0]=lines[0];
                    Y_dif[0]=lines[1];
                    X[0]=lines[2];
                    Y[0]=lines[3];
                    Mylinedb_to_gion(X_dif,Y_dif,X,Y,1,nnHeight,nnWidth,&linetemp);
                    *lineOut=linetemp.line[0];
                    *houghinfoOut=linetemp.houghinfo[0];
                }
                else
                {
                    lineOut->st.x=lines[2];
                    lineOut->st.y=0;
                    lineOut->ed.x=lines[2];
                    lineOut->ed.y=nnHeight-1;
                    houghinfoOut->theta=MHC_TETARANGE/2;
                    houghinfoOut->rho=draw_xyrho_to_houghrho(lines[2],nnWidth,nnHeight);
                }
            break;
            default:
                return 1;
            break;
        }

        return 0;
    }

    Int8 MyMat_sqare_circle(Mat matIn,sqaretype Mod,double *centerXOut,double *centerYOut,double *radiusOut)
    {
        Int32 nnWidth=matIn.nWidth;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        Int32 i,j;
        Int32 *i32_bufferX=(Int32*)u8_buffer_x3Temp1;
        Int32 *i32_bufferY=(Int32*)u8_buffer_x1Temp1;
        Int32 N=0;
        double sum_x = 0.0f, sum_y = 0.0f;
        double sum_x2 = 0.0f, sum_y2 = 0.0f;
        double sum_x3 = 0.0f, sum_y3 = 0.0f;
        double sum_xy = 0.0f, sum_x1y2 = 0.0f, sum_x2y1 = 0.0f;
        double C, D, E, G, H;
        double a, b, c;

        *centerXOut=0;
        *centerYOut=0;
        *radiusOut=0;
        switch(matIn._type)
        {
            case CCV_8UC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(matIn.data[j*nnWidth+i]!=0)
                        {
                            i32_bufferX[N]=i;
                            i32_bufferY[N++]=j;
                        }
                    }
                }
                switch(Mod)
                {
                    case MHC_VAR_SQARE:
                        if(N<3)
                            return 1;
                        for (i = 0;i<N;i++)
                        {
                            double x = i32_bufferX[i];
                            double y = i32_bufferY[i];
                            double x2 = x * x;
                            double y2 = y * y;
                            sum_x += x;
                            sum_y += y;
                            sum_x2 += x2;
                            sum_y2 += y2;
                            sum_x3 += x2 * x;
                            sum_y3 += y2 * y;
                            sum_xy += x * y;
                            sum_x1y2 += x * y2;
                            sum_x2y1 += x2 * y;
                        }
                        C = N * sum_x2 - sum_x * sum_x;
                        D = N * sum_xy - sum_x * sum_y;
                        E = N * sum_x3 + N * sum_x1y2 - (sum_x2 + sum_y2) * sum_x;
                        G = N * sum_y2 - sum_y * sum_y;
                        H = N * sum_x2y1 + N * sum_y3 - (sum_x2 + sum_y2) * sum_y;
                        a = (H * D - E * G) / (C * G - D * D);
                        b = (H * C - E * D) / (D * D - G * C);
                        c = -(a * sum_x + b * sum_y + sum_x2 + sum_y2) / N;
                        *centerXOut = a / (-2);
                        *centerYOut = b / (-2);
                        *radiusOut = sqrt(a * a + b * b - 4 * c) / 2;
                    break;
                    default:
                        return 1;
                    break;
                }
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 MyMat_masksqare_circle(Mat matIn,Mat mask,sqaretype Mod,double *centerXOut,double *centerYOut,double *radiusOut)
    {
        Uint32 nnWidth=matIn.nWidth;
        Uint32 nStartX=matIn.startx;
        Uint32 nStartY=matIn.starty;
        Uint32 nWidth=matIn.width;
        Uint32 nHeight=matIn.height;
        Int32 i,j;
        Int32 *i32_bufferX=(Int32*)u8_buffer_x3Temp1;
        Int32 *i32_bufferY=(Int32*)u8_buffer_x1Temp1;
        Int32 N=0;
        double sum_x = 0.0f, sum_y = 0.0f;
        double sum_x2 = 0.0f, sum_y2 = 0.0f;
        double sum_x3 = 0.0f, sum_y3 = 0.0f;
        double sum_xy = 0.0f, sum_x1y2 = 0.0f, sum_x2y1 = 0.0f;
        double C, D, E, G, H;
        double a, b, c;

        *centerXOut=0;
        *centerYOut=0;
        *radiusOut=0;
        if(0!=judgeMaskSize(matIn,mask))
            return 1;
        switch(matIn._type)
        {
            case CCV_8UC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(mask.data[j*nnWidth+i]!=0&&matIn.data[j*nnWidth+i]!=0)
                        {
                            i32_bufferX[N]=i;
                            i32_bufferY[N++]=j;
                        }
                    }
                }
                switch(Mod)
                {
                    case MHC_VAR_SQARE:
                        if(N<3)
                            return 1;
                        for (i = 0;i<N;i++)
                        {
                            double x = i32_bufferX[i];
                            double y = i32_bufferY[i];
                            double x2 = x * x;
                            double y2 = y * y;
                            sum_x += x;
                            sum_y += y;
                            sum_x2 += x2;
                            sum_y2 += y2;
                            sum_x3 += x2 * x;
                            sum_y3 += y2 * y;
                            sum_xy += x * y;
                            sum_x1y2 += x * y2;
                            sum_x2y1 += x2 * y;
                        }
                        C = N * sum_x2 - sum_x * sum_x;
                        D = N * sum_xy - sum_x * sum_y;
                        E = N * sum_x3 + N * sum_x1y2 - (sum_x2 + sum_y2) * sum_x;
                        G = N * sum_y2 - sum_y * sum_y;
                        H = N * sum_x2y1 + N * sum_y3 - (sum_x2 + sum_y2) * sum_y;
                        a = (H * D - E * G) / (C * G - D * D);
                        b = (H * C - E * D) / (D * D - G * C);
                        c = -(a * sum_x + b * sum_y + sum_x2 + sum_y2) / N;
                        *centerXOut = a / (-2);
                        *centerYOut = b / (-2);
                        *radiusOut = sqrt(a * a + b * b - 4 * c) / 2;
                    break;
                    default:
                        return 1;
                    break;
                }
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 MyConect_sqare_circle(MyConect *ImageConectIn,sqaretype Mod,double *centerXOut,double *centerYOut,double *radiusOut)
    {
        Int32 i,j;
        Int32 N=0;
        double sum_x = 0.0f, sum_y = 0.0f;
        double sum_x2 = 0.0f, sum_y2 = 0.0f;
        double sum_x3 = 0.0f, sum_y3 = 0.0f;
        double sum_xy = 0.0f, sum_x1y2 = 0.0f, sum_x2y1 = 0.0f;
        double C, D, E, G, H;
        double a, b, c;

        *centerXOut=0;
        *centerYOut=0;
        *radiusOut=0;

        N=ImageConectIn->mianji;
        switch(Mod)
        {
            case MHC_VAR_SQARE:
                if(N<3)
                    return 1;
                for(j=0;j<ImageConectIn->AllMarkPointCount;j++)
                {
                    for(i=0;i<ImageConectIn->AllMarkPoint[j].PointArea;i++)
                    {
                        double x = ImageConectIn->AllMarkPoint[j].point[i].x;
                        double y = ImageConectIn->AllMarkPoint[j].point[i].y;
                        double x2 = x * x;
                        double y2 = y * y;
                        sum_x += x;
                        sum_y += y;
                        sum_x2 += x2;
                        sum_y2 += y2;
                        sum_x3 += x2 * x;
                        sum_y3 += y2 * y;
                        sum_xy += x * y;
                        sum_x1y2 += x * y2;
                        sum_x2y1 += x2 * y;
                    }
                }
                C = N * sum_x2 - sum_x * sum_x;
                D = N * sum_xy - sum_x * sum_y;
                E = N * sum_x3 + N * sum_x1y2 - (sum_x2 + sum_y2) * sum_x;
                G = N * sum_y2 - sum_y * sum_y;
                H = N * sum_x2y1 + N * sum_y3 - (sum_x2 + sum_y2) * sum_y;
                a = (H * D - E * G) / (C * G - D * D);
                b = (H * C - E * D) / (D * D - G * C);
                c = -(a * sum_x + b * sum_y + sum_x2 + sum_y2) / N;
                *centerXOut = a / (-2);
                *centerYOut = b / (-2);
                *radiusOut = sqrt(a * a + b * b - 4 * c) / 2;
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 MyData_sqare_circle(Int32 *dataXIn,Int32 *dataYIn,Int32 num,sqaretype Mod,double *centerXOut,double *centerYOut,double *radiusOut)
    {
        Int32 i;
        double sum_x = 0.0f, sum_y = 0.0f;
        double sum_x2 = 0.0f, sum_y2 = 0.0f;
        double sum_x3 = 0.0f, sum_y3 = 0.0f;
        double sum_xy = 0.0f, sum_x1y2 = 0.0f, sum_x2y1 = 0.0f;
        double C, D, E, G, H;
        double a, b, c;
        Int32 N=num;

        *centerXOut=0;
        *centerYOut=0;
        *radiusOut=0;

        switch(Mod)
        {
            case MHC_VAR_SQARE:
                if(N<3)
                    return 1;
                for (i = 0;i<N;i++)
                {
                    double x = dataXIn[i];
                    double y = dataYIn[i];
                    double x2 = x * x;
                    double y2 = y * y;
                    sum_x += x;
                    sum_y += y;
                    sum_x2 += x2;
                    sum_y2 += y2;
                    sum_x3 += x2 * x;
                    sum_y3 += y2 * y;
                    sum_xy += x * y;
                    sum_x1y2 += x * y2;
                    sum_x2y1 += x2 * y;
                }
                C = N * sum_x2 - sum_x * sum_x;
                D = N * sum_xy - sum_x * sum_y;
                E = N * sum_x3 + N * sum_x1y2 - (sum_x2 + sum_y2) * sum_x;
                G = N * sum_y2 - sum_y * sum_y;
                H = N * sum_x2y1 + N * sum_y3 - (sum_x2 + sum_y2) * sum_y;
                a = (H * D - E * G) / (C * G - D * D);
                b = (H * C - E * D) / (D * D - G * C);
                c = -(a * sum_x + b * sum_y + sum_x2 + sum_y2) / N;
                *centerXOut = a / (-2);
                *centerYOut = b / (-2);
                *radiusOut = sqrt(a * a + b * b - 4 * c) / 2;
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 MyHough_to_maxline(Mat HoughIn,Uint16 nWidth,Uint16 nHeight,MyCountLine *LineOut)
    {
        Uint32 halfnWidth;
        Uint32 halfnHeight;
        Int32 i,j;
        Uint16 MAXtemp=0;
        Int32 MAXtheta,MAXrho;
        Mat matIn=MatCreat(nHeight,nWidth,CCV_8UC1,(Uint8*)u8_buffer_x1Temp4);

        LineOut->nHeight=nHeight;
        LineOut->nWidth=nWidth;
        LineOut->startx=0;
        LineOut->starty=0;
        LineOut->width=nWidth;
        LineOut->height=nHeight;
        LineOut->linenum=0;

        if(HoughIn._type!=CCV_16UC1
        ||HoughIn.nHeight!=MHC_TETARANGE
        ||HoughIn.nWidth!=MHC_ROLENGTH)
            return 1;

        halfnWidth=(HoughIn.nWidth>>1)-2;
        halfnHeight=(HoughIn.nHeight>>1);

        for(j=halfnHeight;j<HoughIn.starty+HoughIn.height;j++)
        {
            for(i=halfnWidth;i<HoughIn.startx+HoughIn.width;i++)
            {
                if(MAXtemp<HoughIn.ptr_ushort[j*HoughIn.nWidth+i])
                {
                    MAXtemp=HoughIn.ptr_ushort[j*HoughIn.nWidth+i];
                    MAXtheta=j;
                    MAXrho=i;
                }
            }
        }
        for(j=HoughIn.starty;j<halfnHeight;j++)
        {
            for(i=HoughIn.startx;i<HoughIn.startx+HoughIn.width;i++)
            {
                if(MAXtemp<HoughIn.ptr_ushort[j*HoughIn.nWidth+i])
                {
                    MAXtemp=HoughIn.ptr_ushort[j*HoughIn.nWidth+i];
                    MAXtheta=j;
                    MAXrho=i;
                }
            }
        }
        if(MAXtemp>0)
        {
            L_Point32 pt1,pt2,realpt1,realpt2;
            Int32 rho=MAXrho;
            Int32 theta=MAXtheta;
            Int32 a,b;
            Int32 x0,y0;
            Int16 stx,sty,edx,edy;
            rho=draw_houghrho_to_xyrho(rho,nWidth,nHeight);
            a=CV_Cos[theta];
            b=CV_Sin[theta];
            x0=((a*rho)>>16);
            y0=((b*rho)>>16);
            pt1.x=x0-(b<<3);
            pt1.y=y0+(a<<3);
            pt2.x=x0+(b<<3);
            pt2.y=y0-(a<<3);
            MyLineComperMat4(&matIn,pt1,pt2,CV_LINE_8LT,&realpt1,&realpt2);
            stx=realpt1.x;
            sty=realpt1.y;
            edx=realpt2.x;
            edy=realpt2.y;

            LineOut->line[0].st.x=stx;
            LineOut->line[0].st.y=sty;
            LineOut->line[0].ed.x=edx;
            LineOut->line[0].ed.y=edy;
            LineOut->houghinfo[0].theta=(Uint16)theta;
            LineOut->houghinfo[0].rho=draw_xyrho_to_houghrho(rho,nWidth,nHeight);
            LineOut->linenum=1;
        }
        else
        {
            return 1;
        }

        return 0;
    }

    Int8 MyHough_to_lineNeartheta(Mat HoughIn,Mat matIn,MyCountLine *LineOut,Int32 thetaIn,Int32 thetaNearby,Int32 lineLongmin,Int32 lineGapmax)
    {
        Uint32 halfnWidth;
        Uint32 halfnHeight;
        Uint8 nowlineTotal=0;
        Int32 nnWidth=matIn.nWidth;
        Int32 nnHeight=matIn.nHeight;

        Uint16 MAXtemp=0;
        Int32 MAXtheta,MAXrho;
        Int32 startj=thetaIn-thetaNearby;
        Int32 endj=thetaIn+thetaNearby;

        Int32 i,j;

        LineOut->nHeight=matIn.nHeight;
        LineOut->nWidth=matIn.nWidth;
        LineOut->startx=matIn.startx;
        LineOut->starty=matIn.starty;
        LineOut->width=matIn.width;
        LineOut->height=matIn.height;
        LineOut->linenum=nowlineTotal;

        if(matIn._type!=CCV_8UC1
        ||HoughIn._type!=CCV_16UC1
        ||HoughIn.nHeight!=MHC_TETARANGE
        ||HoughIn.nWidth!=MHC_ROLENGTH)
            return 1;

        halfnWidth=(HoughIn.nWidth>>1)-2;
        halfnHeight=(HoughIn.nHeight>>1);

        if(startj<HoughIn.starty)
            startj=HoughIn.starty;
        if(endj>HoughIn.starty+HoughIn.height)
            endj=HoughIn.starty+HoughIn.height;
        for(j=startj;j<endj;j++)
        {
            if(j>=halfnHeight)
            {
                for(i=halfnWidth;i<HoughIn.startx+HoughIn.width;i++)
                {
                    if(MAXtemp<HoughIn.ptr_ushort[j*HoughIn.nWidth+i])
                    {
                        MAXtemp=HoughIn.ptr_ushort[j*HoughIn.nWidth+i];
                        MAXtheta=j;
                        MAXrho=i;
                    }
                }
            }
            else
            {
                for(i=HoughIn.startx;i<HoughIn.startx+HoughIn.width;i++)
                {
                    if(MAXtemp<HoughIn.ptr_ushort[j*HoughIn.nWidth+i])
                    {
                        MAXtemp=HoughIn.ptr_ushort[j*HoughIn.nWidth+i];
                        MAXtheta=j;
                        MAXrho=i;
                    }
                }
            }
        }

        if(MAXtemp>0)
        {
            L_Point32 pt1,pt2;
            Int32 rho=MAXrho;
            Int32 theta=MAXtheta;
            Int32 a,b;
            Int32 x0,y0;
            Int32 startrho;
            Int32 endrho;
            Int32 drho;
            Int32 maxlongsize=0;
            Int32 maxlongsizerho=0;
            Int32 maxlongsizenum=0;

            rho=draw_houghrho_to_xyrho(rho,nnWidth,nnHeight);
            startrho=-(MHC_SEARCH_SIZE>>1);
            endrho=(MHC_SEARCH_SIZE>>1);

            for(drho=startrho;drho<=endrho;drho++)
            {
                Int32 longsize;
                a=CV_Cos[theta];
                b=CV_Sin[theta];
                x0=((a*rho)>>16)+((drho*a)>>8);
                y0=((b*rho)>>16)+((drho*b)>>8);
                pt1.x=x0-(b<<3);
                pt1.y=y0+(a<<3);
                pt2.x=x0+(b<<3);
                pt2.y=y0-(a<<3);
                MyLineComperMat(&matIn,pt1,pt2,CV_LINE_8LT,1,lineGapmax,&longsize);
                if(maxlongsize<longsize)
                {
                    maxlongsize=longsize;
                    maxlongsizerho=drho;
                    maxlongsizenum=1;
                }
                else if(maxlongsize==longsize)
                {
                    maxlongsizerho=maxlongsizerho+drho;
                    maxlongsizenum++;
                }
            }
            if(maxlongsize>lineLongmin&&maxlongsizenum!=0)
            {
                Int32 drho=maxlongsizerho/maxlongsizenum;
                L_Point32 pt1,pt2;
                L_Point32 realpt1,realpt2;
                Int16 stx,sty,edx,edy;

                a=CV_Cos[theta];
                b=CV_Sin[theta];
                x0=((a*rho)>>16)+((drho*a)>>8);
                y0=((b*rho)>>16)+((drho*b)>>8);
                pt1.x=x0-(b<<3);
                pt1.y=y0+(a<<3);
                pt2.x=x0+(b<<3);
                pt2.y=y0-(a<<3);
                MyLineComperMat2(&matIn,pt1,pt2,CV_LINE_8LT,1,lineGapmax,&realpt1,&realpt2);
                stx=realpt1.x;
                sty=realpt1.y;
                edx=realpt2.x;
                edy=realpt2.y;
                LineOut->line[nowlineTotal].st.x=(Uint16)stx;
                LineOut->line[nowlineTotal].st.y=(Uint16)sty;
                LineOut->line[nowlineTotal].ed.x=(Uint16)edx;
                LineOut->line[nowlineTotal].ed.y=(Uint16)edy;
                LineOut->houghinfo[nowlineTotal].theta=(Uint16)theta;

                LineOut->houghinfo[nowlineTotal].rho=draw_xyrho_to_houghrho(rho,nnWidth,nnHeight);
                nowlineTotal++;
            }
        }
        else
        {
            return 1;
        }
        LineOut->linenum=nowlineTotal;
        return 0;
    }

    Int8 MyGetCountLineSqare(MyCountLine *LineIn,Mat matIn,MyCountLine *LineOut,sqaretype Mod,Int32 rhoIn,Int32 lineGapmax,Bool *ResultMark)
    {
        Int32 n;

        Int32 nnWidth=matIn.nWidth;
        Int32 nnHeight=matIn.nHeight;

        Mat matInbig=MatCreatzero(nnHeight,nnWidth,CCV_8UC1,(Uint8*)u8_buffer_x1Temp4);
        Mat matjiaoji=MatCreatzero(nnHeight,nnWidth,CCV_8UC1,(Uint8*)u8_buffer_x1Temp5);
        Mat matlinezero=MatCreat(nnHeight,nnWidth,CCV_8UC1,(Uint8*)u8_buffer_x1Temp6);
        Uint8 *u8_buffer=(Uint8*)u8_buffer_x1Temp3;

        LineOut->nHeight=LineIn->nHeight;
        LineOut->nWidth=LineIn->nWidth;
        LineOut->startx=LineIn->startx;
        LineOut->starty=LineIn->starty;
        LineOut->width=LineIn->width;
        LineOut->height=LineIn->height;
        LineOut->linenum=LineIn->linenum;
        memcpy(LineOut->houghinfo,LineIn->houghinfo,sizeof(houghlineinfo)*LineIn->linenum);

        if(matIn._type!=CCV_8UC1)
            return 1;


        for(n=0;n<LineIn->linenum;n++)
        {
            Int32 rho=LineIn->houghinfo[n].rho;
            Int32 theta=LineIn->houghinfo[n].theta;
            Int32 a,b;
            Int32 x0,y0;
            L_Point32 pt1,pt2;
            L_line lineWT;
            houghlineinfo linehough;
            Int32 x1=(LineIn->line[n].st.x);
            Int32 x2=(LineIn->line[n].ed.x);
            Int32 y1=(LineIn->line[n].st.y);
            Int32 y2=(LineIn->line[n].ed.y);
            Int32 lineminlong=sqrt((double)(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));

            rho=draw_houghrho_to_xyrho(rho,nnWidth,nnHeight);
            a=CV_Cos[theta];
            b=CV_Sin[theta];
            x0=((a*rho)>>16);
            y0=((b*rho)>>16);
            pt1.x=x0-(b<<3);
            pt1.y=y0+(a<<3);
            pt2.x=x0+(b<<3);
            pt2.y=y0-(a<<3);
            MatSet1col(&matlinezero,0);
            MyLine(&matlinezero,pt1,pt2,255,CV_LINE_8LT,rhoIn);
            Myintersection(matlinezero,matIn,&matjiaoji);
            Myconnection(matjiaoji,&conect_buffer1,lineminlong*2,lineGapmax/2+1,MHC_8LT,u8_buffer);
            if(conect_buffer1.AllMarkPointCount==0)
            {
                ResultMark[n] = FALSE;
                continue;
            }
            Mysort_region(&conect_buffer1,&conect_buffer2,MHC_HEIGHT_PAIXU);
            Myselect_obj(&conect_buffer2,&conect_buffer3,conect_buffer2.AllMarkPointCount-1);
            Myregion_to_bin(&conect_buffer3,&matInbig,255);
            MyMat_sqare_line(matInbig,Mod,&lineWT,&linehough);
            LineOut->line[n]=lineWT;
            LineOut->houghinfo[n]=linehough;
            ResultMark[n] = TRUE;
        }
        return 0;
    }

    Int8 MyGetCountLineBreakpoint(MyCountLine *LineIn,Mat matIn,MyCountLine *LineOut,Int32 rhoIn,Int32 lineGapmax,Int32 lineminlong,Bool *ResultMark)
    {
        Int32 n;
        Int32 nnWidth=matIn.nWidth;
        Int32 nnHeight=matIn.nHeight;
        Mat matInbig=MatCreatzero(nnHeight,nnWidth,CCV_8UC1,(Uint8*)u8_buffer_x1Temp4);
        Mat matjiaoji=MatCreatzero(nnHeight,nnWidth,CCV_8UC1,(Uint8*)u8_buffer_x1Temp5);
        Mat matlinezero=MatCreat(nnHeight,nnWidth,CCV_8UC1,(Uint8*)u8_buffer_x1Temp6);
        Uint8 *u8_buffer=(Uint8*)u8_buffer_x1Temp3;

        LineOut->nHeight=LineIn->nHeight;
        LineOut->nWidth=LineIn->nWidth;
        LineOut->startx=LineIn->startx;
        LineOut->starty=LineIn->starty;
        LineOut->width=LineIn->width;
        LineOut->height=LineIn->height;
        LineOut->linenum=LineIn->linenum;
        memcpy(LineOut->houghinfo,LineIn->houghinfo,sizeof(houghlineinfo)*LineIn->linenum);

        if(matIn._type!=CCV_8UC1)
            return 1;

        for(n=0;n<LineIn->linenum;n++)
        {
            Int32 rho=LineIn->houghinfo[n].rho;
            Int32 theta=LineIn->houghinfo[n].theta;
            Int32 a,b;
            Int32 x0,y0;
            Int32 startrho;
            Int32 endrho;
            Int32 drho;
            L_Point st;
            L_Point ed;
            L_Point32 pt1,pt2;
            Uint8 first=0;

            rho=draw_houghrho_to_xyrho(rho,nnWidth,nnHeight);

            startrho=-(rhoIn>>1);
            endrho=(rhoIn>>1);

            a=CV_Cos[theta];
            b=CV_Sin[theta];
            x0=((a*rho)>>16);
            y0=((b*rho)>>16);
            pt1.x=x0-(b<<3);
            pt1.y=y0+(a<<3);
            pt2.x=x0+(b<<3);
            pt2.y=y0-(a<<3);
            MatSet1col(&matlinezero,0);
            MyLine(&matlinezero,pt1,pt2,255,CV_LINE_8LT,rhoIn);
            Myintersection(matlinezero,matIn,&matjiaoji);
            Myconnection(matjiaoji,&conect_buffer1,lineminlong*2,lineGapmax/2+1,MHC_8LT,u8_buffer);
            if(conect_buffer1.AllMarkPointCount==0)
            {
                ResultMark[n] = FALSE;
                continue;
            }
            Mysort_region(&conect_buffer1,&conect_buffer2,MHC_HEIGHT_PAIXU);
            Myselect_obj(&conect_buffer2,&conect_buffer3,conect_buffer2.AllMarkPointCount-1);
            Myregion_to_bin(&conect_buffer3,&matInbig,255);
            for(drho=startrho;drho<=endrho;drho++)
            {
                L_Point32 pt1,pt2;
                L_Point32 realpt1,realpt2;
                Int16 stx,sty,edx,edy;
                Int32 maxlong;

                a=CV_Cos[theta];
                b=CV_Sin[theta];
                x0=((a*rho)>>16)+((drho*a)>>8);
                y0=((b*rho)>>16)+((drho*b)>>8);
                pt1.x=x0-(b<<3);
                pt1.y=y0+(a<<3);
                pt2.x=x0+(b<<3);
                pt2.y=y0-(a<<3);
                MyLineComperMat3(&matInbig,pt1,pt2,CV_LINE_8LT,1,lineGapmax,&maxlong,&realpt1,&realpt2);
                if(maxlong>lineminlong)
                {
                    stx=realpt1.x;
                    sty=realpt1.y;
                    edx=realpt2.x;
                    edy=realpt2.y;
                    if(first==0)
                    {
                        first=1;
                        st.x=stx;
                        st.y=sty;
                        ed.x=edx;
                        ed.y=edy;
                    }
                    else
                    {
                        if(sty<st.y)
                        {
                            st.x=stx;
                            st.y=sty;
                        }
                        if(edy>ed.y)
                        {
                            ed.x=edx;
                            ed.y=edy;
                        }
                    }
                }
            }
            if(first==0)
            {
                LineOut->line[n]=LineIn->line[n];
                LineOut->line[n]=LineIn->line[n];
                ResultMark[n] = FALSE;
                continue;
            }
            else
            {
                LineOut->line[n].st.x=st.x;
                LineOut->line[n].st.y=st.y;
                LineOut->line[n].ed.x=ed.x;
                LineOut->line[n].ed.y=ed.y;
                ResultMark[n] = TRUE;
            }
        }
        return 0;
    }

    Int8 Mysort_line(MyCountLine *LineIn,MyCountLine *LineOut,sortline Mod)
    {
        Int32 Index;
        Int32 linenum=0;
        Mypaixu paixu[MHC_SEARCH_LINENUM];
        MyCountLine LineTemp;

        LineOut->nHeight=LineIn->nHeight;
        LineOut->nWidth=LineIn->nWidth;
        LineOut->startx=LineIn->startx;
        LineOut->starty=LineIn->starty;
        LineOut->width=LineIn->width;
        LineOut->height=LineIn->height;
        LineOut->linenum=LineIn->linenum;
        switch(Mod)
        {
            case MHC_LONG_LINEPAIXU:
                for(Index=0; Index<LineIn->linenum; Index++)
                {
                    Int32 x1=LineIn->line[Index].st.x;
                    Int32 x2=LineIn->line[Index].ed.x;
                    Int32 y1=LineIn->line[Index].st.y;
                    Int32 y2=LineIn->line[Index].ed.y;
                    paixu[Index].value=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);
                    paixu[Index].i=Index;
                }
                QuickSortC(paixu,LineIn->linenum);
            break;
            case MHC_UP_LINEPAIXU:
                for(Index=0; Index<LineIn->linenum; Index++)
                {
                    paixu[Index].value=MIN(LineIn->line[Index].st.y,LineIn->line[Index].ed.y);
                    paixu[Index].i=Index;
                }
                QuickSortC(paixu,LineIn->linenum);
            break;
            case MHC_DOWN_LINEPAIXU:
                for(Index=0; Index<LineIn->linenum; Index++)
                {
                    paixu[Index].value=MAX(LineIn->line[Index].st.y,LineIn->line[Index].ed.y);
                    paixu[Index].i=Index;
                }
                QuickSortB(paixu,LineIn->linenum);
            break;
            case MHC_LEFT_LINEPAIXU:
                for(Index=0; Index<LineIn->linenum; Index++)
                {
                    paixu[Index].value=MIN(LineIn->line[Index].st.x,LineIn->line[Index].ed.x);
                    paixu[Index].i=Index;
                }
                QuickSortC(paixu,LineIn->linenum);
            break;
            case MHC_RIGHT_LINEPAIXU:
                for(Index=0; Index<LineIn->linenum; Index++)
                {
                    paixu[Index].value=MAX(LineIn->line[Index].st.x,LineIn->line[Index].ed.x);
                    paixu[Index].i=Index;
                }
                QuickSortB(paixu,LineIn->linenum);
            break;
            case MHC_CENTER_H_LINEPAIXU:
                for(Index=0; Index<LineIn->linenum; Index++)
                {
                    paixu[Index].value=((LineIn->line[Index].st.y+LineIn->line[Index].ed.y)>>1);
                    paixu[Index].i=Index;
                }
                QuickSortC(paixu,LineIn->linenum);
            break;
            case MHC_CENTER_W_LINEPAIXU:
                for(Index=0; Index<LineIn->linenum; Index++)
                {
                    paixu[Index].value=((LineIn->line[Index].st.x+LineIn->line[Index].ed.x)>>1);
                    paixu[Index].i=Index;
                }
                QuickSortC(paixu,LineIn->linenum);
            break;
            case MHC_K_LINEPAIXU:
                for(Index=0; Index<LineIn->linenum; Index++)
                {
                    Int32 x1=LineIn->line[Index].st.x;
                    Int32 x2=LineIn->line[Index].ed.x;
                    Int32 y1=LineIn->line[Index].st.y;
                    Int32 y2=LineIn->line[Index].ed.y;
                    if(x1-x2==0)
                    {
                        paixu[Index].value=FLT_MAX;
                    }
                    else
                    {
                        paixu[Index].value=(float)(y1-y2)/(x1-x2);
                    }
                    paixu[Index].i=Index;
                }
                QuickSortC(paixu,LineIn->linenum);
            break;
            default:
                return 1;
            break;
        }
        if(LineOut!=LineIn)
        {
            for(Index=0; Index<LineIn->linenum; Index++)
            {
                Int32 i=paixu[Index].i;
                LineOut->line[linenum]=LineIn->line[i];
                LineOut->houghinfo[linenum]=LineIn->houghinfo[i];
                linenum++;
            }
        }
        else
        {
            LineTemp=*LineIn;
            for(Index=0; Index<LineIn->linenum; Index++)
            {
                Int32 i=paixu[Index].i;
                LineOut->line[linenum]=LineTemp.line[i];
                LineOut->houghinfo[linenum]=LineTemp.houghinfo[i];
                linenum++;
            }
        }
        return 0;
    }

    Int8 Myselect_line(MyCountLine *LineIn,MyCountLine *LineOut,Int32 Index)
    {
        LineOut->nHeight=LineIn->nHeight;
        LineOut->nWidth=LineIn->nWidth;
        LineOut->startx=LineIn->startx;
        LineOut->starty=LineIn->starty;
        LineOut->width=LineIn->width;
        LineOut->height=LineIn->height;
        LineOut->linenum=1;

        if(Index>=LineIn->linenum)
            return 1;

        LineOut->line[0]=LineIn->line[Index];
        LineOut->houghinfo[0]=LineIn->houghinfo[Index];

        return 0;
    }

    Int8 MyX_to_Y_trans(Mat matIn,Mat *matOut)
    {
        Int32 nnHeight=matIn.nHeight;
        Int32 nnWidth=matIn.nWidth;
        Int32 nHeight=matIn.height;
        Int32 nWidth=matIn.width;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 i,j;
        Mat temp;
        cv::Mat cvimgIn,cvimgOut;

        if(matIn.data==matOut->data)
        {
            temp=MatCreatClone(matIn,u8_buffer_x3Temp1);
        }
        else
        {
            temp=matIn;
        }
        matOut->nWidth=nnHeight;
        matOut->nHeight=nnWidth;
        matOut->startx=nStartY;
        matOut->starty=nStartX;
        matOut->width=nHeight;
        matOut->height=nWidth;
        MyconvertTo(matOut,matIn._type);
        MatToCvMat(matIn,&cvimgIn);
        cv::rotate(cvimgIn, cvimgOut, cv::ROTATE_90_CLOCKWISE);
        memcpy(matOut->data,cvimgOut.data,cvimgOut.elemSize()*cvimgOut.rows*cvimgOut.cols);
        return 0;
    }

    Int8 Myaffine_trans_region_sincos(MyConect *ImageConectIn,MyConect *ImageConectOut,Int32 Range,Int32 Ox,Int32 Oy,transtype Mod)
    {
        Int32 Index,num;
        Int32 aa,bb,xTotal,yTotal;
        Int32 nWidth=ImageConectIn->nWidth;
        Int32 nHeight=ImageConectIn->nHeight;
        Int32 top,bottom,left,right;

        if(ImageConectOut!=ImageConectIn)
        {
            ImageConectOut->AllMarkPointCount=0;
            ImageConectOut->mianji=0;
            aa=0;
            bb=0;
            for(Index=0;Index<ImageConectIn->AllMarkPointCount;Index++)
            {
                aa=0;
                top=nHeight;
                bottom=0;
                left=nWidth;
                right=0;
                xTotal=0;
                yTotal=0;
                for(num=0;num<ImageConectIn->AllMarkPoint[Index].PointArea;num++)
                {
                    Int32 tempx=(Int32)trans_x((Int32)ImageConectIn->AllMarkPoint[Index].point[num].x,(Int32)ImageConectIn->AllMarkPoint[Index].point[num].y,Range,Ox,Oy);
                    Int32 tempy=(Int32)trans_y((Int32)ImageConectIn->AllMarkPoint[Index].point[num].x,(Int32)ImageConectIn->AllMarkPoint[Index].point[num].y,Range,Ox,Oy);
                    if(Mod==MHC_TRANS_INIMAGE)
                    {
                        if(tempx<0||tempx>=nWidth||tempy<0||tempy>=nHeight)
                            continue;
                    }
                    ImageConectOut->memPoint[aa+bb].x=tempx;
                    ImageConectOut->memPoint[aa+bb].y=tempy;
                    xTotal=xTotal+tempx;
                    yTotal=yTotal+tempy;
                    if(bottom<tempy)
                    {
                        bottom=tempy;
                    }
                    if(top>tempy)
                    {
                        top=tempy;
                    }
                    if(right<tempx)
                    {
                        right=tempx;
                    }
                    if(left>tempx)
                    {
                        left=tempx;
                    }
                    aa++;
                }
                ImageConectOut->AllMarkPoint[Index].left=left;
                ImageConectOut->AllMarkPoint[Index].right=right;
                ImageConectOut->AllMarkPoint[Index].top=top;
                ImageConectOut->AllMarkPoint[Index].bottom=bottom;
                ImageConectOut->AllMarkPoint[Index].xTotal=xTotal;
                ImageConectOut->AllMarkPoint[Index].yTotal=yTotal;
                ImageConectOut->AllMarkPoint[Index].PointArea=aa;
                ImageConectOut->AllMarkPoint[Index].point=&(ImageConectOut->memPoint[bb]);
                ImageConectOut->AllMarkPoint[Index].color=ImageConectIn->AllMarkPoint[Index].color;
                bb=aa+bb;
            }
            ImageConectOut->AllMarkPointCount=ImageConectIn->AllMarkPointCount;
            ImageConectOut->mianji=bb;
        }
        else
        {
            Uint8 *u8_buffer=(Uint8*)u8_buffer_x1Temp3;
            MyCopyObj(ImageConectIn,&conect_buffer3,u8_buffer);
            ImageConectOut->AllMarkPointCount=0;
            ImageConectOut->mianji=0;
            aa=0;
            bb=0;
            for(Index=0;Index<conect_buffer3.AllMarkPointCount;Index++)
            {
                aa=0;
                top=nHeight;
                bottom=0;
                left=nWidth;
                right=0;
                xTotal=0;
                yTotal=0;
                for(num=0;num<conect_buffer3.AllMarkPoint[Index].PointArea;num++)
                {
                    Int32 tempx=(Int32)trans_x((Int32)conect_buffer3.AllMarkPoint[Index].point[num].x,(Int32)conect_buffer3.AllMarkPoint[Index].point[num].y,Range,Ox,Oy);
                    Int32 tempy=(Int32)trans_y((Int32)conect_buffer3.AllMarkPoint[Index].point[num].x,(Int32)conect_buffer3.AllMarkPoint[Index].point[num].y,Range,Ox,Oy);
                    if(Mod==MHC_TRANS_INIMAGE)
                    {
                        if(tempx<0||tempx>=nWidth||tempy<0||tempy>=nHeight)
                            continue;
                    }
                    ImageConectOut->memPoint[aa+bb].x=tempx;
                    ImageConectOut->memPoint[aa+bb].y=tempy;
                    xTotal=xTotal+tempx;
                    yTotal=yTotal+tempy;
                    if(bottom<tempy)
                    {
                        bottom=tempy;
                    }
                    if(top>tempy)
                    {
                        top=tempy;
                    }
                    if(right<tempx)
                    {
                        right=tempx;
                    }
                    if(left>tempx)
                    {
                        left=tempx;
                    }
                    aa++;
                }
                ImageConectOut->AllMarkPoint[Index].left=left;
                ImageConectOut->AllMarkPoint[Index].right=right;
                ImageConectOut->AllMarkPoint[Index].top=top;
                ImageConectOut->AllMarkPoint[Index].bottom=bottom;
                ImageConectOut->AllMarkPoint[Index].xTotal=xTotal;
                ImageConectOut->AllMarkPoint[Index].yTotal=yTotal;
                ImageConectOut->AllMarkPoint[Index].PointArea=aa;
                ImageConectOut->AllMarkPoint[Index].point=&(ImageConectOut->memPoint[bb]);
                ImageConectOut->AllMarkPoint[Index].color=conect_buffer3.AllMarkPoint[Index].color;
                bb=aa+bb;
            }
            ImageConectOut->AllMarkPointCount=conect_buffer3.AllMarkPointCount;
            ImageConectOut->mianji=bb;
        }
        return 0;
    }

    Int8 Myhom_conect2d_translate(MyConect *ImageConectIn,MyConect *ImageConectOut,Int32 movex,Int32 movey,transtype Mod)
    {
        Int32 Index,num;
        Int32 aa,bb,xTotal,yTotal;
        Int32 nWidth=ImageConectIn->nWidth;
        Int32 nHeight=ImageConectIn->nHeight;
        Int32 top,bottom,left,right;

        if(ImageConectOut!=ImageConectIn)
        {
            ImageConectOut->AllMarkPointCount=0;
            ImageConectOut->mianji=0;
            aa=0;
            bb=0;
            ImageConectOut->memPoint=ImageConectIn->memPoint;
            for(Index=0;Index<ImageConectIn->AllMarkPointCount;Index++)
            {
                aa=0;
                top=RANDOM_MAX;
                bottom=0;
                left=RANDOM_MAX;
                right=0;
                xTotal=0;
                yTotal=0;
                for(num=0;num<ImageConectIn->AllMarkPoint[Index].PointArea;num++)
                {
                    Int32 tempx=ImageConectIn->AllMarkPoint[Index].point[num].x+movex;
                    Int32 tempy=ImageConectIn->AllMarkPoint[Index].point[num].y+movey;
                    if(Mod==MHC_TRANS_INIMAGE)
                    {
                        if(tempx<0||tempx>=nWidth||tempy<0||tempy>=nHeight)
                            continue;
                    }
                    ImageConectOut->memPoint[aa+bb].x=tempx;
                    ImageConectOut->memPoint[aa+bb].y=tempy;
                    xTotal=xTotal+tempx;
                    yTotal=yTotal+tempy;
                    if(bottom<tempy)
                    {
                        bottom=tempy;
                    }
                    if(top>tempy)
                    {
                        top=tempy;
                    }
                    if(right<tempx)
                    {
                        right=tempx;
                    }
                    if(left>tempx)
                    {
                        left=tempx;
                    }
                    aa++;
                }
                ImageConectOut->AllMarkPoint[Index].left=left;
                ImageConectOut->AllMarkPoint[Index].right=right;
                ImageConectOut->AllMarkPoint[Index].top=top;
                ImageConectOut->AllMarkPoint[Index].bottom=bottom;
                ImageConectOut->AllMarkPoint[Index].xTotal=xTotal;
                ImageConectOut->AllMarkPoint[Index].yTotal=yTotal;
                ImageConectOut->AllMarkPoint[Index].PointArea=aa;
                ImageConectOut->AllMarkPoint[Index].point=&(ImageConectOut->memPoint[bb]);
                ImageConectOut->AllMarkPoint[Index].color=ImageConectIn->AllMarkPoint[Index].color;
                bb=aa+bb;
            }
            ImageConectOut->AllMarkPointCount=ImageConectIn->AllMarkPointCount;
            ImageConectOut->mianji=bb;
        }
        else
        {
            Uint8 *u8_buffer=(Uint8*)u8_buffer_x1Temp3;
            MyCopyObj(ImageConectIn,&conect_buffer3,u8_buffer);
            ImageConectOut->AllMarkPointCount=0;
            ImageConectOut->mianji=0;
            aa=0;
            bb=0;
            ImageConectOut->memPoint=conect_buffer3.memPoint;
            for(Index=0;Index<conect_buffer3.AllMarkPointCount;Index++)
            {
                aa=0;
                top=RANDOM_MAX;
                bottom=0;
                left=RANDOM_MAX;
                right=0;
                xTotal=0;
                yTotal=0;
                for(num=0;num<conect_buffer3.AllMarkPoint[Index].PointArea;num++)
                {
                    Int32 tempx=conect_buffer3.AllMarkPoint[Index].point[num].x+movex;
                    Int32 tempy=conect_buffer3.AllMarkPoint[Index].point[num].y+movey;
                    if(Mod==MHC_TRANS_INIMAGE)
                    {
                        if(tempx<0||tempx>=nWidth||tempy<0||tempy>=nHeight)
                            continue;
                    }
                    ImageConectOut->memPoint[aa+bb].x=tempx;
                    ImageConectOut->memPoint[aa+bb].y=tempy;
                    xTotal=xTotal+tempx;
                    yTotal=yTotal+tempy;
                    if(bottom<tempy)
                    {
                        bottom=tempy;
                    }
                    if(top>tempy)
                    {
                        top=tempy;
                    }
                    if(right<tempx)
                    {
                        right=tempx;
                    }
                    if(left>tempx)
                    {
                        left=tempx;
                    }
                    aa++;
                }
                ImageConectOut->AllMarkPoint[Index].left=left;
                ImageConectOut->AllMarkPoint[Index].right=right;
                ImageConectOut->AllMarkPoint[Index].top=top;
                ImageConectOut->AllMarkPoint[Index].bottom=bottom;
                ImageConectOut->AllMarkPoint[Index].xTotal=xTotal;
                ImageConectOut->AllMarkPoint[Index].yTotal=yTotal;
                ImageConectOut->AllMarkPoint[Index].PointArea=aa;
                ImageConectOut->AllMarkPoint[Index].point=&(ImageConectOut->memPoint[bb]);
                ImageConectOut->AllMarkPoint[Index].color=conect_buffer3.AllMarkPoint[Index].color;
                bb=aa+bb;
            }
            ImageConectOut->AllMarkPointCount=conect_buffer3.AllMarkPointCount;
            ImageConectOut->mianji=bb;
        }
        return 0;
    }

    Int32 getsizeof(type Mod)
    {
        Int32 size;
        switch(Mod)
        {
            case CCV_8UC1:
                size=sizeof(Uint8);
            break;
            case CCV_8UC3:
                size=sizeof(Uint8)*3;
            break;
            case CCV_8SC1:
                size=sizeof(Int8);
            break;
            case CCV_8SC3:
                size=sizeof(Int8)*3;
            break;
            case CCV_16UC1:
                size=sizeof(Uint16);
            break;
            case CCV_16UC3:
                size=sizeof(Uint16)*3;
            break;
            case CCV_16SC1:
                size=sizeof(Int16);
            break;
            case CCV_16SC3:
                size=sizeof(Int16)*3;
            break;
            case CCV_32SC1:
                size=sizeof(Int32);
            break;
            case CCV_32SC3:
                size=sizeof(Int32)*3;
            break;
            case CCV_32FC1:
                size=sizeof(float);
            break;
            case CCV_32FC3:
                size=sizeof(float)*3;
            break;
            case CCV_64FC1:
                size=sizeof(double);
            break;
            case CCV_64FC3:
                size=sizeof(double)*3;
            break;
        }
        return size;
    }

    static long my_do_rand(unsigned long *value)
    {
       long quotient, remainder, t;


       quotient = *value / 127773L;

       remainder = *value % 127773L;

       t = 16807L * remainder - 2836L * quotient;


       if (t <= 0)

          t += 0x7FFFFFFFL;

       return ((*value = t) % ((unsigned long)RANDOM_MAX + 1));

    }

    Int32 My_rand(void)

    {
       return my_do_rand(&mhc_next);
    }

    void My_srand(Uint32 seed)

    {
       mhc_next = seed;
    }

    Int32 getVerbsizeof(Int32 Vernum)
    {
        Int32 num=(Vernum>>5)+1;
        return (num*sizeof(Int32));
    }

    Int32 getVer1isizeof(Int32 Vernum)
    {
        return (sizeof(Int32)*Vernum);
    }

    Int32 getVer2isizeof(Int32 Vernum)
    {
        return (sizeof(L_Point32)*Vernum);
    }

    Int32 getVer3isizeof(Int32 Vernum)
    {
        return (sizeof(Vec3i)*Vernum);
    }

    Int32 getVer2vsizeof(Int32 Vernum)
    {
        return (sizeof(Vec2v)*Vernum);
    }

    Int32 getVer3vsizeof(Int32 Vernum)
    {
        return (sizeof(Vec3v)*Vernum);
    }

    Int32 get_1_num_in_bin(Uint32 n)
    {
        n=(n&0x55555555)+((n>>1)&0x55555555);
        n=(n&0x33333333)+((n>>2)&0x33333333);
        n=(n&0x0f0f0f0f)+((n>>4)&0x0f0f0f0f);
        n=(n&0x00ff00ff)+((n>>8)&0x00ff00ff);
        n=(n&0x0000ffff)+((n>>16)&0x0000ffff);
        return n;
    }

    void getcloneinfo(Mat matIn,Mat *matOut)
    {
        matOut->nWidth=matIn.nWidth;
        matOut->nHeight=matIn.nHeight;
        matOut->startx=matIn.startx;
        matOut->starty=matIn.starty;
        matOut->width=matIn.width;
        matOut->height=matIn.height;
        MyconvertTo(matOut,matIn._type);
    }

    Int8 judgeMaskSize(Mat matIn,Mat mask)//判断Mask尺寸是否符合
    {
        if(mask._type!=CCV_8UC1||mask.nHeight!=matIn.nHeight||mask.nWidth!=matIn.nWidth)
            return 1;
        else
            return 0;
    }

    Int8 judgeCMaskSize(MyConect *ImageConectIn,Mat mask)
    {
        if(mask._type!=CCV_8UC1||mask.nHeight!=ImageConectIn->nHeight||mask.nWidth!=ImageConectIn->nWidth)
            return 1;
        else
            return 0;
    }

    Int8 judgeCImageSize(MyConect *ImageConectIn,Mat image)
    {
        if((image._type!=CCV_8UC1&&image._type!=CCV_8UC3)||image.nHeight!=ImageConectIn->nHeight||image.nWidth!=ImageConectIn->nWidth)
            return 1;
        else
            return 0;
    }

    Int8 judgeLMaskSize(MyCountLine *LineIn,Mat image)
    {
        if(image._type!=CCV_8UC1&&image._type!=CCV_8UC3)
            return 1;
        else if(image.nHeight!=LineIn->nHeight||image.nWidth!=LineIn->nWidth)
            return 2;
        else
            return 0;
    }

    Int8 judgeDataNotzero(Mat matIn,L_Point *notzeroLoc)
    {
        Int32 j,i;
        Int32 nnWidth=matIn.nWidth;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        switch(matIn._type)
        {
            case CCV_8UC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(matIn.ptr_uchar[j*nnWidth+i]!=0)
                        {
                            notzeroLoc->x=i;
                            notzeroLoc->y=j;
                            return 0;
                        }
                    }
                }
                return 1;
            break;
            case CCV_8UC3:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(matIn.ptr_Vec3b[j*nnWidth+i].data1!=0||
                           matIn.ptr_Vec3b[j*nnWidth+i].data2!=0||
                           matIn.ptr_Vec3b[j*nnWidth+i].data3!=0)
                        {
                            notzeroLoc->x=i;
                            notzeroLoc->y=j;
                            return 0;
                        }
                    }
                }
                return 1;
            break;
            case CCV_8SC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(matIn.ptr_char[j*nnWidth+i]!=0)
                        {
                            notzeroLoc->x=i;
                            notzeroLoc->y=j;
                            return 0;
                        }
                    }
                }
                return 1;
            break;
            case CCV_8SC3:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(matIn.ptr_Vec3ib[j*nnWidth+i].data1!=0||
                           matIn.ptr_Vec3ib[j*nnWidth+i].data2!=0||
                           matIn.ptr_Vec3ib[j*nnWidth+i].data3!=0)
                        {
                            notzeroLoc->x=i;
                            notzeroLoc->y=j;
                            return 0;
                        }
                    }
                }
                return 1;
            break;
            case CCV_16UC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(matIn.ptr_ushort[j*nnWidth+i]!=0)
                        {
                            notzeroLoc->x=i;
                            notzeroLoc->y=j;
                            return 0;
                        }
                    }
                }
                return 1;
            break;
            case CCV_16UC3:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(matIn.ptr_Vec3s[j*nnWidth+i].data1!=0||
                           matIn.ptr_Vec3s[j*nnWidth+i].data2!=0||
                           matIn.ptr_Vec3s[j*nnWidth+i].data3!=0)
                        {
                            notzeroLoc->x=i;
                            notzeroLoc->y=j;
                            return 0;
                        }
                    }
                }
                return 1;
            break;
            case CCV_32SC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(matIn.ptr_int[j*nnWidth+i]!=0)
                        {
                            notzeroLoc->x=i;
                            notzeroLoc->y=j;
                            return 0;
                        }
                    }
                }
                return 1;
            break;
            case CCV_32SC3:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(matIn.ptr_Vec3i[j*nnWidth+i].data1!=0||
                           matIn.ptr_Vec3i[j*nnWidth+i].data2!=0||
                           matIn.ptr_Vec3i[j*nnWidth+i].data3!=0)
                        {
                            notzeroLoc->x=i;
                            notzeroLoc->y=j;
                            return 0;
                        }
                    }
                }
                return 1;
            break;
            case CCV_32FC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(matIn.ptr_float[j*nnWidth+i]!=0)
                        {
                            notzeroLoc->x=i;
                            notzeroLoc->y=j;
                            return 0;
                        }
                    }
                }
                return 1;
            break;
            case CCV_32FC3:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(matIn.ptr_Vec3f[j*nnWidth+i].data1!=0||
                           matIn.ptr_Vec3f[j*nnWidth+i].data2!=0||
                           matIn.ptr_Vec3f[j*nnWidth+i].data3!=0)
                        {
                            notzeroLoc->x=i;
                            notzeroLoc->y=j;
                            return 0;
                        }
                    }
                }
                return 1;
            break;
            case CCV_64FC1:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(matIn.ptr_double[j*nnWidth+i]!=0)
                        {
                            notzeroLoc->x=i;
                            notzeroLoc->y=j;
                            return 0;
                        }
                    }
                }
                return 1;
            break;
            case CCV_64FC3:
                for(j=nStartY;j<nStartY+nHeight;j++)
                {
                    for(i=nStartX;i<nStartX+nWidth;i++)
                    {
                        if(matIn.ptr_Vec3d[j*nnWidth+i].data1!=0||
                           matIn.ptr_Vec3d[j*nnWidth+i].data2!=0||
                           matIn.ptr_Vec3d[j*nnWidth+i].data3!=0)
                        {
                            notzeroLoc->x=i;
                            notzeroLoc->y=j;
                            return 0;
                        }
                    }
                }
                return 1;
            break;
            default:
                return 1;
            break;
        }
    }

    Int8 MyNon_Maximal(Mat matIn,Mat *matOut,Int16 value,non_max Mod)
    {
        Int32 nnWidth=matIn.nWidth;
        Int32 nnHeight=matIn.nHeight;
        Int32 nStartY=matIn.starty;
        Int32 nHeight=matIn.height;
        Int32 nStartX=matIn.startx;
        Int32 nWidth=matIn.width;
        Int32 i,j;
        cv::Mat cvimgIn,cvimgOut;
        cv::Mat cvRoi;
        Int32 stY,stX,edY,edX;
        Mat matIntemp;
        Int32 di,longi;

        matOut->nWidth=matIn.nWidth;
        matOut->nHeight=matIn.nHeight;
        matOut->startx=matIn.startx;
        matOut->starty=matIn.starty;
        matOut->width=matIn.width;
        matOut->height=matIn.height;
        MyconvertTo(matOut,CCV_8UC1);

        if(matIn.data==matOut->data)
        {
            switch(matIn._type)
            {
                case CCV_8UC1:
                case CCV_16UC1:
                break;
                default:
                    return 1;
                break;
            }
            matIntemp=MatCreatClone(matIn,(Uint8*)u8_buffer_x1Temp2);
        }
        else
        {
            matIntemp=matIn;
        }

        MyCutRoiSetZero(&matIntemp);

        switch(matIn._type)
        {
            case CCV_8UC1:
                cvimgIn=cv::Mat(matIntemp.nHeight,matIntemp.nWidth,CV_8U);
                memcpy(cvimgIn.data,matIntemp.data,getsizeof(matIntemp._type)*matIntemp.nHeight*matIntemp.nWidth);
            break;
            case CCV_16UC1:
                cvimgIn=cv::Mat(matIntemp.nHeight,matIntemp.nWidth,CV_16U);
                memcpy(cvimgIn.data,matIntemp.data,getsizeof(matIntemp._type)*matIntemp.nHeight*matIntemp.nWidth);
            break;
            default:
                return 1;
            break;
        }

        MatSet1col(matOut,0);

        stY=nStartY;
        stX=nStartX;
        edY=nStartY+nHeight-1;
        edX=nStartX+nWidth-1;

        switch(Mod)
        {
            case NON_MAX_3x3:
                if(stY<1)
                    stY=1;
                if(edY>nnHeight-1)
                    edY=nnHeight-1;
                if(stX<1)
                    stX=1;
                if(edX>nnWidth-1)
                    edX=nnWidth-1;
                di=1;
                longi=3;
            break;
            case NON_MAX_5x5:
                if(stY<2)
                    stY=2;
                if(edY>nnHeight-2)
                    edY=nnHeight-2;
                if(stX<2)
                    stX=2;
                if(edX>nnWidth-2)
                    edX=nnWidth-2;
                di=2;
                longi=5;
            break;
            case NON_MAX_7x7:
                if(stY<3)
                    stY=3;
                if(edY>nnHeight-3)
                    edY=nnHeight-3;
                if(stX<3)
                    stX=3;
                if(edX>nnWidth-3)
                    edX=nnWidth-3;
                di=3;
                longi=7;
            break;
            default:
                return 2;
            break;
        }
        switch(matIn._type)
        {
            case CCV_8UC1:
                for(j=stY;j<=edY;j++)
                {
                    for(i=stX;i<=edX;i++)
                    {
                        if(matIntemp.ptr_uchar[j*nnWidth+i]>value)
                        {
                            double max;
                            cvRoi=cvimgIn(cv::Rect(i-di,j-di,longi,longi));
                            cv::minMaxLoc(cvRoi,0,&max);
                            if(matIntemp.ptr_uchar[j*nnWidth+i]==(Int32)max)
                            {
                                matOut->ptr_uchar[j*nnWidth+i]=255;
                            }
                        }
                    }
                }
            break;
            case CCV_16UC1:
                for(j=stY;j<=edY;j++)
                {
                    for(i=stX;i<=edX;i++)
                    {
                        if(matIntemp.ptr_ushort[j*nnWidth+i]>value)
                        {
                            double max;
                            cvRoi=cvimgIn(cv::Rect(i-di,j-di,longi,longi));
                            cv::minMaxLoc(cvRoi,0,&max);
                            if(matIntemp.ptr_ushort[j*nnWidth+i]==(Int32)max)
                            {
                                matOut->ptr_uchar[j*nnWidth+i]=255;
                            }
                        }
                    }
                }
            break;
            default:
                return 2;
            break;
        }
        return 0;
    }

    Int8 Myimrite(const char *str,Mat matIn)
    {
        Int32 nHeight=matIn.nHeight;
        Int32 nWidth=matIn.nWidth;
        Int32 nnWidth;
        Uint8 quard[1024];
        Uint8 *locate;
        FILE *fp;
        Int32 i,j;
        Vec3b *u8_3data;
        Int8 returnnum=0;
        Uint8 zero=0;

        fp = fopen(str, "wb+");
        switch(matIn._type)
        {
            case CCV_8UC1:
                nnWidth=(nWidth+3)/4*4;
                for (i = 0; i < 256; i ++)
                {
                    quard[i * 4] = i;
                    quard[i * 4 + 1] = i;
                    quard[i * 4 + 2] = i;
                    quard[i * 4 + 3] = 0;
                }
                MHC_BitMapFileHeaderZoom.bfSize = 14 + 40 + 1024 + nnWidth * nHeight;
                locate = (Uint8 *) &MHC_BitMapFileHeaderZoom;
                locate = locate + 2;
                fwrite(locate, 1, 14, fp);
                MHC_BitMapInfoHeader.biHeight = nHeight;
                MHC_BitMapInfoHeader.biWidth = nWidth;
                MHC_BitMapInfoHeader.biSizeImage = nnWidth * nHeight;
                fwrite(&MHC_BitMapInfoHeader, 1, 40, fp);
                fwrite(quard, 1, 1024, fp);
                for(j=0;j<nHeight;j++)
                {
                    for(i=0;i<nnWidth;i++)
                    {
                        if(i<nWidth)
                            fwrite(&matIn.ptr_uchar[j*nWidth+i],1,1,fp);
                        else
                            fwrite(&zero,1,1,fp);
                    }
                }
            break;
            case CCV_8UC3:
                nnWidth=(nWidth*3+3)/4*4;
                MHC_BitMapFileHeader_24Zoom.bfSize = 14 + 40 + nnWidth * nHeight;
                locate = (Uint8 *) &MHC_BitMapFileHeader_24Zoom;
                locate = locate + 2;
                fwrite(locate, 1, 14, fp);
                MHC_BitMapInfoHeader_24.biHeight = nHeight;
                MHC_BitMapInfoHeader_24.biWidth = nWidth;
                MHC_BitMapInfoHeader_24.biSizeImage = nnWidth * nHeight;
                fwrite(&MHC_BitMapInfoHeader_24, 1, 40, fp);
                u8_3data=matIn.ptr_Vec3b;

                for(j=0;j<nHeight;j++)
                {
                    for(i=0;i<nWidth;i++)
                    {
                        fwrite(&u8_3data[j*nWidth+i].data3,1,1,fp);//B
                        fwrite(&u8_3data[j*nWidth+i].data2,1,1,fp);//G
                        fwrite(&u8_3data[j*nWidth+i].data1,1,1,fp);//R
                    }
                    for(i=nWidth*3+1;i<nnWidth;i++)
                    {
                        fwrite(&zero,1,1,fp);
                    }
                }
            break;
            default:
                returnnum=1;
            break;
        }
        fclose(fp);
        return returnnum;
    }

    Int8 Myflip(Mat matIn,Mat *matOut,fliptype Mod)
    {
        Int32 nnHeight=matIn.nHeight;
        Int32 nnWidth=matIn.nWidth;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        Int32 i,j;
        Mat temp;

        if(matIn.data==matOut->data)
        {
            temp=MatCreatClone(matIn,u8_buffer_x3Temp1);
        }
        else
        {
            temp=matIn;
        }
        MyconvertTo(matOut,matIn._type);

        switch(Mod)
        {
            case MHC_FLIP_X:
                matOut->nWidth=nnWidth;
                matOut->nHeight=nnHeight;
                matOut->startx=nnWidth-(nStartX+nWidth);
                matOut->starty=nStartY;
                matOut->width=nWidth;
                matOut->height=nHeight;
            break;
            case MHC_FLIP_Y:
                matOut->nWidth=nnWidth;
                matOut->nHeight=nnHeight;
                matOut->startx=nStartX;
                matOut->starty=nnHeight-(nStartY+nHeight);
                matOut->width=nWidth;
                matOut->height=nHeight;
            break;
            default:
                return 1;
            break;
        }
        switch(matIn._type)
        {
            case CCV_8UC1:
                switch(Mod)
                {
                    case MHC_FLIP_X:
                        for(j=0;j<nnHeight;j++)
                        {
                            for(i=0;i<nnWidth;i++)
                            {
                                matOut->data[j*nnWidth+i]=temp.data[j*nnWidth+(nnWidth-i-1)];
                            }
                        }
                    break;
                    case MHC_FLIP_Y:
                        for(j=0;j<nnHeight;j++)
                        {
                            memcpy(&matOut->data[j*nnWidth],&temp.data[(nnHeight-j-1)*nnWidth],nnWidth);
                        }
                    break;
                    default:
                        return 1;
                    break;
                }
            break;
            case CCV_8UC3:
                switch(Mod)
                {
                    case MHC_FLIP_X:
                        for(j=0;j<nnHeight;j++)
                        {
                            for(i=0;i<nnWidth;i++)
                            {
                                matOut->ptr_Vec3b[j*nnWidth+i]=temp.ptr_Vec3b[j*nnWidth+(nnWidth-i-1)];
                            }
                        }
                    break;
                    case MHC_FLIP_Y:
                        for(j=0;j<nnHeight;j++)
                        {
                            memcpy(&matOut->ptr_Vec3b[j*nnWidth],&temp.ptr_Vec3b[(nnHeight-j-1)*nnWidth],nnWidth*sizeof(Vec3b));
                        }
                    break;
                    default:
                        return 1;
                    break;
                }
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 Myimread(const char *str,Mat *matIn_Out)
    {
        FILE *fp;
        MHC_BITMAPFILEHEADER bmpFileHeader;
        MHC_BITMAPINFOHEADER bmpInfo;
        Int32 nnWidth;
        Int32 nWidth;
        Int32 nHeight;
        Int32 i,j;
        Uint8 temp;
        Int32 i32_nHeight;
        if((fp=fopen(str,"rb"))==NULL)
        {
            return 1;
        }
        fseek(fp,0,SEEK_SET);
        fread(&bmpFileHeader,14,1,fp);
        fread(&bmpInfo,40,1,fp);
        if(bmpFileHeader.bfType!=0x4D42)
        {
            fclose(fp);
            return 2;
        }
        i32_nHeight=bmpInfo.biHeight;
        nHeight=abs(i32_nHeight);
        matIn_Out->nHeight=nHeight;
        nWidth=bmpInfo.biWidth;
        matIn_Out->startx=0;
        matIn_Out->starty=0;
        matIn_Out->height=nHeight;
        if(bmpInfo.biBitCount==0x08)
        {
            nnWidth=(nWidth+3)/4*4;
            matIn_Out->nWidth=nnWidth;
            matIn_Out->width=nnWidth;
            MyconvertTo(matIn_Out,CCV_8UC1);
            fseek(fp,0x0400,SEEK_CUR);
            fread(matIn_Out->data,1,nHeight*nnWidth,fp);
        }
        else if(bmpInfo.biBitCount==0x18)
        {
            nnWidth=(nWidth*3+3)/4*4;
            matIn_Out->nWidth=nWidth;
            matIn_Out->width=nWidth;
            MyconvertTo(matIn_Out,CCV_8UC3);
            for(j=0;j<nHeight;j++)
            {
                for(i=0;i<nWidth;i++)
                {
                    fread(&matIn_Out->ptr_Vec3b[j*nWidth+i].data3,1,1,fp);
                    fread(&matIn_Out->ptr_Vec3b[j*nWidth+i].data2,1,1,fp);
                    fread(&matIn_Out->ptr_Vec3b[j*nWidth+i].data1,1,1,fp);
                }
                for(i=nWidth*3+1;i<nnWidth;i++)
                {
                    fread(&temp,1,1,fp);
                }
            }
        }
        else if(bmpInfo.biBitCount==0x20)
        {
            nnWidth=(nWidth*4+3)/4*4;
            matIn_Out->nWidth=nWidth;
            matIn_Out->width=nWidth;
            MyconvertTo(matIn_Out,CCV_8UC3);
            for(j=0;j<nHeight;j++)
            {
                for(i=0;i<nWidth;i++)
                {
                    fread(&matIn_Out->ptr_Vec3b[j*nWidth+i].data3,1,1,fp);
                    fread(&matIn_Out->ptr_Vec3b[j*nWidth+i].data2,1,1,fp);
                    fread(&matIn_Out->ptr_Vec3b[j*nWidth+i].data1,1,1,fp);
                    fread(&temp,1,1,fp);
                }
                for(i=nWidth*4+1;i<nnWidth;i++)
                {
                    fread(&temp,1,1,fp);
                }
            }
        }
        else
        {
            fclose(fp);
            return 3;
        }
        fclose(fp);
        if(i32_nHeight<0)
        {
            Myflip(*matIn_Out,matIn_Out,MHC_FLIP_Y);//沿着Y轴翻转(DSP时去掉)
        }
        return 0;
    }

    Int8 MyMatSaveTxt(const char *str,Mat matIn)
    {
        FILE *fp;
        Int32 nHeight=matIn.nHeight;
        Int32 nWidth=matIn.nWidth;
        Int32 i,j;
        char string[50];

        fp = fopen(str, "wb+");
        fseek(fp,0,SEEK_SET);
        switch(matIn._type)
        {
            case CCV_8UC1:
                sprintf(string,"CV_8UC1\n",NULL);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"nWidth=%d\n",nWidth);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"nHeight=%d\n",nHeight);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"startx=%d\n",matIn.startx);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"starty=%d\n",matIn.starty);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"width=%d\n",matIn.width);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"height=%d\n",matIn.height);
                fwrite(string, 1, strlen(string), fp);
                for(j=0;j<nHeight;j++)
                {
                    if(j!=0)
                        fwrite("\n", 1, 1, fp);
                    for(i=0;i<nWidth;i++)
                    {
                        sprintf(string,"%02x ",matIn.ptr_uchar[j*nWidth+i]);
                        fwrite(string, 1, strlen(string), fp);
                    }
                }
            break;
            case CCV_8SC1:
                sprintf(string,"CV_8SC1\n",NULL);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"nWidth=%d\n",nWidth);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"nHeight=%d\n",nHeight);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"startx=%d\n",matIn.startx);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"starty=%d\n",matIn.starty);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"width=%d\n",matIn.width);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"height=%d\n",matIn.height);
                fwrite(string, 1, strlen(string), fp);
                for(j=0;j<nHeight;j++)
                {
                    if(j!=0)
                        fwrite("\n", 1, 1, fp);
                    for(i=0;i<nWidth;i++)
                    {
                        sprintf(string,"%02x ",matIn.ptr_char[j*nWidth+i]);
                        fwrite(string, 1, strlen(string), fp);
                    }
                }
            break;
            case CCV_8UC3:
                sprintf(string,"CV_8UC3\n",NULL);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"nWidth=%d\n",nWidth);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"nHeight=%d\n",nHeight);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"startx=%d\n",matIn.startx);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"starty=%d\n",matIn.starty);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"width=%d\n",matIn.width);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"height=%d\n",matIn.height);
                fwrite(string, 1, strlen(string), fp);
                for(j=0;j<nHeight;j++)
                {
                    if(j!=0)
                        fwrite("\n", 1, 1, fp);
                    for(i=0;i<nWidth;i++)
                    {
                        sprintf(string,"(%02x,%02x,%02x) ",matIn.ptr_Vec3b[j*nWidth+i].data1,matIn.ptr_Vec3b[j*nWidth+i].data2,matIn.ptr_Vec3b[j*nWidth+i].data3);
                        fwrite(string, 1, strlen(string), fp);
                    }
                }
            break;
            case CCV_8SC3:
                sprintf(string,"CV_8SC3\n",NULL);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"nWidth=%d\n",nWidth);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"nHeight=%d\n",nHeight);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"startx=%d\n",matIn.startx);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"starty=%d\n",matIn.starty);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"width=%d\n",matIn.width);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"height=%d\n",matIn.height);
                fwrite(string, 1, strlen(string), fp);
                for(j=0;j<nHeight;j++)
                {
                    if(j!=0)
                        fwrite("\n", 1, 1, fp);
                    for(i=0;i<nWidth;i++)
                    {
                        sprintf(string,"(%02x,%02x,%02x) ",matIn.ptr_Vec3ib[j*nWidth+i].data1,matIn.ptr_Vec3ib[j*nWidth+i].data2,matIn.ptr_Vec3ib[j*nWidth+i].data3);
                        fwrite(string, 1, strlen(string), fp);
                    }
                }
            break;
            case CCV_16UC1:
                sprintf(string,"CV_16UC1\n",NULL);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"nWidth=%d\n",nWidth);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"nHeight=%d\n",nHeight);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"startx=%d\n",matIn.startx);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"starty=%d\n",matIn.starty);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"width=%d\n",matIn.width);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"height=%d\n",matIn.height);
                fwrite(string, 1, strlen(string), fp);
                for(j=0;j<nHeight;j++)
                {
                    if(j!=0)
                        fwrite("\n", 1, 1, fp);
                    for(i=0;i<nWidth;i++)
                    {
                        sprintf(string,"%04x ",matIn.ptr_ushort[j*nWidth+i]);
                        fwrite(string, 1, strlen(string), fp);
                    }
                }
            break;
            case CCV_16UC3:
                sprintf(string,"CV_16UC3\n",NULL);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"nWidth=%d\n",nWidth);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"nHeight=%d\n",nHeight);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"startx=%d\n",matIn.startx);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"starty=%d\n",matIn.starty);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"width=%d\n",matIn.width);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"height=%d\n",matIn.height);
                fwrite(string, 1, strlen(string), fp);
                for(j=0;j<nHeight;j++)
                {
                    if(j!=0)
                        fwrite("\n", 1, 1, fp);
                    for(i=0;i<nWidth;i++)
                    {
                        sprintf(string,"(%04x,%04x,%04x) ",matIn.ptr_Vec3s[j*nWidth+i].data1,matIn.ptr_Vec3s[j*nWidth+i].data2,matIn.ptr_Vec3s[j*nWidth+i].data3);
                        fwrite(string, 1, strlen(string), fp);
                    }
                }
            break;
            case CCV_16SC1:
                sprintf(string,"CV_16SC1\n",NULL);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"nWidth=%d\n",nWidth);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"nHeight=%d\n",nHeight);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"startx=%d\n",matIn.startx);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"starty=%d\n",matIn.starty);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"width=%d\n",matIn.width);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"height=%d\n",matIn.height);
                fwrite(string, 1, strlen(string), fp);
                for(j=0;j<nHeight;j++)
                {
                    if(j!=0)
                        fwrite("\n", 1, 1, fp);
                    for(i=0;i<nWidth;i++)
                    {
                        sprintf(string,"%04x ",matIn.ptr_short[j*nWidth+i]);
                        fwrite(string, 1, strlen(string), fp);
                    }
                }
            break;
            case CCV_16SC3:
                sprintf(string,"CV_16SC3\n",NULL);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"nWidth=%d\n",nWidth);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"nHeight=%d\n",nHeight);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"startx=%d\n",matIn.startx);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"starty=%d\n",matIn.starty);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"width=%d\n",matIn.width);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"height=%d\n",matIn.height);
                fwrite(string, 1, strlen(string), fp);
                for(j=0;j<nHeight;j++)
                {
                    if(j!=0)
                        fwrite("\n", 1, 1, fp);
                    for(i=0;i<nWidth;i++)
                    {
                        sprintf(string,"(%04x,%04x,%04x) ",matIn.ptr_Vec3w[j*nWidth+i].data1,matIn.ptr_Vec3w[j*nWidth+i].data2,matIn.ptr_Vec3w[j*nWidth+i].data3);
                        fwrite(string, 1, strlen(string), fp);
                    }
                }
            break;
            case CCV_32SC1:
                sprintf(string,"CV_32SC1\n",NULL);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"nWidth=%d\n",nWidth);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"nHeight=%d\n",nHeight);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"startx=%d\n",matIn.startx);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"starty=%d\n",matIn.starty);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"width=%d\n",matIn.width);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"height=%d\n",matIn.height);
                fwrite(string, 1, strlen(string), fp);
                for(j=0;j<nHeight;j++)
                {
                    if(j!=0)
                        fwrite("\n", 1, 1, fp);
                    for(i=0;i<nWidth;i++)
                    {
                        sprintf(string,"%08x ",matIn.ptr_int[j*nWidth+i]);
                        fwrite(string, 1, strlen(string), fp);
                    }
                }
            break;
            case CCV_32SC3:
                sprintf(string,"CV_32SC3\n",NULL);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"nWidth=%d\n",nWidth);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"nHeight=%d\n",nHeight);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"startx=%d\n",matIn.startx);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"starty=%d\n",matIn.starty);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"width=%d\n",matIn.width);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"height=%d\n",matIn.height);
                fwrite(string, 1, strlen(string), fp);
                for(j=0;j<nHeight;j++)
                {
                    if(j!=0)
                        fwrite("\n", 1, 1, fp);
                    for(i=0;i<nWidth;i++)
                    {
                        sprintf(string,"(%08x,%08x,%08x) ",matIn.ptr_Vec3i[j*nWidth+i].data1,matIn.ptr_Vec3i[j*nWidth+i].data2,matIn.ptr_Vec3i[j*nWidth+i].data3);
                        fwrite(string, 1, strlen(string), fp);
                    }
                }
            break;
            case CCV_32FC1:
                sprintf(string,"CV_32FC1\n",NULL);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"nWidth=%d\n",nWidth);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"nHeight=%d\n",nHeight);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"startx=%d\n",matIn.startx);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"starty=%d\n",matIn.starty);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"width=%d\n",matIn.width);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"height=%d\n",matIn.height);
                fwrite(string, 1, strlen(string), fp);
                for(j=0;j<nHeight;j++)
                {
                    if(j!=0)
                        fwrite("\n", 1, 1, fp);
                    for(i=0;i<nWidth;i++)
                    {
                        sprintf(string,"%f ",matIn.ptr_float[j*nWidth+i]);
                        fwrite(string, 1, strlen(string), fp);
                    }
                }
            break;
            case CCV_32FC3:
                sprintf(string,"CV_32FC3\n",NULL);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"nWidth=%d\n",nWidth);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"nHeight=%d\n",nHeight);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"startx=%d\n",matIn.startx);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"starty=%d\n",matIn.starty);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"width=%d\n",matIn.width);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"height=%d\n",matIn.height);
                fwrite(string, 1, strlen(string), fp);
                for(j=0;j<nHeight;j++)
                {
                    if(j!=0)
                        fwrite("\n", 1, 1, fp);
                    for(i=0;i<nWidth;i++)
                    {
                        sprintf(string,"(%f,%f,%f) ",matIn.ptr_Vec3f[j*nWidth+i].data1,matIn.ptr_Vec3f[j*nWidth+i].data2,matIn.ptr_Vec3f[j*nWidth+i].data3);
                        fwrite(string, 1, strlen(string), fp);
                    }
                }
            break;
            case CCV_64FC1:
                sprintf(string,"CV_64FC1\n",NULL);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"nWidth=%d\n",nWidth);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"nHeight=%d\n",nHeight);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"startx=%d\n",matIn.startx);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"starty=%d\n",matIn.starty);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"width=%d\n",matIn.width);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"height=%d\n",matIn.height);
                fwrite(string, 1, strlen(string), fp);
                for(j=0;j<nHeight;j++)
                {
                    if(j!=0)
                        fwrite("\n", 1, 1, fp);
                    for(i=0;i<nWidth;i++)
                    {
                        sprintf(string,"%lf ",matIn.ptr_double[j*nWidth+i]);
                        fwrite(string, 1, strlen(string), fp);
                    }
                }
            break;
            case CCV_64FC3:
                sprintf(string,"CV_64FC3\n",NULL);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"nWidth=%d\n",nWidth);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"nHeight=%d\n",nHeight);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"startx=%d\n",matIn.startx);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"starty=%d\n",matIn.starty);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"width=%d\n",matIn.width);
                fwrite(string, 1, strlen(string), fp);
                sprintf(string,"height=%d\n",matIn.height);
                fwrite(string, 1, strlen(string), fp);
                for(j=0;j<nHeight;j++)
                {
                    if(j!=0)
                        fwrite("\n", 1, 1, fp);
                    for(i=0;i<nWidth;i++)
                    {
                        sprintf(string,"(%lf,%lf,%lf) ",matIn.ptr_Vec3d[j*nWidth+i].data1,matIn.ptr_Vec3d[j*nWidth+i].data2,matIn.ptr_Vec3d[j*nWidth+i].data3);
                        fwrite(string, 1, strlen(string), fp);
                    }
                }
            break;
        }
        fclose(fp);
        return 0;
    }

    Int8 MyMatReadTxt(const char *str,Mat *matIn_Out)
    {
        FILE *fp;
        char string[50];
        Int32 nHeight;
        Int32 nWidth;
        Int32 i,j;
        Int32 len;
        char info[50];
        char data[50];

        if((fp=fopen(str,"rb"))==NULL)
        {
            return 1;
        }
        fseek(fp,0,SEEK_SET);
        fgets(string,50,fp);
        len = strlen(string);
        string[len-1]='\0';

        fgets(info,50,fp);
        len = strlen(info);
        info[len-1] ='\0';

        if(0==memcmp("nWidth=",info,strlen("nWidth=")))//下一组焊缝
        {
            char *s,*e;
            s=strchr(info,'=');
            s=s+1;
            e=strchr(s,'\0');
            memcpy(data,s,e-s);
            data[e-s]='\0';
            matIn_Out->nWidth=atoi(data);
            nWidth=matIn_Out->nWidth;
        }
        else
        {
            return 1;
        }

        fgets(info,50,fp);
        len = strlen(info);
        info[len-1] ='\0';

        if(0==memcmp("nHeight=",info,strlen("nHeight=")))//下一组焊缝
        {
            char *s,*e;
            s=strchr(info,'=');
            s=s+1;
            e=strchr(s,'\0');
            memcpy(data,s,e-s);
            data[e-s]='\0';
            matIn_Out->nHeight=atoi(data);
            nHeight=matIn_Out->nHeight;
        }
        else
        {
            return 1;
        }

        fgets(info,50,fp);
        len = strlen(info);
        info[len-1] ='\0';
        if(0==memcmp("startx=",info,strlen("startx=")))//下一组焊缝
        {
            char *s,*e;
            s=strchr(info,'=');
            s=s+1;
            e=strchr(s,'\0');
            memcpy(data,s,e-s);
            data[e-s]='\0';
            matIn_Out->startx=atoi(data);
        }
        else
        {
            return 1;
        }

        fgets(info,50,fp);
        len = strlen(info);
        info[len-1] ='\0';
        if(0==memcmp("starty=",info,strlen("starty=")))//下一组焊缝
        {
            char *s,*e;
            s=strchr(info,'=');
            s=s+1;
            e=strchr(s,'\0');
            memcpy(data,s,e-s);
            data[e-s]='\0';
            matIn_Out->starty=atoi(data);
        }
        else
        {
            return 1;
        }

        fgets(info,50,fp);
        len = strlen(info);
        info[len-1] ='\0';
        if(0==memcmp("width=",info,strlen("width=")))//下一组焊缝
        {
            char *s,*e;
            s=strchr(info,'=');
            s=s+1;
            e=strchr(s,'\0');
            memcpy(data,s,e-s);
            data[e-s]='\0';
            matIn_Out->width=atoi(data);
        }
        else
        {
            return 1;
        }

        fgets(info,50,fp);
        len = strlen(info);
        info[len-1] ='\0';
        if(0==memcmp("height=",info,strlen("height=")))//下一组焊缝
        {
            char *s,*e;
            s=strchr(info,'=');
            s=s+1;
            e=strchr(s,'\0');
            memcpy(data,s,e-s);
            data[e-s]='\0';
            matIn_Out->height=atoi(data);
        }
        else
        {
            return 1;
        }

        if(0==memcmp("CV_8UC1",string,strlen("CV_8UC1")))
        {
            MyconvertTo(matIn_Out,CCV_8UC1);
            for(j=0;j<nHeight;j++)
            {
                for(i=0;i<nWidth;i++)
                {
                    fscanf(fp,"%s",data);
                    len = strlen(data);
                    data[len] ='\0';
                    sscanf(data,"%x",&matIn_Out->ptr_uchar[j*nWidth+i]);
                }
                fgetc(fp);
            }
        }
        else if(0==memcmp("CV_8SC1",string,strlen("CV_8SC1")))
        {
            MyconvertTo(matIn_Out,CCV_8SC1);
            for(j=0;j<nHeight;j++)
            {
                for(i=0;i<nWidth;i++)
                {
                    fscanf(fp,"%s",data);
                    len = strlen(data);
                    data[len] ='\0';
                    sscanf(data,"%x",&matIn_Out->ptr_char[j*nWidth+i]);
                }
                fgetc(fp);
            }
        }
        else if(0==memcmp("CV_8UC3",string,strlen("CV_8UC3")))
        {
            MyconvertTo(matIn_Out,CCV_8UC3);
            for(j=0;j<nHeight;j++)
            {
                for(i=0;i<nWidth;i++)
                {
                    char *s,*e;
                    fscanf(fp,"%s",info);
                    len = strlen(info);
                    info[len] ='\0';
                    s=strchr(info,'(');
                    s=s+1;
                    e=strchr(s,',');
                    memcpy(data,s,e-s);
                    data[e-s]='\0';
                    sscanf(data,"%x",&matIn_Out->ptr_Vec3b[j*nWidth+i].data1);
                    s=e+1;
                    e=strchr(s,',');
                    memcpy(data,s,e-s);
                    data[e-s]='\0';
                    sscanf(data,"%x",&matIn_Out->ptr_Vec3b[j*nWidth+i].data2);
                    s=e+1;
                    e=strchr(s,')');
                    memcpy(data,s,e-s);
                    data[e-s]='\0';
                    sscanf(data,"%x",&matIn_Out->ptr_Vec3b[j*nWidth+i].data3);
                }
                fgetc(fp);
            }
        }
        else if(0==memcmp("CV_8SC3",string,strlen("CV_8SC3")))
        {
            MyconvertTo(matIn_Out,CCV_8SC3);
            for(j=0;j<nHeight;j++)
            {
                for(i=0;i<nWidth;i++)
                {
                    char *s,*e;
                    fscanf(fp,"%s",info);
                    len = strlen(info);
                    info[len] ='\0';
                    s=strchr(info,'(');
                    s=s+1;
                    e=strchr(s,',');
                    memcpy(data,s,e-s);
                    data[e-s]='\0';
                    sscanf(data,"%x",&matIn_Out->ptr_Vec3b[j*nWidth+i].data1);
                    s=e+1;
                    e=strchr(s,',');
                    memcpy(data,s,e-s);
                    data[e-s]='\0';
                    sscanf(data,"%x",&matIn_Out->ptr_Vec3b[j*nWidth+i].data2);
                    s=e+1;
                    e=strchr(s,')');
                    memcpy(data,s,e-s);
                    data[e-s]='\0';
                    sscanf(data,"%x",&matIn_Out->ptr_Vec3b[j*nWidth+i].data3);
                }
                fgetc(fp);
            }
        }
        else if(0==memcmp("CV_16UC1",string,strlen("CV_16UC1")))
        {
            MyconvertTo(matIn_Out,CCV_16UC1);
            for(j=0;j<nHeight;j++)
            {
                for(i=0;i<nWidth;i++)
                {
                    fscanf(fp,"%s",data);
                    len = strlen(data);
                    data[len] ='\0';
                    sscanf(data,"%x",&matIn_Out->ptr_ushort[j*nWidth+i]);
                }
                fgetc(fp);
            }
        }
        else if(0==memcmp("CV_16SC1",string,strlen("CV_16SC1")))
        {
            MyconvertTo(matIn_Out,CCV_16SC1);
            for(j=0;j<nHeight;j++)
            {
                for(i=0;i<nWidth;i++)
                {
                    fscanf(fp,"%s",data);
                    len = strlen(data);
                    data[len] ='\0';
                    sscanf(data,"%x",&matIn_Out->ptr_short[j*nWidth+i]);
                }
                fgetc(fp);
            }
        }
        else if(0==memcmp("CV_16UC3",string,strlen("CV_16UC3")))
        {
            MyconvertTo(matIn_Out,CCV_16UC3);
            for(j=0;j<nHeight;j++)
            {
                for(i=0;i<nWidth;i++)
                {
                    char *s,*e;
                    fscanf(fp,"%s",info);
                    len = strlen(info);
                    info[len] ='\0';
                    s=strchr(info,'(');
                    s=s+1;
                    e=strchr(s,',');
                    memcpy(data,s,e-s);
                    data[e-s]='\0';
                    sscanf(data,"%x",&matIn_Out->ptr_Vec3s[j*nWidth+i].data1);
                    s=e+1;
                    e=strchr(s,',');
                    memcpy(data,s,e-s);
                    data[e-s]='\0';
                    sscanf(data,"%x",&matIn_Out->ptr_Vec3s[j*nWidth+i].data2);
                    s=e+1;
                    e=strchr(s,')');
                    memcpy(data,s,e-s);
                    data[e-s]='\0';
                    sscanf(data,"%x",&matIn_Out->ptr_Vec3s[j*nWidth+i].data3);
                }
                fgetc(fp);
            }
        }
        else if(0==memcmp("CV_16SC3",string,strlen("CV_16SC3")))
        {
            MyconvertTo(matIn_Out,CCV_16SC3);
            for(j=0;j<nHeight;j++)
            {
                for(i=0;i<nWidth;i++)
                {
                    char *s,*e;
                    fscanf(fp,"%s",info);
                    len = strlen(info);
                    info[len] ='\0';
                    s=strchr(info,'(');
                    s=s+1;
                    e=strchr(s,',');
                    memcpy(data,s,e-s);
                    data[e-s]='\0';
                    sscanf(data,"%x",&matIn_Out->ptr_Vec3w[j*nWidth+i].data1);
                    s=e+1;
                    e=strchr(s,',');
                    memcpy(data,s,e-s);
                    data[e-s]='\0';
                    sscanf(data,"%x",&matIn_Out->ptr_Vec3w[j*nWidth+i].data2);
                    s=e+1;
                    e=strchr(s,')');
                    memcpy(data,s,e-s);
                    data[e-s]='\0';
                    sscanf(data,"%x",&matIn_Out->ptr_Vec3w[j*nWidth+i].data3);
                }
                fgetc(fp);
            }
        }
        else if(0==memcmp("CV_32SC1",string,strlen("CV_32SC1")))
        {
            MyconvertTo(matIn_Out,CCV_32SC1);
            for(j=0;j<nHeight;j++)
            {
                for(i=0;i<nWidth;i++)
                {
                    fscanf(fp,"%s",data);
                    len = strlen(data);
                    data[len] ='\0';
                    sscanf(data,"%x",&matIn_Out->ptr_int[j*nWidth+i]);
                }
                fgetc(fp);
            }
        }
        else if(0==memcmp("CV_32SC3",string,strlen("CV_32SC3")))
        {
            MyconvertTo(matIn_Out,CCV_32SC3);
            for(j=0;j<nHeight;j++)
            {
                for(i=0;i<nWidth;i++)
                {
                    char *s,*e;
                    fscanf(fp,"%s",info);
                    len = strlen(info);
                    info[len] ='\0';
                    s=strchr(info,'(');
                    s=s+1;
                    e=strchr(s,',');
                    memcpy(data,s,e-s);
                    data[e-s]='\0';
                    sscanf(data,"%x",&matIn_Out->ptr_Vec3i[j*nWidth+i].data1);
                    s=e+1;
                    e=strchr(s,',');
                    memcpy(data,s,e-s);
                    data[e-s]='\0';
                    sscanf(data,"%x",&matIn_Out->ptr_Vec3i[j*nWidth+i].data2);
                    s=e+1;
                    e=strchr(s,')');
                    memcpy(data,s,e-s);
                    data[e-s]='\0';
                    sscanf(data,"%x",&matIn_Out->ptr_Vec3i[j*nWidth+i].data3);
                }
                fgetc(fp);
            }
        }
        else if(0==memcmp("CV_32FC1",string,strlen("CV_32FC1")))
        {
            MyconvertTo(matIn_Out,CCV_32FC1);
            for(j=0;j<nHeight;j++)
            {
                for(i=0;i<nWidth;i++)
                {
                    fscanf(fp,"%s",data);
                    len = strlen(data);
                    data[len] ='\0';
                    sscanf(data,"%f",&matIn_Out->ptr_float[j*nWidth+i]);
                }
                fgetc(fp);
            }
        }
        else if(0==memcmp("CV_32FC3",string,strlen("CV_32FC3")))
        {
            MyconvertTo(matIn_Out,CCV_32FC3);
            for(j=0;j<nHeight;j++)
            {
                for(i=0;i<nWidth;i++)
                {
                    char *s,*e;
                    fscanf(fp,"%s",info);
                    len = strlen(info);
                    info[len] ='\0';
                    s=strchr(info,'(');
                    s=s+1;
                    e=strchr(s,',');
                    memcpy(data,s,e-s);
                    data[e-s]='\0';
                    sscanf(data,"%f",&matIn_Out->ptr_Vec3f[j*nWidth+i].data1);
                    s=e+1;
                    e=strchr(s,',');
                    memcpy(data,s,e-s);
                    data[e-s]='\0';
                    sscanf(data,"%f",&matIn_Out->ptr_Vec3f[j*nWidth+i].data2);
                    s=e+1;
                    e=strchr(s,')');
                    memcpy(data,s,e-s);
                    data[e-s]='\0';
                    sscanf(data,"%f",&matIn_Out->ptr_Vec3f[j*nWidth+i].data3);
                }
                fgetc(fp);
            }
        }
        else if(0==memcmp("CV_64FC1",string,strlen("CV_64FC1")))
        {
            MyconvertTo(matIn_Out,CCV_64FC1);
            for(j=0;j<nHeight;j++)
            {
                for(i=0;i<nWidth;i++)
                {
                    fscanf(fp,"%s",data);
                    len = strlen(data);
                    data[len] ='\0';
                    sscanf(data,"%lf",&matIn_Out->ptr_double[j*nWidth+i]);
                }
                fgetc(fp);
            }
        }
        else if(0==memcmp("CV_64FC3",string,strlen("CV_64FC3")))
        {
            MyconvertTo(matIn_Out,CCV_64FC3);
            for(j=0;j<nHeight;j++)
            {
                for(i=0;i<nWidth;i++)
                {
                    char *s,*e;
                    fscanf(fp,"%s",info);
                    len = strlen(info);
                    info[len] ='\0';
                    s=strchr(info,'(');
                    s=s+1;
                    e=strchr(s,',');
                    memcpy(data,s,e-s);
                    data[e-s]='\0';
                    sscanf(data,"%lf",&matIn_Out->ptr_Vec3d[j*nWidth+i].data1);
                    s=e+1;
                    e=strchr(s,',');
                    memcpy(data,s,e-s);
                    data[e-s]='\0';
                    sscanf(data,"%lf",&matIn_Out->ptr_Vec3d[j*nWidth+i].data2);
                    s=e+1;
                    e=strchr(s,')');
                    memcpy(data,s,e-s);
                    data[e-s]='\0';
                    sscanf(data,"%lf",&matIn_Out->ptr_Vec3d[j*nWidth+i].data3);
                }
                fgetc(fp);
            }
        }
        else
        {
            return 0;
        }
        fclose(fp);
        return 0;
    }

    Int8 Myintegral(Mat matIn,Mat *matOut)
    {
        Uint32 nnWidth=matIn.nWidth;
        Uint32 nnHeight=matIn.nHeight;
        Int32 nStartY=matIn.starty;
        Int32 nHeight=matIn.height;
        Int32 nStartX=matIn.startx;
        Int32 nWidth=matIn.width;
        Int32 type=matIn._type;
        Mat mincut=MatCreat(nHeight,nWidth,CCV_8UC1,u8_buffer_x1Temp2);
        Mat minout=MatCreat(nHeight,nWidth,CCV_32SC1,u8_buffer_x1Temp3);
        cv::Mat cvimgIn,cvimgOut;

        MyCutminRoi(matIn,&mincut,MHC_CUTMIN_1,nStartX,nStartY,nWidth,nHeight);
        MyconvertTo(matOut,CCV_32SC1);
        matOut->nHeight=nnHeight;
        matOut->nWidth=nnWidth;
        matOut->startx=nStartX;
        matOut->starty=nStartY;
        matOut->width=nWidth;
        matOut->height=nHeight;
        MatSet1col(matOut,0);
        minout.nHeight=mincut.nHeight;
        minout.nWidth=mincut.nWidth;
        minout.startx=mincut.startx;
        minout.starty=mincut.starty;
        minout.width=mincut.width;
        minout.height=mincut.height;
        MatSet1col(&minout,0);
        switch(type)
        {
            case CCV_8UC1:
            case CCV_8SC1:
                cvimgIn=cv::Mat(mincut.nHeight,mincut.nWidth,CV_8U);
                memcpy(cvimgIn.data,mincut.data,getsizeof(mincut._type)*mincut.nHeight*mincut.nWidth);
                cv::integral(cvimgIn,cvimgOut,CV_32S);
                memcpy(minout.data,cvimgOut.data,cvimgOut.elemSize()*cvimgOut.rows*cvimgOut.cols);
            break;
            case CCV_16UC1:
                cvimgIn=cv::Mat(mincut.nHeight,mincut.nWidth,CV_16U);
                memcpy(cvimgIn.data,mincut.data,getsizeof(mincut._type)*mincut.nHeight*mincut.nWidth);
                cvimgIn.convertTo(cvimgIn,CV_32F);
                cv::integral(cvimgIn,cvimgOut,CV_32S);
                memcpy(minout.data,cvimgOut.data,cvimgOut.elemSize()*cvimgOut.rows*cvimgOut.cols);
            case CCV_16SC1:
                cvimgIn=cv::Mat(mincut.nHeight,mincut.nWidth,CV_16S);
                memcpy(cvimgIn.data,mincut.data,getsizeof(mincut._type)*mincut.nHeight*mincut.nWidth);
                cvimgIn.convertTo(cvimgIn,CV_32F);
                cv::integral(cvimgIn,cvimgOut,CV_32S);
                memcpy(minout.data,cvimgOut.data,cvimgOut.elemSize()*cvimgOut.rows*cvimgOut.cols);
            break;
        }
        MyAddminRoi(*matOut,minout,matOut,nStartX,nStartY);
        return 0;
    }

    Int8 Myintegral_8(Uint8 *pIn,Uint16 width,Uint16 height,Uint32 *pOut)
    {
        cv::Mat cvimgIn,cvimgOut;
        cvimgIn=cv::Mat(height,width,CV_8U);
        memcpy(cvimgIn.data,pIn,sizeof(Uint8)*width*height);
        cv::integral(cvimgIn,cvimgOut,CV_32S);
        memcpy(pOut,cvimgOut.data,cvimgOut.elemSize()*cvimgOut.rows*cvimgOut.cols);
        return 0;
    }

    Int8 Myintegral_16(Uint16 *pIn,Uint16 width,Uint16 height,Uint32 *pOut)
    {
        cv::Mat cvimgIn,cvimgOut;
        cvimgIn=cv::Mat(height,width,CV_16U);
        memcpy(cvimgIn.data,pIn,sizeof(Uint16)*width*height);
        cvimgIn.convertTo(cvimgIn,CV_32F);
        cv::integral(cvimgIn,cvimgOut,CV_32S);
        memcpy(pOut,cvimgOut.data,cvimgOut.elemSize()*cvimgOut.rows*cvimgOut.cols);
        return 0;
    }

    Int8 Myhom_mat2d_translate(Mat matIn,Mat *matOut,Int32 movex,Int32 movey)
    {
        Int32 nWidth=matIn.nWidth;
        Int32 nHeight=matIn.nHeight;
        Int32 i;
        Mat matIntemp;
        getcloneinfo(matIn,matOut);
        if(matIn.data==matOut->data)
        {
            switch(matIn._type)
            {
                case CCV_8UC1:
                case CCV_8UC3:
                break;
                default:
                    return 1;
                break;
            }
            matIntemp=MatCreatClone(matIn,u8_buffer_x3Temp1);
        }
        else
        {
            matIntemp=matIn;
        }
        MatSet1col(matOut,0);
        switch(matIntemp._type)
        {
        case CCV_8UC1:
            for(i=0;i<nHeight;i++)
            {
                Int32 y= i - movey;
                if(y>=0&&y<nHeight)
                {
                    Int32 stx= -movex;
                    Int32 longx;
                    if(stx<0)
                    {
                        longx=nWidth+stx;
                        memcpy(&matOut->ptr_uchar[i*nWidth-stx],&matIntemp.ptr_uchar[y*nWidth],longx);
                    }
                    else
                    {
                        longx=nWidth-stx;
                        memcpy(&matOut->ptr_uchar[i*nWidth],&matIntemp.ptr_uchar[y*nWidth+stx],longx);
                    }
                }
            }
        break;
        case CCV_8UC3:
            for(i=0;i<nHeight;i++)
            {
                Int32 y= i - movey;
                if(y>=0&&y<nHeight)
                {
                    Int32 stx= -movex;
                    Int32 longx;
                    if(stx<0)
                    {
                        longx=nWidth+stx;
                        memcpy(&matOut->ptr_Vec3b[i*nWidth-stx],&matIntemp.ptr_Vec3b[y*nWidth],longx*getsizeof(CCV_8UC3));
                    }
                    else
                    {
                        longx=nWidth-stx;
                        memcpy(&matOut->ptr_Vec3b[i*nWidth],&matIntemp.ptr_Vec3b[y*nWidth+stx],longx*getsizeof(CCV_8UC3));
                    }
                }
            }
        break;
        default:
            return 1;
        break;
        }
        return 0;
    }

    Int8 MyPoint16to32(L_Point pointIn,L_Point32 *pointOut)
    {
        pointOut->x=pointIn.x;
        pointOut->y=pointIn.y;
        return 0;
    }

    Int8 MyPoint32to16(L_Point32 pointIn,L_Point *pointOut)
    {
        pointOut->x=(Uint16)pointIn.x;
        pointOut->y=(Uint16)pointIn.y;
        return 0;
    }

    Int8 Myline16to32(L_line lineIn,L_line32 *lineOut)
    {
        MyPoint16to32(lineIn.st,&lineOut->st);
        MyPoint16to32(lineIn.ed,&lineOut->ed);
        return 0;
    }

    Int8 Myline32to16(L_line32 lineIn,L_line *lineOut)
    {
        MyPoint32to16(lineIn.st,&lineOut->st);
        MyPoint32to16(lineIn.ed,&lineOut->ed);
        return 0;
    }

    Int8 MyLinetoPoint(Uint32 nHeight,Uint32 nWidth,L_Point32 st,L_Point32 ed,linetype connectivity,Int32 thickness,MyConect *ImageConectOut,void *bufferIn)
    {
        Int32 L_Pointnum=0;
        Int32 nTalx=0,nTaly=0;
        Int32 top,bottom,left,right;

        Mat matline=MatCreatzero(nHeight,nWidth,CCV_8UC1,(Uint8*)u8_buffer_x1Temp2);

        ImageConectOut->mianji=0;
        ImageConectOut->AllMarkPointCount=0;
        ImageConectOut->memPoint=(L_Point*)bufferIn;
        ImageConectOut->nHeight=nHeight;
        ImageConectOut->nWidth=nWidth;
        ImageConectOut->startx=0;
        ImageConectOut->starty=0;
        ImageConectOut->height=nHeight;
        ImageConectOut->width=nWidth;
        MyLinePoint(&matline,st,ed,connectivity,thickness,ImageConectOut->memPoint,&L_Pointnum);
        if(L_Pointnum!=0)
        {
            Int32 n;
            ImageConectOut->mianji=L_Pointnum;
            ImageConectOut->AllMarkPointCount=1;
            ImageConectOut->AllMarkPoint[0].point=ImageConectOut->memPoint;
            for(n=0;n<L_Pointnum;n++)
            {
                Int32 x=ImageConectOut->AllMarkPoint[0].point[n].x;
                Int32 y=ImageConectOut->AllMarkPoint[0].point[n].y;
                nTalx=nTalx+x;
                nTaly=nTaly+y;
            }
            top=ImageConectOut->AllMarkPoint[0].point[0].y;
            bottom=ImageConectOut->AllMarkPoint[0].point[L_Pointnum-1].y;
            left=MIN(ImageConectOut->AllMarkPoint[0].point[0].x,ImageConectOut->AllMarkPoint[0].point[L_Pointnum-1].x);
            right=MAX(ImageConectOut->AllMarkPoint[0].point[0].x,ImageConectOut->AllMarkPoint[0].point[L_Pointnum-1].x);
            ImageConectOut->AllMarkPoint[0].left=left;
            ImageConectOut->AllMarkPoint[0].right=right;
            ImageConectOut->AllMarkPoint[0].top=top;
            ImageConectOut->AllMarkPoint[0].bottom=bottom;
            ImageConectOut->AllMarkPoint[0].xTotal=nTalx;
            ImageConectOut->AllMarkPoint[0].yTotal=nTaly;
            ImageConectOut->AllMarkPoint[0].PointArea=L_Pointnum;
            ImageConectOut->AllMarkPoint[0].color=1;
        }
        return 0;
    }

    Int8 MyCircletoPoint(Uint32 nHeight,Uint32 nWidth,L_Point32 center,Int32 radius,circletype connectivity,MyConect *ImageConectOut,void *bufferIn)
    {
        Int32 L_Pointnum=0;
        Int32 nTalx=0,nTaly=0;
        Int32 top,bottom,left,right;
        Int32 templeft=nWidth;
        Int32 tempright=0;

        Mat matcir=MatCreatzero(nHeight,nWidth,CCV_8UC1,(Uint8*)u8_buffer_x1Temp2);

        ImageConectOut->mianji=0;
        ImageConectOut->AllMarkPointCount=0;
        ImageConectOut->memPoint=(L_Point*)bufferIn;
        ImageConectOut->nHeight=nHeight;
        ImageConectOut->nWidth=nWidth;
        ImageConectOut->startx=0;
        ImageConectOut->starty=0;
        ImageConectOut->height=nHeight;
        ImageConectOut->width=nWidth;

        MyCirclePoint(&matcir,center,radius,connectivity,ImageConectOut->memPoint,&L_Pointnum);
        if(L_Pointnum!=0)
        {
            Int32 n;
            ImageConectOut->mianji=L_Pointnum;
            ImageConectOut->AllMarkPointCount=1;
            ImageConectOut->AllMarkPoint[0].point=ImageConectOut->memPoint;
            for(n=0;n<L_Pointnum;n++)
            {
                Int32 x=ImageConectOut->AllMarkPoint[0].point[n].x;
                Int32 y=ImageConectOut->AllMarkPoint[0].point[n].y;
                nTalx=nTalx+x;
                nTaly=nTaly+y;
                if(templeft>x)
                    templeft=x;
                if(tempright<x)
                    tempright=x;
            }
            top=ImageConectOut->AllMarkPoint[0].point[0].y;
            bottom=ImageConectOut->AllMarkPoint[0].point[L_Pointnum-1].y;
            left=templeft;
            right=tempright;
            ImageConectOut->AllMarkPoint[0].left=left;
            ImageConectOut->AllMarkPoint[0].right=right;
            ImageConectOut->AllMarkPoint[0].top=top;
            ImageConectOut->AllMarkPoint[0].bottom=bottom;
            ImageConectOut->AllMarkPoint[0].xTotal=nTalx;
            ImageConectOut->AllMarkPoint[0].yTotal=nTaly;
            ImageConectOut->AllMarkPoint[0].PointArea=L_Pointnum;
            ImageConectOut->AllMarkPoint[0].color=1;
        }
        return 0;
    }

    Int8 MyEllipsetoPoint(Uint32 nHeight,Uint32 nWidth,RotatedRect box,linetype connectivity,Int32 thickness,MyConect *ImageConectOut,void *bufferIn)
    {
        Int32 L_Pointnum=0;
        Int32 nTalx=0,nTaly=0;
        Int32 top,bottom,left,right;
        Int32 templeft=nWidth;
        Int32 tempright=0;

        Mat matcir=MatCreatzero(nHeight,nWidth,CCV_8UC1,(Uint8*)u8_buffer_x1Temp2);

        ImageConectOut->mianji=0;
        ImageConectOut->AllMarkPointCount=0;
        ImageConectOut->memPoint=(L_Point*)bufferIn;
        ImageConectOut->nHeight=nHeight;
        ImageConectOut->nWidth=nWidth;
        ImageConectOut->startx=0;
        ImageConectOut->starty=0;
        ImageConectOut->height=nHeight;
        ImageConectOut->width=nWidth;

        MyEllipsePoint(&matcir,box,connectivity,thickness,ImageConectOut->memPoint,&L_Pointnum);
        if(L_Pointnum!=0)
        {
            Int32 n;
            ImageConectOut->mianji=L_Pointnum;
            ImageConectOut->AllMarkPointCount=1;
            ImageConectOut->AllMarkPoint[0].point=ImageConectOut->memPoint;
            for(n=0;n<L_Pointnum;n++)
            {
                Int32 x=ImageConectOut->AllMarkPoint[0].point[n].x;
                Int32 y=ImageConectOut->AllMarkPoint[0].point[n].y;
                nTalx=nTalx+x;
                nTaly=nTaly+y;
                if(templeft>x)
                    templeft=x;
                if(tempright<x)
                    tempright=x;
            }
            top=ImageConectOut->AllMarkPoint[0].point[0].y;
            bottom=ImageConectOut->AllMarkPoint[0].point[L_Pointnum-1].y;
            left=templeft;
            right=tempright;
            ImageConectOut->AllMarkPoint[0].left=left;
            ImageConectOut->AllMarkPoint[0].right=right;
            ImageConectOut->AllMarkPoint[0].top=top;
            ImageConectOut->AllMarkPoint[0].bottom=bottom;
            ImageConectOut->AllMarkPoint[0].xTotal=nTalx;
            ImageConectOut->AllMarkPoint[0].yTotal=nTaly;
            ImageConectOut->AllMarkPoint[0].PointArea=L_Pointnum;
            ImageConectOut->AllMarkPoint[0].color=1;
        }
        return 0;
    }

    Int8 MyrectangletoPoint(Uint32 nHeight,Uint32 nWidth,Int32 left,Int32 right,Int32 top,Int32 deep,Int32 thickness,MyConect *ImageConectOut,void *bufferIn)
    {
        Int32 nStartY=0;
        Int32 nStartX=0;
        Int32 nnWidth=nWidth;
        Int32 i,j;
        Int32 L_Pointnum=0;
        Int32 n=0;
        Int32 nTalx=0,nTaly=0;

        Mat matcir=MatCreatzero(nHeight,nWidth,CCV_8UC1,(Uint8*)u8_buffer_x1Temp2);

        ImageConectOut->mianji=0;
        ImageConectOut->AllMarkPointCount=0;
        ImageConectOut->memPoint=(L_Point*)bufferIn;
        ImageConectOut->nHeight=nHeight;
        ImageConectOut->nWidth=nWidth;
        ImageConectOut->startx=0;
        ImageConectOut->starty=0;
        ImageConectOut->height=nHeight;
        ImageConectOut->width=nWidth;

        if(left<nStartX)
            left=nStartX;
        if(right>nStartX+nWidth-1)
            right=nStartX+nWidth-1;
        if(top<nStartY)
            top=nStartY;
        if(deep>nStartY+nHeight-1)
            deep=nStartY+nHeight-1;

        if(thickness<0)
        {
            L_Pointnum=(deep-top+1)*(right-left+1);
            ImageConectOut->mianji=L_Pointnum;
            ImageConectOut->AllMarkPointCount=1;
            ImageConectOut->AllMarkPoint[0].point=ImageConectOut->memPoint;
            ImageConectOut->AllMarkPoint[0].left=left;
            ImageConectOut->AllMarkPoint[0].right=right;
            ImageConectOut->AllMarkPoint[0].top=top;
            ImageConectOut->AllMarkPoint[0].bottom=deep;
            ImageConectOut->AllMarkPoint[0].xTotal=(left+right)*(right-left+1)*(deep-top+1)/2;
            ImageConectOut->AllMarkPoint[0].yTotal=(top+deep)*(deep-top+1)*(right-left+1)/2;
            ImageConectOut->AllMarkPoint[0].PointArea=L_Pointnum;
            ImageConectOut->AllMarkPoint[0].color=1;
            for(j=top;j<=deep;j++)
            {
                for(i=left;i<=right;i++)
                {
                    ImageConectOut->AllMarkPoint[0].point[n].x=i;
                    ImageConectOut->AllMarkPoint[0].point[n++].y=j;
                }
            }
        }
        else
        {
            Myrectangle(&matcir,left,right,top,deep,255,thickness);
            ImageConectOut->AllMarkPointCount=1;
            ImageConectOut->AllMarkPoint[0].point=ImageConectOut->memPoint;
            ImageConectOut->AllMarkPoint[0].left=left;
            ImageConectOut->AllMarkPoint[0].right=right;
            ImageConectOut->AllMarkPoint[0].top=top;
            ImageConectOut->AllMarkPoint[0].bottom=deep;
            ImageConectOut->AllMarkPoint[0].color=1;
            for(j=top;j<=deep;j++)
            {
                for(i=left;i<=right;i++)
                {
                    if(matcir.data[j*nnWidth+i]!=0)
                    {
                        ImageConectOut->AllMarkPoint[0].point[n].x=i;
                        ImageConectOut->AllMarkPoint[0].point[n++].y=j;
                        nTalx=nTalx+i;
                        nTaly=nTaly+j;
                    }
                }
            }
            ImageConectOut->mianji=n;
            ImageConectOut->AllMarkPoint[0].PointArea=n;
            ImageConectOut->AllMarkPoint[0].xTotal=nTalx;
            ImageConectOut->AllMarkPoint[0].yTotal=nTaly;
        }

        return 0;
    }

    Int8 MyGetLinefocal(L_line lineIn1,L_line lineIn2,L_Point32 *focal)
    {
        double line1_x1=lineIn1.st.x;
        double line1_y1=lineIn1.st.y;
        double line1_x2=lineIn1.ed.x;
        double line1_y2=lineIn1.ed.y;
        double line2_x1=lineIn2.st.x;
        double line2_y1=lineIn2.st.y;
        double line2_x2=lineIn2.ed.x;
        double line2_y2=lineIn2.ed.y;

        double A1,B1,C1,A2,B2,C2;
        double M;

        A1=line1_y2-line1_y1;
        B1=line1_x1-line1_x2;
        C1=line1_y1*line1_x2-line1_x1*line1_y2;

        A2=line2_y2-line2_y1;
        B2=line2_x1-line2_x2;
        C2=line2_y1*line2_x2-line2_x1*line2_y2;

        if((lineIn1.st.x==lineIn1.ed.x)&&(lineIn1.st.y==lineIn1.ed.y))
        {
            return 1;
        }
        if((lineIn2.st.x==lineIn2.ed.x)&&(lineIn2.st.y==lineIn2.ed.y))
        {
            return 2;
        }

        M=A1*B2-A2*B1;
        if(M==0)
        {
            return 3;
        }
        else
        {
            focal->x=(Int32)((double)(C2*B1-C1*B2)/M+0.5);
            focal->y=(Int32)((double)(C1*A2-C2*A1)/M+0.5);
        }
        return 0;
    }

    Int8 MyGetLinefocal32(L_line32 lineIn1,L_line32 lineIn2,L_Point32 *focal)
    {
        double line1_x1=lineIn1.st.x;
        double line1_y1=lineIn1.st.y;
        double line1_x2=lineIn1.ed.x;
        double line1_y2=lineIn1.ed.y;
        double line2_x1=lineIn2.st.x;
        double line2_y1=lineIn2.st.y;
        double line2_x2=lineIn2.ed.x;
        double line2_y2=lineIn2.ed.y;

        double A1,B1,C1,A2,B2,C2;
        double M;

        A1=line1_y2-line1_y1;
        B1=line1_x1-line1_x2;
        C1=line1_y1*line1_x2-line1_x1*line1_y2;

        A2=line2_y2-line2_y1;
        B2=line2_x1-line2_x2;
        C2=line2_y1*line2_x2-line2_x1*line2_y2;

        if((lineIn1.st.x==lineIn1.ed.x)&&(lineIn1.st.y==lineIn1.ed.y))
        {
            return 1;
        }
        if((lineIn2.st.x==lineIn2.ed.x)&&(lineIn2.st.y==lineIn2.ed.y))
        {
            return 2;
        }

        M=A1*B2-A2*B1;
        if(M==0)
        {
            return 3;
        }
        else
        {
            focal->x=(Int32)((double)(C2*B1-C1*B2)/M+0.5);
            focal->y=(Int32)((double)(C1*A2-C2*A1)/M+0.5);
        }
        return 0;
    }

    Int8 MyGetLineCirclefocal(L_line lineIn,double centerXIn,double centerYIn,double radiusIn,L_Point32 *focal1,L_Point32 *focal2)
    {
        double x1=lineIn.st.x;
        double y1=lineIn.st.y;
        double x2=lineIn.ed.x;
        double y2=lineIn.ed.y;

        double k;
        double b;
        double aX,bX,cX;
        double m=centerXIn;
        double n=centerYIn;
        double r=radiusIn;
        double result;
        double xArr1,xArr2;
        double yArr1,yArr2;

        if(x1!=x2)
        {
            k = (y1 - y2) / (x1 - x2);
            b = (x1 * y2 - x2 * y1) / (x1 - x2);
            aX = 1 + k * k;
            bX = 2 * k * (b - n) - 2 * m;
            cX = m * m + (b - n) * (b - n) - r * r;
            result = pow(bX, 2) - 4*aX*cX;
            if(result>0)
            {
                xArr1=(-bX + sqrt(result))/(2 * aX);
                yArr1 = k * xArr1 + b;
                xArr2=(-bX - sqrt(result))/(2 * aX);
                yArr2 = k * xArr2 + b;
                if(yArr1<yArr2)
                {
                    focal1->x=xArr1;
                    focal1->y=yArr1;
                    focal2->x=xArr2;
                    focal2->y=yArr2;
                }
                else if(yArr1>yArr2)
                {
                    focal2->x=xArr1;
                    focal2->y=yArr1;
                    focal1->x=xArr2;
                    focal1->y=yArr2;
                }
                else
                {
                    if(xArr1<xArr2)
                    {
                        focal1->x=xArr1;
                        focal1->y=yArr1;
                        focal2->x=xArr2;
                        focal2->y=yArr2;
                    }
                    else
                    {
                        focal2->x=xArr1;
                        focal2->y=yArr1;
                        focal1->x=xArr2;
                        focal1->y=yArr2;
                    }
                }
            }
            else if(result==0)
            {
                xArr1=(-bX / (2 * aX));
                yArr1 = k * xArr1 + b;
                focal1->x=xArr1;
                focal1->y=yArr1;
                focal2->x=xArr1;
                focal2->y=yArr1;
            }
            else
            {
                return 1;
            }
        }
        else
        {
            xArr1=-sqrt(r*r-(y1-n)*(y1-n))+m;
            xArr2=sqrt(r*r-(y1-n)*(y1-n))+m;
            focal1->x=xArr1;
            focal1->y=y1;
            focal2->x=xArr2;
            focal2->y=y1;
        }
        return 0;
    }

    Int8 MyGetCirclefocal(double centerXIn1,double centerYIn1,double radiusIn1,double centerXIn2,double centerYIn2,double radiusIn2,L_Point32 *focal1,L_Point32 *focal2)
    {
        double a1=centerXIn1;
        double a2=centerXIn2;
        double b1=centerYIn1;
        double b2=centerYIn2;
        double r1=radiusIn1;
        double r2=radiusIn2;
        double K=-(2*a1-2*a2);
        double B=-(2*b1-2*b2);
        double C=(r1*r1-r2*r2)-(a1*a1-a2*a2+b1*b1-b2*b2);
        double cX=-(r1*r1-C*C/(K*K)-a1*a1+2*a1*C/K-b1*b1);
        double aX=B*B/(K*K)+1;
        double bX=-(2*C*B/(K*K)-2*a1*B/K+2*b1);
        double result = pow(bX, 2) - 4*aX*cX;
        double xArr1,xArr2;
        double yArr1,yArr2;

        if(result>0)
        {
            yArr1=(-bX+sqrt(result))/(2*aX);
            xArr1=(C-B*yArr1)/K;
            yArr2=(-bX-sqrt(result))/(2*aX);
            xArr2=(C-B*yArr2)/K;
            if(xArr1<xArr2)
            {
                focal1->x=xArr1;
                focal1->y=yArr1;
                focal2->x=xArr2;
                focal2->y=yArr2;
            }
            else if(xArr1>xArr2)
            {
                focal2->x=xArr1;
                focal2->y=yArr1;
                focal1->x=xArr2;
                focal1->y=yArr2;
            }
            else
            {
                if(yArr1<yArr2)
                {
                    focal1->x=xArr1;
                    focal1->y=yArr1;
                    focal2->x=xArr2;
                    focal2->y=yArr2;
                }
                else
                {
                    focal2->x=xArr1;
                    focal2->y=yArr1;
                    focal1->x=xArr2;
                    focal1->y=yArr2;
                }
            }
        }
        else if(result==0)
        {
            yArr1=(-bX/(2*aX));
            xArr1=(C-B*yArr1)/K;
            focal1->x=xArr1;
            focal1->y=yArr1;
            focal2->x=xArr1;
            focal2->y=yArr1;
        }
        else
        {
            return 1;
        }

        return 0;
    }

    Int8 MyGetLinefocalBisection(L_Point32 focalInP,L_Point32 focalInA,L_Point32 focalInB,L_Point32F *focalOut)
    {
        L_Point32F lineA,singA;
        L_Point32F lineB,singB;
        L_Point32F lineOut;
        double disA;
        double disB;
        lineA.x=focalInA.x-focalInP.x;
        lineA.y=focalInA.y-focalInP.y;
        disA=sqrt((double)(lineA.x*lineA.x+lineA.y*lineA.y));
        singA.x=lineA.x/disA;
        singA.y=lineA.y/disA;

        lineB.x=focalInB.x-focalInP.x;
        lineB.y=focalInB.y-focalInP.y;
        disB=sqrt((double)(lineB.x*lineB.x+lineB.y*lineB.y));
        singB.x=lineB.x/disB;
        singB.y=lineB.y/disB;

        lineOut.x=singA.x+singB.x;
        lineOut.y=singA.y+singB.y;

        (*focalOut).x=lineOut.x;
        (*focalOut).y=lineOut.y;

        return 0;
    }

    Int8 MyGetLinefocalRight(L_Point32 focalInP,L_Point32 focalInA,L_Point32F *focalOut)
    {
        Vec3d lineA,lineB,lineC;
        double disA;
        lineA.data1=focalInA.x-focalInP.x;
        lineA.data2=focalInA.y-focalInP.y;
        lineA.data3=0;
        if(lineA.data2==0)
        {
            return 1;
        }
        if(lineA.data2<0)
        {
            lineA.data1=-lineA.data1;
            lineA.data2=-lineA.data2;
        }
        disA=sqrt((double)(lineA.data1*lineA.data1+lineA.data2*lineA.data2+lineA.data3*lineA.data3));
        lineA.data1=lineA.data1/disA;
        lineA.data2=lineA.data2/disA;
        lineA.data3=lineA.data3/disA;

        lineB.data1=0;
        lineB.data2=0;
        lineB.data3=disA;

        lineC.data1=lineA.data2*lineB.data3-lineA.data3*lineB.data2;
        lineC.data2=lineA.data3*lineB.data1-lineA.data1*lineB.data3;
        lineC.data3=lineA.data1*lineB.data2-lineA.data2*lineB.data1;

        (*focalOut).x=lineC.data1;
        (*focalOut).y=lineC.data2;

        return 0;
    }

    Int8 MyGetLinefocalLeft(L_Point32 focalInP,L_Point32 focalInA,L_Point32F *focalOut)
    {
        Vec3d lineA,lineB,lineC;
        double disA;
        lineA.data1=focalInA.x-focalInP.x;
        lineA.data2=focalInA.y-focalInP.y;
        lineA.data3=0;
        if(lineA.data2==0)
        {
            return 1;
        }
        if(lineA.data2<0)
        {
            lineA.data1=-lineA.data1;
            lineA.data2=-lineA.data2;
        }
        disA=sqrt((double)(lineA.data1*lineA.data1+lineA.data2*lineA.data2+lineA.data3*lineA.data3));
        lineA.data1=lineA.data1/disA;
        lineA.data2=lineA.data2/disA;
        lineA.data3=lineA.data3/disA;

        lineB.data1=0;
        lineB.data2=0;
        lineB.data3=-disA;

        lineC.data1=lineA.data2*lineB.data3-lineA.data3*lineB.data2;
        lineC.data2=lineA.data3*lineB.data1-lineA.data1*lineB.data3;
        lineC.data3=lineA.data1*lineB.data2-lineA.data2*lineB.data1;

        (*focalOut).x=lineC.data1;
        (*focalOut).y=lineC.data2;

        return 0;
    }


    Int8 MyGetLineXpos(L_line lineIn,Int32 YIn,Int32 *XOut)
    {
        double line_x1=lineIn.st.x;
        double line_y1=lineIn.st.y;
        double line_x2=lineIn.ed.x;
        double line_y2=lineIn.ed.y;

        double A,B,C;

        A=line_y2-line_y1;
        B=line_x1-line_x2;
        C=line_y1*line_x2-line_x1*line_y2;
        if(A==0)
        {
            *XOut=0;
            return 1;
        }
        else
        {
            *XOut=(Int32)((double)(-C-B*YIn)/A+0.5);
        }
        return 0;
    }

    Int8 MyGetLineYpos(L_line lineIn,Int32 XIn,Int32 *YOut)
    {
        double line_x1=lineIn.st.x;
        double line_y1=lineIn.st.y;
        double line_x2=lineIn.ed.x;
        double line_y2=lineIn.ed.y;

        double A,B,C;

        A=line_y2-line_y1;
        B=line_x1-line_x2;
        C=line_y1*line_x2-line_x1*line_y2;
        if(B==0)
        {
            *YOut=0;
            return 1;
        }
        else
        {
            *YOut=(Int32)((double)(-C-A*XIn)/B+0.5);
        }
        return 0;
    }

    Int8 MyGetLine32Xpos(L_line32 lineIn,Int32 YIn,Int32 *XOut)
    {
        double line_x1=lineIn.st.x;
        double line_y1=lineIn.st.y;
        double line_x2=lineIn.ed.x;
        double line_y2=lineIn.ed.y;

        double A,B,C;

        A=line_y2-line_y1;
        B=line_x1-line_x2;
        C=line_y1*line_x2-line_x1*line_y2;
        if(A==0)
        {
            *XOut=0;
            return 1;
        }
        else
        {
            *XOut=(Int32)((double)(-C-B*YIn)/A+0.5);
        }
        return 0;
    }

    Int8 MyGetLine32Ypos(L_line32 lineIn,Int32 XIn,Int32 *YOut)
    {
        double line_x1=lineIn.st.x;
        double line_y1=lineIn.st.y;
        double line_x2=lineIn.ed.x;
        double line_y2=lineIn.ed.y;

        double A,B,C;

        A=line_y2-line_y1;
        B=line_x1-line_x2;
        C=line_y1*line_x2-line_x1*line_y2;
        if(B==0)
        {
            *YOut=0;
            return 1;
        }
        else
        {
            *YOut=(Int32)((double)(-C-A*XIn)/B+0.5);
        }
        return 0;
    }

    Int8 MyGetLine32XD64pos(L_line32 lineIn,Int32 YIn,double *XOut)
    {
        double line_x1=lineIn.st.x;
        double line_y1=lineIn.st.y;
        double line_x2=lineIn.ed.x;
        double line_y2=lineIn.ed.y;

        double A,B,C;

        A=line_y2-line_y1;
        B=line_x1-line_x2;
        C=line_y1*line_x2-line_x1*line_y2;
        if(A==0)
        {
            *XOut=0;
            return 1;
        }
        else
        {
            *XOut=((double)(-C-B*YIn)/A);
        }
        return 0;
    }

    Int8 MyGetLine32YD64pos(L_line32 lineIn,Int32 XIn,double *YOut)
    {
        double line_x1=lineIn.st.x;
        double line_y1=lineIn.st.y;
        double line_x2=lineIn.ed.x;
        double line_y2=lineIn.ed.y;

        double A,B,C;

        A=line_y2-line_y1;
        B=line_x1-line_x2;
        C=line_y1*line_x2-line_x1*line_y2;
        if(B==0)
        {
            *YOut=0;
            return 1;
        }
        else
        {
            *YOut=((double)(-C-A*XIn)/B);
        }
        return 0;
    }

    Int8 Myfixdata(Int32 *dataIn_Out,Uint8 *mask,Int32 num)
    {
        Int32 n,m;
        Int32 nST,nED;
        Int32 *u32_data=(Int32*)u8_buffer_x3Temp1;
        Int32 seed=0;
        Uint8 nTemp=0;
        Int32 addnum;
        Int32 add;
        Int32 t;
        Uint8 have=0;

        memset(u32_data,0,num*sizeof(Int32));
        for(n=0;n<num;n++)
        {
            if(mask[n]==1)
            {
                have=1;
                break;
            }
        }
        if(have==0)
        {
            return 1;
        }
        for(n=0;n<num;n++)
        {
            if(mask[n]==0&&nTemp==0)
            {
                nTemp=1;
                u32_data[seed++]=n;
            }
            else if(mask[n]!=0&&nTemp==1)
            {
                nTemp=0;
                u32_data[seed++]=n;
            }
        }
        if(nTemp==1)
        {
            u32_data[seed++]=num;
        }
        for(n=0;n<seed;n=n+2)
        {
            nST=u32_data[n];
            nED=u32_data[n+1];
            addnum=(nED-nST)+1;
            if(nST==0)
            {
                for(m=nST;m<nED;m++)
                {
                    dataIn_Out[m]=dataIn_Out[nED];
                }
            }
            else if(nED==num)
            {
                for(m=nST;m<nED;m++)
                {
                    dataIn_Out[m]=dataIn_Out[nST-1];
                }
            }
            else
            {
                t=1;
                add=((dataIn_Out[nED]-dataIn_Out[nST-1])<<12)/addnum;
                for(m=nST;m<nED;m++)
                {
                    dataIn_Out[m]=dataIn_Out[nST-1]+((add*t)>>12);
                    t++;
                }
            }
        }
        return 0;
    }

    Int8 Myfixfdata(float *dataIn_Out,Uint8 *mask,Int32 num)
    {
        Int32 n,m;
        Int32 nST,nED;
        Int32 *u32_data=(Int32*)u8_buffer_x3Temp1;
        Int32 seed=0;
        Uint8 nTemp=0;
        Int32 addnum;
        float add;
        Int32 t;
        Uint8 have=0;

        memset(u32_data,0,num*sizeof(Int32));
        for(n=0;n<num;n++)
        {
            if(mask[n]==1)
            {
                have=1;
                break;
            }
        }
        if(have==0)
        {
            return 1;
        }
        for(n=0;n<num;n++)
        {
            if(mask[n]==0&&nTemp==0)
            {
                nTemp=1;
                u32_data[seed++]=n;
            }
            else if(mask[n]!=0&&nTemp==1)
            {
                nTemp=0;
                u32_data[seed++]=n;
            }
        }
        if(nTemp==1)
        {
            u32_data[seed++]=num;
        }
        for(n=0;n<seed;n=n+2)
        {
            nST=u32_data[n];
            nED=u32_data[n+1];
            addnum=(nED-nST)+1;
            if(nST==0)
            {
                for(m=nST;m<nED;m++)
                {
                    dataIn_Out[m]=dataIn_Out[nED];
                }
            }
            else if(nED==num)
            {
                for(m=nST;m<nED;m++)
                {
                    dataIn_Out[m]=dataIn_Out[nST-1];
                }
            }
            else
            {
                t=1;
                add=(dataIn_Out[nED]-dataIn_Out[nST-1])/addnum;
                for(m=nST;m<nED;m++)
                {
                    dataIn_Out[m]=dataIn_Out[nST-1]+((add*t));
                    t++;
                }
            }
        }
        return 0;
    }


    Int8 MychangeI32toF32data(Int32 *dataIn,float *dataOut,Int32 num)
    {
        Int32 head;
        Int32 headi=0;
        Int32 taili=0;
        Int32 i,n;
        Int8 dizeng=-1;

        while(headi<num)
        {
            head=dataIn[headi];
            for(i=headi;i<num;i++)
            {
                if(head!=dataIn[i])
                {
                    taili=i-1;
                    if(head<dataIn[i])
                    {
                        dizeng=1;
                    }
                    else
                    {
                        dizeng=0;
                    }
                    break;
                }
                if(i==num-1)
                {
                    taili=i;
                }
            }
            if(dizeng==1)
            {
                if(taili==headi)
                {      
                    dataOut[headi]=dataIn[headi];
                }
                else
                {
                    float f_st=head-0.5;
                    float f_add=1.0/(taili-headi+1);
                    int t=1;
                    for(n=headi;n<=taili;n++)
                    {
                        dataOut[n]=f_st+f_add*t;
                        t++;
                    }
                }
            }
            else if(dizeng==0)
            {
                if(taili==headi)
                {
                    dataOut[headi]=dataIn[headi];
                }
                else
                {
                    float f_st=head+0.5;
                    float f_add=-1.0/(taili-headi+1);
                    int t=1;
                    for(n=headi;n<=taili;n++)
                    {
                        dataOut[n]=f_st+f_add*t;
                        t++;
                    }
                }
            }
            headi=taili+1;
        }
        if(dizeng==-1)
        {
            for(i=0;i<num;i++)
            {
                dataOut[i]=dataIn[i];
            }
        }

        return 0;
    }

    Int8 Myresizefixdata_4fSize(Int32 *data, Uint8 *mask,float *dataOut,Int num)
    {
        Int32 n;
        cv::Mat bufmask=cv::Mat::zeros(1,num*4,CV_8UC1);
        cv::Mat in_32=cv::Mat::zeros(1,num,CV_32SC1);
        cv::Mat in_f=cv::Mat::zeros(1,num,CV_32FC1);
        float *da_f=(float*)in_f.data;
        memcpy(in_32.data,data,sizeof(Int32)*num); 
        Myfixdata((Int32*)in_32.data,mask,num);
        MychangeI32toF32data((Int32*)in_32.data,(float*)in_f.data,num);
        memset(dataOut,0,sizeof(float)*num*4);
        for(n=0;n<num;n++)
        {
            if(mask[n]!=0)
            {
                bufmask.data[n*4]=1;
                dataOut[n*4]=(da_f[n]*2);
            }
        }
        Myfixfdata(dataOut,bufmask.data,num*4);
        return 0;
    }

    Int8 Myresizefix2bitdata_4fSize(Int32 *data2bit_In,Uint8 *mask,float *dataOut,Int num)
    {
        Int32 n;
        cv::Mat bufmask=cv::Mat::zeros(1,num*4,CV_8UC1);
        cv::Mat in_32=cv::Mat::zeros(1,num,CV_32SC1);
        cv::Mat in_f=cv::Mat::zeros(1,num,CV_32FC1);
        float *da_f=(float*)in_f.data;
        memcpy(in_32.data,data2bit_In,sizeof(Int32)*num);
        Myfixdata((Int32*)in_32.data,mask,num);
        MychangeI32toF32data((Int32*)in_32.data,(float*)in_f.data,num);
        memset(dataOut,0,sizeof(float)*num*4);       
        for(n=0;n<num;n++)
        {
            if(mask[n]!=0)
            {
                bufmask.data[n*4]=1;
                dataOut[n*4]=(da_f[n]*2);
            }
        }
        Myfixfdata(dataOut,bufmask.data,num*4);
        return 0;
    }

    Verb VerbCreat(Int32 num,void *bufferIn)
    {
        Uint32 *buf=(Uint32*)bufferIn;
        Int32 vernum=(num>>5)+1;
        Int32 hinum=vernum%32;
        Uint32 hi=0xffffffff;
        Verb verb;
        if(hinum!=0)
        {
            hi=(0xffffffff>>(32-hinum));
        }
        memset(buf,0,vernum*sizeof(Uint32));
        verb.buf32_data=buf;
        verb.buf32_num=vernum;
        verb.highst_data=hi;
        verb.num=0;
        return verb;
    }

    Ver1i Ver1iCreat(Int32 num,void *bufferIn)
    {
        Ver1i ver1i;
        ver1i.point=(Int32*)bufferIn;
        ver1i.buf32_num=num;
        ver1i.num=0;
        memset(ver1i.point,0,sizeof(Int32)*num);
        return ver1i;
    }

    Ver2i Ver2iCreat(Int32 num,void *bufferIn)
    {
        Ver2i ver2i;
        ver2i.point=(L_Point32*)bufferIn;
        ver2i.buf32_num=num;
        ver2i.num=0;
        memset(ver2i.point,0,sizeof(L_Point32)*num);
        return ver2i;
    }

    Ver3i Ver3iCreat(Int32 num,void *bufferIn)
    {
        Ver3i ver3i;
        ver3i.point=(Vec3i*)bufferIn;
        ver3i.buf32_num=num;
        ver3i.num=0;
        memset(ver3i.point,0,sizeof(Vec3i)*num);
        return ver3i;
    }

    Ver2v Ver2vCreat(Int32 num,void *bufferIn)
    {
        Ver2v ver2v;
        ver2v.point=(Vec2v*)bufferIn;
        ver2v.buf32_num=num;
        ver2v.num=0;
        memset(ver2v.point,0,sizeof(Vec2v)*num);
        return ver2v;
    }

    Ver3v Ver3vCreat(Int32 num,void *bufferIn)
    {
        Ver3v ver3v;
        ver3v.point=(Vec3v*)bufferIn;
        ver3v.buf32_num=num;
        ver3v.num=0;
        memset(ver3v.point,0,sizeof(Vec3v)*num);
        return ver3v;
    }

    Int8 VerbClear(Verb *verIn_Out)
    {
        memset(verIn_Out->buf32_data,0,verIn_Out->buf32_num*sizeof(Uint32));
        verIn_Out->num=0;
        return 0;
    }

    Int8 Ver1iClear(Ver1i *verIn_Out)
    {
        memset(verIn_Out->point,0,verIn_Out->buf32_num*sizeof(Int32));
        verIn_Out->num=0;
        return 0;
    }

    Int8 Ver2iClear(Ver2i *verIn_Out)
    {
        memset(verIn_Out->point,0,verIn_Out->buf32_num*sizeof(L_Point32));
        verIn_Out->num=0;
        return 0;
    }

    Int8 Ver3iClear(Ver3i *verIn_Out)
    {
        memset(verIn_Out->point,0,verIn_Out->buf32_num*sizeof(Vec3i));
        verIn_Out->num=0;
        return 0;
    }

    Int8 Ver2vClear(Ver2v *verIn_Out)
    {
        memset(verIn_Out->point,0,verIn_Out->buf32_num*sizeof(Vec2v));
        verIn_Out->num=0;
        return 0;
    }

    Int8 Ver3vClear(Ver3v *verIn_Out)
    {
        memset(verIn_Out->point,0,verIn_Out->buf32_num*sizeof(Vec3v));
        verIn_Out->num=0;
        return 0;
    }

    Int8 VerbPush(Verb *verIn_Out,Bool value)
    {
        Int32 n;
        if(verIn_Out->buf32_num<=1)
        {
            verIn_Out->buf32_data[0]=((verIn_Out->buf32_data[0]<<1)&(verIn_Out->highst_data));
            if(value!=FALSE)
            {
                verIn_Out->buf32_data[0]=(verIn_Out->buf32_data[0]|1);
            }
        }
        else
        {
            verIn_Out->buf32_data[0]=(verIn_Out->buf32_data[0]<<1);
            verIn_Out->buf32_data[0]=(((verIn_Out->buf32_data[1]>>0x1f)|verIn_Out->buf32_data[0])&(verIn_Out->highst_data));
            for(n=1;n<verIn_Out->buf32_num-1;n++)
            {
                verIn_Out->buf32_data[n]=(verIn_Out->buf32_data[n]<<1);
                verIn_Out->buf32_data[n]=((verIn_Out->buf32_data[n+1]>>0x1f)|(verIn_Out->buf32_data[n]));
            }
            verIn_Out->buf32_data[verIn_Out->buf32_num-1]=(verIn_Out->buf32_data[verIn_Out->buf32_num-1]<<1);
            if(value!=FALSE)
            {
                verIn_Out->buf32_data[verIn_Out->buf32_num-1]=(verIn_Out->buf32_data[verIn_Out->buf32_num-1]|1);
            }
        }
        if(verIn_Out->num<verIn_Out->buf32_num)
        {
            verIn_Out->num=verIn_Out->num+1;
        }
        return 0;
    }

    Int8 VerbGetTRUEnum(Verb verIn,Int32 *valout)
    {
        Int32 n;
        *valout=0;
        for(n=0;n<verIn.buf32_num;n++)
        {
            *valout=*valout+get_1_num_in_bin(verIn.buf32_data[n]);
        }
        return 0;
    }

    Int8 VerbGetFALSEnum(Verb verIn,Int32 *valout)
    {
        Int32 n;
        *valout=0;
        for(n=0;n<verIn.buf32_num;n++)
        {
            *valout=*valout+get_1_num_in_bin(verIn.buf32_data[n]);
        }
        *valout=verIn.num-*valout;
        return 0;
    }

    Int8 Ver1iPush(Ver1i *verIn_Out,Int32 point)
    {
        if(verIn_Out->buf32_num>1)
        {
            if(verIn_Out->num==verIn_Out->buf32_num)
            {
                memmove(verIn_Out->point,&verIn_Out->point[1],(verIn_Out->num-1)*sizeof(Int32));
                verIn_Out->point[verIn_Out->num-1]=point;
            }
            else
            {
                verIn_Out->point[verIn_Out->num]=point;
            }
        }
        else
        {
            verIn_Out->point[0]=point;
        }
        if(verIn_Out->num<verIn_Out->buf32_num)
        {
            verIn_Out->num=verIn_Out->num+1;
        }
        return 0;
    }

    Int8 Ver2iPush(Ver2i *verIn_Out,L_Point32 point)
    {
        if(verIn_Out->buf32_num>1)
        {
            if(verIn_Out->num==verIn_Out->buf32_num)
            {
                memmove(verIn_Out->point,&verIn_Out->point[1],(verIn_Out->num-1)*sizeof(L_Point32));
                memcpy(&verIn_Out->point[verIn_Out->num-1],&point,sizeof(L_Point32));
            }
            else
            {
                memcpy(&verIn_Out->point[verIn_Out->num],&point,sizeof(L_Point32));
            }
        }
        else
        {
            memcpy(verIn_Out->point,&point,sizeof(L_Point32));
        }
        if(verIn_Out->num<verIn_Out->buf32_num)
        {
            verIn_Out->num=verIn_Out->num+1;
        }
        return 0;
    }

    Int8 Ver3iPush(Ver3i *verIn_Out,Vec3i point)
    {
        if(verIn_Out->buf32_num>1)
        {
            if(verIn_Out->num==verIn_Out->buf32_num)
            {
                memmove(verIn_Out->point,&verIn_Out->point[1],(verIn_Out->num-1)*sizeof(Vec3i));
                memcpy(&verIn_Out->point[verIn_Out->num-1],&point,sizeof(Vec3i));
            }
            else
            {
                memcpy(&verIn_Out->point[verIn_Out->num],&point,sizeof(Vec3i));
            }
        }
        else
        {
            memcpy(verIn_Out->point,&point,sizeof(Vec3i));
        }
        if(verIn_Out->num<verIn_Out->buf32_num)
        {
            verIn_Out->num=verIn_Out->num+1;
        }
        return 0;
    }

    Int8 Ver2vPush(Ver2v *verIn_Out,Vec2v point)
    {
        if(verIn_Out->buf32_num>1)
        {
            if(verIn_Out->num==verIn_Out->buf32_num)
            {
                memmove(verIn_Out->point,&verIn_Out->point[1],(verIn_Out->num-1)*sizeof(Vec2v));
                memcpy(&verIn_Out->point[verIn_Out->num-1],&point,sizeof(Vec2v));
            }
            else
            {
                memcpy(&verIn_Out->point[verIn_Out->num],&point,sizeof(Vec2v));
            }
        }
        else
        {
            memcpy(verIn_Out->point,&point,sizeof(Vec2v));
        }
        if(verIn_Out->num<verIn_Out->buf32_num)
        {
            verIn_Out->num=verIn_Out->num+1;
        }
        return 0;
    }

    Int8 Ver3vPush(Ver3v *verIn_Out,Vec3v point)
    {
        if(verIn_Out->buf32_num>1)
        {
            if(verIn_Out->num==verIn_Out->buf32_num)
            {
                memmove(verIn_Out->point,&verIn_Out->point[1],(verIn_Out->num-1)*sizeof(Vec3v));
                memcpy(&verIn_Out->point[verIn_Out->num-1],&point,sizeof(Vec3v));
            }
            else
            {
                memcpy(&verIn_Out->point[verIn_Out->num],&point,sizeof(Vec3v));
            }
        }
        else
        {
            memcpy(verIn_Out->point,&point,sizeof(Vec3v));
        }
        if(verIn_Out->num<verIn_Out->buf32_num)
        {
            verIn_Out->num=verIn_Out->num+1;
        }
        return 0;
    }

    Peak_Trough MyCreat_peaktrough(Int32 num,void *bufferIn1,void *bufferIn2)
    {
        Peak_Trough peak;
        peak.valuenum=num;
        peak.value=(Int32*)bufferIn1;
        peak.valpeaktrough=(Int8*)bufferIn2;
        return peak;
    }

    Peak_Trough32FC MyCreat_peaktrough32FC(Int32 num,void *bufferIn1,void *bufferIn2)
    {
        Peak_Trough32FC peak;
        peak.valuenum=num;
        peak.value=(float*)bufferIn1;
        peak.valpeaktrough=(Int8*)bufferIn2;
        return peak;
    }

    Peak_Trough MyCreat_zeropeaktrough(Int32 num,void *bufferIn1,void *bufferIn2)
    {
        Peak_Trough peak;
        peak.valuenum=num;
        peak.value=(Int32*)bufferIn1;
        peak.valpeaktrough=(Int8*)bufferIn2;
        memset(peak.value,0,sizeof(Int32)*num);
        memset(peak.valpeaktrough,0,sizeof(Int8)*num);
        return peak;
    }

    Peak_Trough32FC MyCreat_zeropeaktrough32FC(Int32 num,void *bufferIn1,void *bufferIn2)
    {
        Peak_Trough32FC peak;
        peak.valuenum=num;
        peak.value=(float*)bufferIn1;
        peak.valpeaktrough=(Int8*)bufferIn2;
        memset(peak.value,0,sizeof(float)*num);
        memset(peak.valpeaktrough,0,sizeof(Int8)*num);
        return peak;
    }

    Peak_Trough Find_Peak_Trough(Int32 *value,Int32 valuenum,Bool circleMod,void *bufferIn1,void *bufferIn2)
    {
        peaktrough_info *valueinfo=u8_peaktrough_info;
        peaktrough_Que *Val=u8_peaktrough_Que;
        Uint8 *nTemp=u8_peaktrough_temp_1;
        Peak_Trough peaktrough;
        Int32 Areacount=0;
        Int32 left,right;
        Int32 left_diff,right_diff;
        Int32 nHead=0;
        Int32 numliantong=0;
        Int32 n,z,t;
        Int32 valzhongzi,valzhongziN,tempK,K;

        peaktrough.valuenum=valuenum;
        peaktrough.value=(Int32*)bufferIn1;
        peaktrough.valpeaktrough=(Int8*)bufferIn2;

        memcpy(peaktrough.value,value,sizeof(Int32)*valuenum);
        memset(peaktrough.valpeaktrough,0,sizeof(Int8)*valuenum);
        memset(nTemp,0,sizeof(Uint8)*valuenum);

        if(circleMod!=FALSE)
        {
            for(n=0;n<valuenum;n++)
            {
                Int32 valueliantong;
                if(nTemp[n]==0)
                {
                    Val[nHead].value=value[n];//��ջ
                    Val[nHead].n=n;
                    nTemp[n]=1;
                    nHead++;
                }
                Areacount=0;
                if(nHead!=0)
                {
                    left=Val[nHead-1].n;
                    right=Val[nHead-1].n;
                    valueliantong=Val[nHead-1].value;
                    left_diff=0;
                    right_diff=0;
                }
                while(nHead!=0)
                {
                    nHead--;
                    valzhongzi=Val[nHead].value;
                    valzhongziN=Val[nHead].n;
                    Areacount++;
                    tempK=valzhongziN-1;
                    if(tempK<0)
                    {
                        K=tempK+valuenum;
                    }
                    else
                    {
                        K=tempK;
                    }
                    if(value[K]==valzhongzi&&nTemp[K]==0)
                    {
                        Val[nHead].value=value[K];//��ջ
                        Val[nHead].n=K;
                        nTemp[K]=1;
                        nHead++;
                        left=K;
                    }
                    if(value[K]>valzhongzi)//�����ֵ����
                    {
                        left_diff=-1;
                    }
                    else if(value[K]<valzhongzi)//�ұ���ֵ����
                    {
                        left_diff=1;
                    }
                    tempK=valzhongziN+1;
                    if(tempK>=valuenum)
                    {
                        K=tempK-valuenum;
                    }
                    else
                    {
                        K=tempK;
                    }
                    if(value[K]==valzhongzi&&nTemp[K]==0)
                    {
                        Val[nHead].value=value[K];//��ջ
                        Val[nHead].n=K;
                        nTemp[K]=1;
                        nHead++;
                        right=K;
                    }
                    if(value[K]>valzhongzi)//�ұ���ֵ����
                    {
                        right_diff=1;
                    }
                    else if(value[K]<valzhongzi)//�����ֵ����
                    {
                        right_diff=-1;
                    }
                }
                if(Areacount!=0)
                {
                    valueinfo[numliantong].Left_xiabiao=left;
                    valueinfo[numliantong].Right_xiabiao=right;
                    valueinfo[numliantong].value=valueliantong;
                    valueinfo[numliantong].Left_diff=left_diff;
                    valueinfo[numliantong].Right_diff=right_diff;
                    numliantong++;
                }
            }
            for(z=0;z<numliantong;z++)
            {
                if(valueinfo[z].Left_diff==-1&&valueinfo[z].Right_diff==1)//����
                {
                    Int32 start=valueinfo[z].Left_xiabiao;
                    Int32 end=valueinfo[z].Right_xiabiao;
                    if(end<start)
                    {
                        end=end+valuenum;
                    }
                    for(t=start;t<=end;t++)
                    {
                        Int32 m;
                        if(t>=valuenum)
                        {
                            m=t-valuenum;
                        }
                        else
                        {
                            m=t;
                        }
                        peaktrough.valpeaktrough[m]=-1;
                    }
                }
                if(valueinfo[z].Left_diff==1&&valueinfo[z].Right_diff==-1)//����
                {
                    Int32 start=valueinfo[z].Left_xiabiao;
                    Int32 end=valueinfo[z].Right_xiabiao;
                    if(end<start)
                    {
                        end=end+valuenum;
                    }
                    for(t=start;t<=end;t++)
                    {
                        Int32 m;
                        if(t>=valuenum)
                        {
                            m=t-valuenum;
                        }
                        else
                        {
                            m=t;
                        }
                        peaktrough.valpeaktrough[m]=1;
                    }
                }
                if(valueinfo[z].Left_diff==1&&valueinfo[z].Right_diff==1)//������
                {
                    Int32 start=valueinfo[z].Left_xiabiao;
                    Int32 end=valueinfo[z].Right_xiabiao;
                    if(end<start)
                    {
                        end=end+valuenum;
                    }
                    for(t=start;t<=end;t++)
                    {
                        Int32 m;
                        if(t>=valuenum)
                        {
                            m=t-valuenum;
                        }
                        else
                        {
                            m=t;
                        }
                        peaktrough.valpeaktrough[m]=2;
                    }
                }
                if(valueinfo[z].Left_diff==-1&&valueinfo[z].Right_diff==-1)//�½���
                {
                    Int32 start=valueinfo[z].Left_xiabiao;
                    Int32 end=valueinfo[z].Right_xiabiao;
                    if(end<start)
                    {
                        end=end+valuenum;
                    }
                    for(t=start;t<=end;t++)
                    {
                        Int32 m;
                        if(t>=valuenum)
                        {
                            m=t-valuenum;
                        }
                        else
                        {
                            m=t;
                        }
                        peaktrough.valpeaktrough[m]=-2;
                    }
                }
            }
        }
        else
        {
            for(n=0;n<valuenum;n++)
            {
                Int32 valueliantong;
                if(nTemp[n]==0)
                {
                    Val[nHead].value=value[n];//��ջ
                    Val[nHead].n=n;
                    nTemp[n]=1;
                    nHead++;
                }
                Areacount=0;
                if(nHead!=0)
                {
                    left=Val[nHead-1].n;
                    right=Val[nHead-1].n;
                    valueliantong=Val[nHead-1].value;
                    left_diff=0;
                    right_diff=0;
                }
                while(nHead!=0)
                {
                    nHead--;
                    valzhongzi=Val[nHead].value;
                    valzhongziN=Val[nHead].n;
                    Areacount++;
                    tempK=valzhongziN-1;
                    if(tempK<0)
                    {
                        K=0;
                    }
                    else
                    {
                        K=tempK;
                    }
                    if(value[K]==valzhongzi&&nTemp[K]==0)
                    {
                        Val[nHead].value=value[K];//��ջ
                        Val[nHead].n=K;
                        nTemp[K]=1;
                        nHead++;
                        left=K;
                    }
                    if(value[K]>valzhongzi)//�����ֵ����
                    {
                        left_diff=-1;
                    }
                    else if(value[K]<valzhongzi)//�����ֵ���?
                    {
                        left_diff=1;
                    }
                    tempK=valzhongziN+1;
                    if(tempK>=valuenum)
                    {
                        K=valuenum;
                    }
                    else
                    {
                        K=tempK;
                    }
                    if(value[K]==valzhongzi&&nTemp[K]==0)
                    {
                        Val[nHead].value=value[K];//��ջ
                        Val[nHead].n=K;
                        nTemp[K]=1;
                        nHead++;
                        right=K;
                    }
                    if(value[K]>valzhongzi)//�ұ���ֵ����
                    {
                        right_diff=1;
                    }
                    else if(value[K]<valzhongzi)//�����ֵ����
                    {
                        right_diff=-1;
                    }
                }
                if(Areacount!=0)
                {
                    valueinfo[numliantong].Left_xiabiao=left;
                    valueinfo[numliantong].Right_xiabiao=right;
                    valueinfo[numliantong].value=valueliantong;
                    valueinfo[numliantong].Left_diff=left_diff;
                    valueinfo[numliantong].Right_diff=right_diff;
                    numliantong++;
                }
            }
            for(z=0;z<numliantong;z++)
            {
                if(valueinfo[z].Left_diff==-1&&valueinfo[z].Right_diff==1)//����
                {
                    Int32 start=valueinfo[z].Left_xiabiao;
                    Int32 end=valueinfo[z].Right_xiabiao;
                    for(t=start;t<=end;t++)
                    {
                        peaktrough.valpeaktrough[t]=-1;
                    }
                }
                if(valueinfo[z].Left_diff==1&&valueinfo[z].Right_diff==-1)//����
                {
                    Int32 start=valueinfo[z].Left_xiabiao;
                    Int32 end=valueinfo[z].Right_xiabiao;
                    for(t=start;t<=end;t++)
                    {
                        peaktrough.valpeaktrough[t]=1;
                    }
                }
                if(valueinfo[z].Left_diff==1&&valueinfo[z].Right_diff==1)//������
                {
                    Int32 start=valueinfo[z].Left_xiabiao;
                    Int32 end=valueinfo[z].Right_xiabiao;
                    for(t=start;t<=end;t++)
                    {
                        peaktrough.valpeaktrough[t]=2;
                    }
                }
                if(valueinfo[z].Left_diff==-1&&valueinfo[z].Right_diff==-1)//�½���
                {
                    Int32 start=valueinfo[z].Left_xiabiao;
                    Int32 end=valueinfo[z].Right_xiabiao;
                    for(t=start;t<=end;t++)
                    {
                        peaktrough.valpeaktrough[t]=-2;
                    }
                }
            }
        }
        return peaktrough;
    }

    Peak_Trough32FC Find_Peak_Trough32FC(float *value,Int32 valuenum,Bool circleMod,void *bufferIn1,void *bufferIn2)
    {
        peaktrough_info *valueinfo=u8_peaktrough_info;
        peaktrough_Que32FC *Val=u8_peaktrough_Que32FC;
        Uint8 *nTemp=u8_peaktrough_temp_1;
        Peak_Trough32FC peaktrough;
        Int32 Areacount=0;
        Int32 left,right;
        Int32 left_diff,right_diff;
        Int32 nHead=0;
        Int32 numliantong=0;
        Int32 n,z,t;
        Int32 valzhongziN,tempK,K;
        float valzhongzi;

        peaktrough.valuenum=valuenum;
        peaktrough.value=(float*)bufferIn1;
        peaktrough.valpeaktrough=(Int8*)bufferIn2;

        memcpy(peaktrough.value,value,sizeof(float)*valuenum);
        memset(peaktrough.valpeaktrough,0,sizeof(Int8)*valuenum);
        memset(nTemp,0,sizeof(Uint8)*valuenum);

        if(circleMod!=FALSE)
        {
            for(n=0;n<valuenum;n++)
            {
                float valueliantong;
                if(nTemp[n]==0)
                {
                    Val[nHead].value=value[n];//��ջ
                    Val[nHead].n=n;
                    nTemp[n]=1;
                    nHead++;
                }
                Areacount=0;
                if(nHead!=0)
                {
                    left=Val[nHead-1].n;
                    right=Val[nHead-1].n;
                    valueliantong=Val[nHead-1].value;
                    left_diff=0;
                    right_diff=0;
                }
                while(nHead!=0)
                {
                    nHead--;
                    valzhongzi=Val[nHead].value;
                    valzhongziN=Val[nHead].n;
                    Areacount++;
                    tempK=valzhongziN-1;
                    if(tempK<0)
                    {
                        K=tempK+valuenum;
                    }
                    else
                    {
                        K=tempK;
                    }
                    if(value[K]==valzhongzi&&nTemp[K]==0)
                    {
                        Val[nHead].value=value[K];//��ջ
                        Val[nHead].n=K;
                        nTemp[K]=1;
                        nHead++;
                        left=K;
                    }
                    if(value[K]>valzhongzi)//�����ֵ����
                    {
                        left_diff=-1;
                    }
                    else if(value[K]<valzhongzi)//�ұ���ֵ����
                    {
                        left_diff=1;
                    }
                    tempK=valzhongziN+1;
                    if(tempK>=valuenum)
                    {
                        K=tempK-valuenum;
                    }
                    else
                    {
                        K=tempK;
                    }
                    if(value[K]==valzhongzi&&nTemp[K]==0)
                    {
                        Val[nHead].value=value[K];//��ջ
                        Val[nHead].n=K;
                        nTemp[K]=1;
                        nHead++;
                        right=K;
                    }
                    if(value[K]>valzhongzi)//�ұ���ֵ����
                    {
                        right_diff=1;
                    }
                    else if(value[K]<valzhongzi)//�����ֵ����
                    {
                        right_diff=-1;
                    }
                }
                if(Areacount!=0)
                {
                    valueinfo[numliantong].Left_xiabiao=left;
                    valueinfo[numliantong].Right_xiabiao=right;
                    valueinfo[numliantong].value=valueliantong;
                    valueinfo[numliantong].Left_diff=left_diff;
                    valueinfo[numliantong].Right_diff=right_diff;
                    numliantong++;
                }
            }
            for(z=0;z<numliantong;z++)
            {
                if(valueinfo[z].Left_diff==-1&&valueinfo[z].Right_diff==1)//����
                {
                    Int32 start=valueinfo[z].Left_xiabiao;
                    Int32 end=valueinfo[z].Right_xiabiao;
                    if(end<start)
                    {
                        end=end+valuenum;
                    }
                    for(t=start;t<=end;t++)
                    {
                        Int32 m;
                        if(t>=valuenum)
                        {
                            m=t-valuenum;
                        }
                        else
                        {
                            m=t;
                        }
                        peaktrough.valpeaktrough[m]=-1;
                    }
                }
                if(valueinfo[z].Left_diff==1&&valueinfo[z].Right_diff==-1)//����
                {
                    Int32 start=valueinfo[z].Left_xiabiao;
                    Int32 end=valueinfo[z].Right_xiabiao;
                    if(end<start)
                    {
                        end=end+valuenum;
                    }
                    for(t=start;t<=end;t++)
                    {
                        Int32 m;
                        if(t>=valuenum)
                        {
                            m=t-valuenum;
                        }
                        else
                        {
                            m=t;
                        }
                        peaktrough.valpeaktrough[m]=1;
                    }
                }
                if(valueinfo[z].Left_diff==1&&valueinfo[z].Right_diff==1)//������
                {
                    Int32 start=valueinfo[z].Left_xiabiao;
                    Int32 end=valueinfo[z].Right_xiabiao;
                    if(end<start)
                    {
                        end=end+valuenum;
                    }
                    for(t=start;t<=end;t++)
                    {
                        Int32 m;
                        if(t>=valuenum)
                        {
                            m=t-valuenum;
                        }
                        else
                        {
                            m=t;
                        }
                        peaktrough.valpeaktrough[m]=2;
                    }
                }
                if(valueinfo[z].Left_diff==-1&&valueinfo[z].Right_diff==-1)//�½���
                {
                    Int32 start=valueinfo[z].Left_xiabiao;
                    Int32 end=valueinfo[z].Right_xiabiao;
                    if(end<start)
                    {
                        end=end+valuenum;
                    }
                    for(t=start;t<=end;t++)
                    {
                        Int32 m;
                        if(t>=valuenum)
                        {
                            m=t-valuenum;
                        }
                        else
                        {
                            m=t;
                        }
                        peaktrough.valpeaktrough[m]=-2;
                    }
                }
            }
        }
        else
        {
            for(n=0;n<valuenum;n++)
            {
                Int32 valueliantong;
                if(nTemp[n]==0)
                {
                    Val[nHead].value=value[n];//��ջ
                    Val[nHead].n=n;
                    nTemp[n]=1;
                    nHead++;
                }
                Areacount=0;
                if(nHead!=0)
                {
                    left=Val[nHead-1].n;
                    right=Val[nHead-1].n;
                    valueliantong=Val[nHead-1].value;
                    left_diff=0;
                    right_diff=0;
                }
                while(nHead!=0)
                {
                    nHead--;
                    valzhongzi=Val[nHead].value;
                    valzhongziN=Val[nHead].n;
                    Areacount++;
                    tempK=valzhongziN-1;
                    if(tempK<0)
                    {
                        K=0;
                    }
                    else
                    {
                        K=tempK;
                    }
                    if(value[K]==valzhongzi&&nTemp[K]==0)
                    {
                        Val[nHead].value=value[K];//��ջ
                        Val[nHead].n=K;
                        nTemp[K]=1;
                        nHead++;
                        left=K;
                    }
                    if(value[K]>valzhongzi)//�����ֵ����
                    {
                        left_diff=-1;
                    }
                    else if(value[K]<valzhongzi)//�ұ���ֵ����
                    {
                        left_diff=1;
                    }
                    tempK=valzhongziN+1;
                    if(tempK>=valuenum)
                    {
                        K=valuenum;
                    }
                    else
                    {
                        K=tempK;
                    }
                    if(value[K]==valzhongzi&&nTemp[K]==0)
                    {
                        Val[nHead].value=value[K];//��ջ
                        Val[nHead].n=K;
                        nTemp[K]=1;
                        nHead++;
                        right=K;
                    }
                    if(value[K]>valzhongzi)//�ұ���ֵ����
                    {
                        right_diff=1;
                    }
                    else if(value[K]<valzhongzi)//�����ֵ����
                    {
                        right_diff=-1;
                    }
                }
                if(Areacount!=0)
                {
                    valueinfo[numliantong].Left_xiabiao=left;
                    valueinfo[numliantong].Right_xiabiao=right;
                    valueinfo[numliantong].value=valueliantong;
                    valueinfo[numliantong].Left_diff=left_diff;
                    valueinfo[numliantong].Right_diff=right_diff;
                    numliantong++;
                }
            }
            for(z=0;z<numliantong;z++)
            {
                if(valueinfo[z].Left_diff==-1&&valueinfo[z].Right_diff==1)//����
                {
                    Int32 start=valueinfo[z].Left_xiabiao;
                    Int32 end=valueinfo[z].Right_xiabiao;
                    for(t=start;t<=end;t++)
                    {
                        peaktrough.valpeaktrough[t]=-1;
                    }
                }
                if(valueinfo[z].Left_diff==1&&valueinfo[z].Right_diff==-1)//����
                {
                    Int32 start=valueinfo[z].Left_xiabiao;
                    Int32 end=valueinfo[z].Right_xiabiao;
                    for(t=start;t<=end;t++)
                    {
                        peaktrough.valpeaktrough[t]=1;
                    }
                }
                if(valueinfo[z].Left_diff==1&&valueinfo[z].Right_diff==1)//������
                {
                    Int32 start=valueinfo[z].Left_xiabiao;
                    Int32 end=valueinfo[z].Right_xiabiao;
                    for(t=start;t<=end;t++)
                    {
                        peaktrough.valpeaktrough[t]=2;
                    }
                }
                if(valueinfo[z].Left_diff==-1&&valueinfo[z].Right_diff==-1)//�½���
                {
                    Int32 start=valueinfo[z].Left_xiabiao;
                    Int32 end=valueinfo[z].Right_xiabiao;
                    for(t=start;t<=end;t++)
                    {
                        peaktrough.valpeaktrough[t]=-2;
                    }
                }
            }
        }
        return peaktrough;
    }

    Int8 MyCopy_peaktrough(Peak_Trough *peaktroughIn,Peak_Trough *peaktroughOut)
    {
        peaktroughOut->valuenum=peaktroughIn->valuenum;
        memcpy(peaktroughOut->value,peaktroughIn->value,peaktroughIn->valuenum*sizeof(Int32));
        memcpy(peaktroughOut->valpeaktrough,peaktroughIn->valpeaktrough,peaktroughIn->valuenum*sizeof(Int8));
        return 0;
    }

    Int8 MyCopy_peaktrough32FC(Peak_Trough32FC *peaktroughIn,Peak_Trough32FC *peaktroughOut)
    {
        peaktroughOut->valuenum=peaktroughIn->valuenum;
        memcpy(peaktroughOut->value,peaktroughIn->value,peaktroughIn->valuenum*sizeof(float));
        memcpy(peaktroughOut->valpeaktrough,peaktroughIn->valpeaktrough,peaktroughIn->valuenum*sizeof(Int8));
        return 0;
    }

    Int8 Myintersection_peaktroughside(Peak_Trough *peaktroughIn1,Peak_Trough *peaktroughIn2,Peak_Trough *peaktroughOut)
    {
        Int32 valuenum=peaktroughIn1->valuenum;
        Int32 t;

        if(peaktroughIn1->valuenum!=peaktroughIn2->valuenum)
            return 1;

        peaktroughOut->valuenum=valuenum;
        memcpy(peaktroughOut->value,peaktroughIn1->value,valuenum*sizeof(Int32));
        for(t=0;t<valuenum;t++)
        {
            if(peaktroughIn1->valpeaktrough[t]==-2&&peaktroughIn2->valpeaktrough[t]==-2)
            {
                peaktroughOut->valpeaktrough[t]=-2;
            }
            else if(peaktroughIn1->valpeaktrough[t]==2&&peaktroughIn2->valpeaktrough[t]==2)
            {
                peaktroughOut->valpeaktrough[t]=2;
            }
            else
            {
                peaktroughOut->valpeaktrough[t]=0;
            }
        }
        return 0;
    }

    Int8 Myintersection_peaktroughside32FC(Peak_Trough32FC *peaktroughIn1,Peak_Trough32FC *peaktroughIn2,Peak_Trough32FC *peaktroughOut)
    {
        Int32 valuenum=peaktroughIn1->valuenum;
        Int32 t;

        if(peaktroughIn1->valuenum!=peaktroughIn2->valuenum)
            return 1;

        peaktroughOut->valuenum=valuenum;
        memcpy(peaktroughOut->value,peaktroughIn1->value,valuenum*sizeof(float));
        for(t=0;t<valuenum;t++)
        {
            if(peaktroughIn1->valpeaktrough[t]==-2&&peaktroughIn2->valpeaktrough[t]==-2)
            {
                peaktroughOut->valpeaktrough[t]=-2;
            }
            else if(peaktroughIn1->valpeaktrough[t]==2&&peaktroughIn2->valpeaktrough[t]==2)
            {
                peaktroughOut->valpeaktrough[t]=2;
            }
            else
            {
                peaktroughOut->valpeaktrough[t]=0;
            }
        }
        return 0;
    }

    Int8 Myunion2_peaktrough(Peak_Trough *peaktroughIn1,Peak_Trough *peaktroughIn2,Peak_Trough *peaktroughOut)
    {
        Int32 valuenum=peaktroughIn1->valuenum;
        Int32 t;

        if(peaktroughIn1->valuenum!=peaktroughIn2->valuenum)
            return 1;

        peaktroughOut->valuenum=valuenum;
        memcpy(peaktroughOut->value,peaktroughIn1->value,valuenum*sizeof(Int32));
        for(t=0;t<valuenum;t++)
        {
            if(peaktroughIn1->valpeaktrough[t]==-1||peaktroughIn2->valpeaktrough[t]==-1)
            {
                peaktroughOut->valpeaktrough[t]=-1;
            }
            else if(peaktroughIn1->valpeaktrough[t]==1||peaktroughIn2->valpeaktrough[t]==1)
            {
                peaktroughOut->valpeaktrough[t]=1;
            }
            else
            {
                peaktroughOut->valpeaktrough[t]=0;
            }
        }
        return 0;
    }

    Int8 Myunion2_peaktrough32FC(Peak_Trough32FC *peaktroughIn1,Peak_Trough32FC *peaktroughIn2,Peak_Trough32FC *peaktroughOut)
    {
        Int32 valuenum=peaktroughIn1->valuenum;
        Int32 t;

        if(peaktroughIn1->valuenum!=peaktroughIn2->valuenum)
            return 1;

        peaktroughOut->valuenum=valuenum;
        memcpy(peaktroughOut->value,peaktroughIn1->value,valuenum*sizeof(float));
        for(t=0;t<valuenum;t++)
        {
            if(peaktroughIn1->valpeaktrough[t]==-1||peaktroughIn2->valpeaktrough[t]==-1)
            {
                peaktroughOut->valpeaktrough[t]=-1;
            }
            else if(peaktroughIn1->valpeaktrough[t]==1||peaktroughIn2->valpeaktrough[t]==1)
            {
                peaktroughOut->valpeaktrough[t]=1;
            }
            else
            {
                peaktroughOut->valpeaktrough[t]=0;
            }
        }
        return 0;
    }

    Int8 Myintersection_peaktrough(Peak_Trough *peaktroughIn1,Peak_Trough *peaktroughIn2,Peak_Trough *peaktroughOut)
    {
        Int32 valuenum=peaktroughIn1->valuenum;
        Int32 t;

        if(peaktroughIn1->valuenum!=peaktroughIn2->valuenum)
            return 1;

        peaktroughOut->valuenum=valuenum;
        memcpy(peaktroughOut->value,peaktroughIn1->value,valuenum*sizeof(Int32));
        for(t=0;t<valuenum;t++)
        {
            if(peaktroughIn1->valpeaktrough[t]==-1&&peaktroughIn2->valpeaktrough[t]==-1)
            {
                peaktroughOut->valpeaktrough[t]=-1;
            }
            else if(peaktroughIn1->valpeaktrough[t]==1&&peaktroughIn2->valpeaktrough[t]==1)
            {
                peaktroughOut->valpeaktrough[t]=1;
            }
            else
            {
                peaktroughOut->valpeaktrough[t]=0;
            }
        }
        return 0;
    }

    Int8 Myintersection_peaktrough32FC(Peak_Trough32FC *peaktroughIn1,Peak_Trough32FC *peaktroughIn2,Peak_Trough32FC *peaktroughOut)
    {
        Int32 valuenum=peaktroughIn1->valuenum;
        Int32 t;

        if(peaktroughIn1->valuenum!=peaktroughIn2->valuenum)
            return 1;

        peaktroughOut->valuenum=valuenum;
        memcpy(peaktroughOut->value,peaktroughIn1->value,valuenum*sizeof(float));
        for(t=0;t<valuenum;t++)
        {
            if(peaktroughIn1->valpeaktrough[t]==-1&&peaktroughIn2->valpeaktrough[t]==-1)
            {
                peaktroughOut->valpeaktrough[t]=-1;
            }
            else if(peaktroughIn1->valpeaktrough[t]==1&&peaktroughIn2->valpeaktrough[t]==1)
            {
                peaktroughOut->valpeaktrough[t]=1;
            }
            else
            {
                peaktroughOut->valpeaktrough[t]=0;
            }
        }
        return 0;
    }

    Int8 Mydilation_peaktrough(Peak_Trough *peaktroughIn,Peak_Trough *peaktroughOut,peakdilationtype Mod,Int32 peaktrough_val,Bool circleMod)
    {
        Int32 valuenum=peaktroughIn->valuenum;
        Int32 t;
        Int32 dt;

        peaktroughOut->valuenum=valuenum;
        memcpy(peaktroughOut->value,peaktroughIn->value,valuenum*sizeof(Int32));

        if(peaktrough_val>0)
        {
            Int32 *bofengIn=(Int32*)u8_peaktrough_temp_1;
            Int32 *boguIn=(Int32*)u8_peaktrough_temp_2;
            memset(bofengIn,0,sizeof(Int32)*valuenum);
            memset(boguIn,0,sizeof(Int32)*valuenum);

            for(t=0;t<valuenum;t++)
            {
                switch(Mod)
                {
                case MHC_PEAKTROUGH_BOGU:
                    if(peaktroughIn->valpeaktrough[t]==-1)
                    {
                        for(dt=t-peaktrough_val;dt<=t+peaktrough_val;dt++)
                        {
                            Int32 DT=dt;
                            if(DT<0)
                            {
                                if(circleMod!=FALSE)
                                {
                                    DT=DT+valuenum;
                                }
                                else
                                {
                                    DT=0;
                                }
                            }
                            if(DT>=valuenum)
                            {
                                if(circleMod!=FALSE)
                                {
                                    DT=DT-valuenum;
                                }
                                else
                                {
                                    DT=valuenum-1;
                                }
                            }
                            boguIn[DT]=-1;
                        }
                    }
                break;
                case MHC_PEAKTROUGH_BOFENG:
                    if(peaktroughIn->valpeaktrough[t]==1)
                    {
                        for(dt=t-peaktrough_val;dt<=t+peaktrough_val;dt++)
                        {
                            Int32 DT=dt;
                            if(DT<0)
                            {
                                if(circleMod!=FALSE)
                                {
                                    DT=DT+valuenum;
                                }
                                else
                                {
                                    DT=0;
                                }
                            }
                            if(DT>=valuenum)
                            {
                                if(circleMod!=FALSE)
                                {
                                    DT=DT-valuenum;
                                }
                                else
                                {
                                    DT=valuenum-1;
                                }
                            }
                            bofengIn[DT]=1;
                        }
                    }
                break;
                default:
                    return 1;
                break;
                }
            }
            for(t=0;t<valuenum;t++)
            {
                switch(Mod)
                {
                case MHC_PEAKTROUGH_BOGU:
                    if(boguIn[t]==-1&&boguIn[t]==-1)
                    {
                        peaktroughOut->valpeaktrough[t]=-1;
                    }
                    else
                    {
                        peaktroughOut->valpeaktrough[t]=0;
                    }
                break;
                case MHC_PEAKTROUGH_BOFENG:
                    if(bofengIn[t]==1&&bofengIn[t]==1)
                    {
                        peaktroughOut->valpeaktrough[t]=1;
                    }
                    else
                    {
                        peaktroughOut->valpeaktrough[t]=0;
                    }
                break;
                default:
                    return 1;
                break;
                }
            }
        }
        return 0;
    }

    Int8 Mydilation_peaktrough32FC(Peak_Trough32FC *peaktroughIn,Peak_Trough32FC *peaktroughOut,peakdilationtype Mod,Int32 peaktrough_val,Bool circleMod)
    {
        Int32 valuenum=peaktroughIn->valuenum;
        Int32 t;
        Int32 dt;

        peaktroughOut->valuenum=valuenum;
        memcpy(peaktroughOut->value,peaktroughIn->value,valuenum*sizeof(float));

        if(peaktrough_val>0)
        {
            Int32 *bofengIn=(Int32*)u8_peaktrough_temp_1;
            Int32 *boguIn=(Int32*)u8_peaktrough_temp_2;
            memset(bofengIn,0,sizeof(Int32)*valuenum);
            memset(boguIn,0,sizeof(Int32)*valuenum);

            for(t=0;t<valuenum;t++)
            {
                switch(Mod)
                {
                case MHC_PEAKTROUGH_BOGU:
                    if(peaktroughIn->valpeaktrough[t]==-1)
                    {
                        for(dt=t-peaktrough_val;dt<=t+peaktrough_val;dt++)
                        {
                            Int32 DT=dt;
                            if(DT<0)
                            {
                                if(circleMod!=FALSE)
                                {
                                    DT=DT+valuenum;
                                }
                                else
                                {
                                    DT=0;
                                }
                            }
                            if(DT>=valuenum)
                            {
                                if(circleMod!=FALSE)
                                {
                                    DT=DT-valuenum;
                                }
                                else
                                {
                                    DT=valuenum-1;
                                }
                            }
                            boguIn[DT]=-1;
                        }
                    }
                break;
                case MHC_PEAKTROUGH_BOFENG:
                    if(peaktroughIn->valpeaktrough[t]==1)
                    {
                        for(dt=t-peaktrough_val;dt<=t+peaktrough_val;dt++)
                        {
                            Int32 DT=dt;
                            if(DT<0)
                            {
                                if(circleMod!=FALSE)
                                {
                                    DT=DT+valuenum;
                                }
                                else
                                {
                                    DT=0;
                                }
                            }
                            if(DT>=valuenum)
                            {
                                if(circleMod!=FALSE)
                                {
                                    DT=DT-valuenum;
                                }
                                else
                                {
                                    DT=valuenum-1;
                                }
                            }
                            bofengIn[DT]=1;
                        }
                    }
                break;
                default:
                    return 1;
                break;
                }
            }
            for(t=0;t<valuenum;t++)
            {
                switch(Mod)
                {
                case MHC_PEAKTROUGH_BOGU:
                    if(boguIn[t]==-1&&boguIn[t]==-1)
                    {
                        peaktroughOut->valpeaktrough[t]=-1;
                    }
                    else
                    {
                        peaktroughOut->valpeaktrough[t]=0;
                    }
                break;
                case MHC_PEAKTROUGH_BOFENG:
                    if(bofengIn[t]==1&&bofengIn[t]==1)
                    {
                        peaktroughOut->valpeaktrough[t]=1;
                    }
                    else
                    {
                        peaktroughOut->valpeaktrough[t]=0;
                    }
                break;
                default:
                    return 1;
                break;
                }
            }
        }
        return 0;
    }

    Int8 Myselect_peaktrough_obj(Peak_Trough *peaktroughIn,Peak_Trough *peaktroughOut,Int32 peaktroughnum,Bool circleMod)
    {
        Int32 valuenum=peaktroughIn->valuenum;
        Int32 n,t,k,tempn;

        peaktroughOut->valuenum=valuenum;
        memcpy(peaktroughOut->value,peaktroughIn->value,valuenum*sizeof(Int32));

        if(peaktroughIn->valpeaktrough[peaktroughnum]==-1)
        {
            memset(peaktroughOut->valpeaktrough,1,valuenum*sizeof(Int8));
            peaktroughOut->valpeaktrough[peaktroughnum]=-1;
            if(circleMod!=FALSE)
            {
                t=peaktroughnum;
                n=1;
                tempn=1;
                while(tempn<peaktroughIn->valuenum)
                {
                    k=t-tempn;
                    if(k<0)
                        k=k+valuenum;
                    if(peaktroughIn->valpeaktrough[k]==1)
                    {
                        break;
                    }
                    else
                    {
                        peaktroughOut->valpeaktrough[k]=peaktroughIn->valpeaktrough[k];
                    }
                    tempn++;
                }
                tempn=1;
                while(tempn<peaktroughIn->valuenum)
                {
                    k=t+tempn;
                    if(k>=valuenum)
                        k=k-valuenum;
                    if(peaktroughIn->valpeaktrough[k]==1)
                    {
                        break;
                    }
                    else
                    {
                        peaktroughOut->valpeaktrough[k]=peaktroughIn->valpeaktrough[k];
                    }
                    tempn++;
                }
            }
            else
            {
                t=peaktroughnum;
                while(t>0)
                {
                    t=t-1;
                    if(peaktroughIn->valpeaktrough[t]==1)
                    {
                        break;
                    }
                    else
                    {
                        peaktroughOut->valpeaktrough[t]=peaktroughIn->valpeaktrough[t];
                    }
                }
                t=peaktroughnum;
                while(t<peaktroughIn->valuenum-1)
                {
                    t=t+1;
                    if(peaktroughIn->valpeaktrough[t]==1)
                    {
                        break;
                    }
                    else
                    {
                        peaktroughOut->valpeaktrough[t]=peaktroughIn->valpeaktrough[t];
                    }
                }
            }
        }
        else if(peaktroughIn->valpeaktrough[peaktroughnum]==1)
        {
            memset(peaktroughOut->valpeaktrough,-1,valuenum*sizeof(Int8));
            peaktroughOut->valpeaktrough[peaktroughnum]=1;
            if(circleMod!=FALSE)
            {
                t=peaktroughnum;
                n=1;
                tempn=1;
                while(tempn<peaktroughIn->valuenum)
                {
                    k=t-tempn;
                    if(k<0)
                        k=k+valuenum;
                    if(peaktroughIn->valpeaktrough[k]==-1)
                    {
                        break;
                    }
                    else
                    {
                        peaktroughOut->valpeaktrough[k]=peaktroughIn->valpeaktrough[k];
                    }
                    tempn++;
                }
                tempn=1;
                while(tempn<peaktroughIn->valuenum)
                {
                    k=t+tempn;
                    if(k>=valuenum)
                        k=k-valuenum;
                    if(peaktroughIn->valpeaktrough[k]==-1)
                    {
                        break;
                    }
                    else
                    {
                        peaktroughOut->valpeaktrough[k]=peaktroughIn->valpeaktrough[k];
                    }
                    tempn++;
                }
            }
            else
            {
                t=peaktroughnum;
                while(t>0)
                {
                    t=t-1;
                    if(peaktroughIn->valpeaktrough[t]==-1)
                    {
                        break;
                    }
                    else
                    {
                        peaktroughOut->valpeaktrough[t]=peaktroughIn->valpeaktrough[t];
                    }
                }
                t=peaktroughnum;
                while(t<peaktroughIn->valuenum-1)
                {
                    t=t+1;
                    if(peaktroughIn->valpeaktrough[t]==-1)
                    {
                        break;
                    }
                    else
                    {
                        peaktroughOut->valpeaktrough[t]=peaktroughIn->valpeaktrough[t];
                    }
                }
            }
        }
        else
        {
            for(n=0;n<valuenum;n++)
            {
                peaktroughOut->valpeaktrough[n]=0;
            }
        }
        return 0;
    }

    Int8 Myselect_peaktrough_obj32FC(Peak_Trough32FC *peaktroughIn,Peak_Trough32FC *peaktroughOut,Int32 peaktroughnum,Bool circleMod)
    {
        Int32 valuenum=peaktroughIn->valuenum;
        Int32 n,t,k,tempn;

        peaktroughOut->valuenum=valuenum;
        memcpy(peaktroughOut->value,peaktroughIn->value,valuenum*sizeof(float));

        if(peaktroughIn->valpeaktrough[peaktroughnum]==-1)
        {
            memset(peaktroughOut->valpeaktrough,1,valuenum*sizeof(Int8));
            peaktroughOut->valpeaktrough[peaktroughnum]=-1;
            if(circleMod!=FALSE)
            {
                t=peaktroughnum;
                n=1;
                tempn=1;
                while(tempn<peaktroughIn->valuenum)
                {
                    k=t-tempn;
                    if(k<0)
                        k=k+valuenum;
                    if(peaktroughIn->valpeaktrough[k]==1)
                    {
                        break;
                    }
                    else
                    {
                        peaktroughOut->valpeaktrough[k]=peaktroughIn->valpeaktrough[k];
                    }
                    tempn++;
                }
                tempn=1;
                while(tempn<peaktroughIn->valuenum)
                {
                    k=t+tempn;
                    if(k>=valuenum)
                        k=k-valuenum;
                    if(peaktroughIn->valpeaktrough[k]==1)
                    {
                        break;
                    }
                    else
                    {
                        peaktroughOut->valpeaktrough[k]=peaktroughIn->valpeaktrough[k];
                    }
                    tempn++;
                }
            }
            else
            {
                t=peaktroughnum;
                while(t>0)
                {
                    t=t-1;
                    if(peaktroughIn->valpeaktrough[t]==1)
                    {
                        break;
                    }
                    else
                    {
                        peaktroughOut->valpeaktrough[t]=peaktroughIn->valpeaktrough[t];
                    }
                }
                t=peaktroughnum;
                while(t<peaktroughIn->valuenum-1)
                {
                    t=t+1;
                    if(peaktroughIn->valpeaktrough[t]==1)
                    {
                        break;
                    }
                    else
                    {
                        peaktroughOut->valpeaktrough[t]=peaktroughIn->valpeaktrough[t];
                    }
                }
            }
        }
        else if(peaktroughIn->valpeaktrough[peaktroughnum]==1)
        {
            memset(peaktroughOut->valpeaktrough,-1,valuenum*sizeof(Int8));
            peaktroughOut->valpeaktrough[peaktroughnum]=1;
            if(circleMod!=FALSE)
            {
                t=peaktroughnum;
                n=1;
                tempn=1;
                while(tempn<peaktroughIn->valuenum)
                {
                    k=t-tempn;
                    if(k<0)
                        k=k+valuenum;
                    if(peaktroughIn->valpeaktrough[k]==-1)
                    {
                        break;
                    }
                    else
                    {
                        peaktroughOut->valpeaktrough[k]=peaktroughIn->valpeaktrough[k];
                    }
                    tempn++;
                }
                tempn=1;
                while(tempn<peaktroughIn->valuenum)
                {
                    k=t+tempn;
                    if(k>=valuenum)
                        k=k-valuenum;
                    if(peaktroughIn->valpeaktrough[k]==-1)
                    {
                        break;
                    }
                    else
                    {
                        peaktroughOut->valpeaktrough[k]=peaktroughIn->valpeaktrough[k];
                    }
                    tempn++;
                }
            }
            else
            {
                t=peaktroughnum;
                while(t>0)
                {
                    t=t-1;
                    if(peaktroughIn->valpeaktrough[t]==-1)
                    {
                        break;
                    }
                    else
                    {
                        peaktroughOut->valpeaktrough[t]=peaktroughIn->valpeaktrough[t];
                    }
                }
                t=peaktroughnum;
                while(t<peaktroughIn->valuenum-1)
                {
                    t=t+1;
                    if(peaktroughIn->valpeaktrough[t]==-1)
                    {
                        break;
                    }
                    else
                    {
                        peaktroughOut->valpeaktrough[t]=peaktroughIn->valpeaktrough[t];
                    }
                }
            }
        }
        else
        {
            for(n=0;n<valuenum;n++)
            {
                peaktroughOut->valpeaktrough[n]=0;
            }
        }
        return 0;
    }

    Int8 Myselect_peaktrough_1(Peak_Trough *peaktroughIn,Peak_Trough *peaktroughOut,peakselecttype_1 Mod,Int32 peaktrough_nearside,double peaktrough_val,Bool circleMod)
    {
        Int32 valuenum=peaktroughIn->valuenum;
        Int32 t;
        peaktroughOut->valuenum=valuenum;
        memcpy(peaktroughOut->value,peaktroughIn->value,valuenum*sizeof(Int32));
        memset(peaktroughOut->valpeaktrough,0,sizeof(Int8)*valuenum);

        switch(Mod)
        {
        case MHC_PEAKTROUGH_BOGU_NEAR_PRESENT_ABS:
            if(circleMod!=FALSE)
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==-1)//����
                    {
                        Int32 max=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        while(n<=peaktrough_nearside)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->value[k]>max)
                            {
                                max=peaktroughIn->value[k];
                            }
                        }
                        n=1;
                        while(n<=peaktrough_nearside)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->value[k]>max)
                            {
                                max=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]<=max*peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=-1;
                        }
                    }
                }
            }
            else
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==-1)//����
                    {
                        Int32 max=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        while(n<=peaktrough_nearside)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                break;
                            if(peaktroughIn->value[k]>max)
                            {
                                max=peaktroughIn->value[k];
                            }
                        }
                        n=1;
                        while(n<=peaktrough_nearside)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                break;
                            if(peaktroughIn->value[k]>max)
                            {
                                max=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]<=max*peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=-1;
                        }
                    }
                }
            }
            break;
        case MHC_PEAKTROUGH_BOGU_NEAR_ABS:
            if(circleMod!=FALSE)
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==-1)//����
                    {
                        Int32 max=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        while(n<=peaktrough_nearside)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->value[k]>max)
                            {
                                max=peaktroughIn->value[k];
                            }
                        }
                        n=1;
                        while(n<=peaktrough_nearside)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->value[k]>max)
                            {
                                max=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]<=max-peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=-1;
                        }
                    }
                }
            }
            else
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==-1)//����
                    {
                        Int32 max=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        while(n<=peaktrough_nearside)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                break;
                            if(peaktroughIn->value[k]>max)
                            {
                                max=peaktroughIn->value[k];
                            }
                        }
                        n=1;
                        while(n<=peaktrough_nearside)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                break;
                            if(peaktroughIn->value[k]>max)
                            {
                                max=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]<=max-peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=-1;
                        }
                    }
                }
            }
            break;
        case MHC_PEAKTROUGH_BOFENG_NEAR_PRESENT_ABS:
            if(circleMod!=FALSE)
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==1)//����
                    {
                        Int32 min=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        while(n<=peaktrough_nearside)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->value[k]<min)
                            {
                                min=peaktroughIn->value[k];
                            }
                        }
                        n=1;
                        while(n<=peaktrough_nearside)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->value[k]<min)
                            {
                                min=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]>=min/peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=1;
                        }
                    }
                }
            }
            else
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==1)//����
                    {
                        Int32 min=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        while(n<=peaktrough_nearside)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                break;
                            if(peaktroughIn->value[k]<min)
                            {
                                min=peaktroughIn->value[k];
                            }
                        }
                        n=1;
                        while(n<=peaktrough_nearside)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                break;
                            if(peaktroughIn->value[k]<min)
                            {
                                min=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]>=min/peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=1;
                        }
                    }
                }
            }
            break;
        case MHC_PEAKTROUGH_BOFENG_NEAR_ABS:
            if(circleMod!=FALSE)
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==1)//����
                    {
                        Int32 min=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        while(n<=peaktrough_nearside)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->value[k]<min)
                            {
                                min=peaktroughIn->value[k];
                            }
                        }
                        n=1;
                        while(n<=peaktrough_nearside)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->value[k]<min)
                            {
                                min=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]>=min+peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=1;
                        }
                    }
                }
            }
            else
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==1)//����
                    {
                        Int32 min=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        while(n<=peaktrough_nearside)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                break;
                            if(peaktroughIn->value[k]<min)
                            {
                                min=peaktroughIn->value[k];
                            }
                        }
                        n=1;
                        while(n<=peaktrough_nearside)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                break;
                            if(peaktroughIn->value[k]<min)
                            {
                                min=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]>=min+peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=1;
                        }
                    }
                }
            }
            break;

        case MHC_PEAKTROUGH_BOGU_NEAR2_PRESENT_ABS:
            if(circleMod!=FALSE)
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==-1)//����
                    {
                        Int32 max=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        Int32 tempn=1;
                        Int32 Ltemp,Rtemp;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t-tempn;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->value[k]!=max)
                            {
                                Ltemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        tempn=1;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t+tempn;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->value[k]!=max)
                            {
                                Rtemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        n=Ltemp;
                        while(n<=peaktrough_nearside+Ltemp)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->value[k]>max)
                            {
                                max=peaktroughIn->value[k];
                            }
                        }
                        n=Rtemp;
                        while(n<=peaktrough_nearside+Rtemp)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->value[k]>max)
                            {
                                max=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]<=max*peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=-1;
                        }
                    }
                }
            }
            else
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==-1)//����
                    {
                        Int32 max=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        Int32 tempn=1;
                        Int32 Ltemp,Rtemp;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t-tempn;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->value[k]!=max)
                            {
                                Ltemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        tempn=1;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t+tempn;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->value[k]!=max)
                            {
                                Rtemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        n=Ltemp;
                        while(n<=peaktrough_nearside+Ltemp)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                break;
                            if(peaktroughIn->value[k]>max)
                            {
                                max=peaktroughIn->value[k];
                            }
                        }
                        n=Rtemp;
                        while(n<=peaktrough_nearside+Rtemp)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                break;
                            if(peaktroughIn->value[k]>max)
                            {
                                max=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]<=max*peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=-1;
                        }
                    }
                }
            }
            break;
        case MHC_PEAKTROUGH_BOGU_NEAR2_ABS:
            if(circleMod!=FALSE)
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==-1)//����
                    {
                        Int32 max=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        Int32 tempn=1;
                        Int32 Ltemp,Rtemp;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t-tempn;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->value[k]!=max)
                            {
                                Ltemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        tempn=1;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t+tempn;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->value[k]!=max)
                            {
                                Rtemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        n=Ltemp;
                        while(n<=peaktrough_nearside+Ltemp)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->value[k]>max)
                            {
                                max=peaktroughIn->value[k];
                            }
                        }
                        n=Rtemp;
                        while(n<=peaktrough_nearside+Rtemp)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->value[k]>max)
                            {
                                max=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]<=max-peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=-1;
                        }
                    }
                }
            }
            else
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==-1)//����
                    {
                        Int32 max=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        Int32 tempn=1;
                        Int32 Ltemp,Rtemp;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t-tempn;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->value[k]!=max)
                            {
                                Ltemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        tempn=1;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t+tempn;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->value[k]!=max)
                            {
                                Rtemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        n=Ltemp;
                        while(n<=peaktrough_nearside+Ltemp)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                break;
                            if(peaktroughIn->value[k]>max)
                            {
                                max=peaktroughIn->value[k];
                            }
                        }
                        n=Rtemp;
                        while(n<=peaktrough_nearside+Rtemp)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                break;
                            if(peaktroughIn->value[k]>max)
                            {
                                max=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]<=max-peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=-1;
                        }
                    }
                }
            }
            break;
        case MHC_PEAKTROUGH_BOFENG_NEAR2_PRESENT_ABS:
            if(circleMod!=FALSE)
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==1)//����
                    {
                        Int32 min=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        Int32 tempn=1;
                        Int32 Ltemp,Rtemp;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t-tempn;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->value[k]!=min)
                            {
                                Ltemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        tempn=1;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t+tempn;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->value[k]!=min)
                            {
                                Rtemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        n=Ltemp;
                        while(n<=peaktrough_nearside+Ltemp)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->value[k]<min)
                            {
                                min=peaktroughIn->value[k];
                            }
                        }
                        n=Rtemp;
                        while(n<=peaktrough_nearside+Rtemp)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->value[k]<min)
                            {
                                min=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]>=min/peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=1;
                        }
                    }
                }
            }
            else
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==1)//����
                    {
                        Int32 min=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        Int32 tempn=1;
                        Int32 Ltemp,Rtemp;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t-tempn;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->value[k]!=min)
                            {
                                Ltemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        tempn=1;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t+tempn;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->value[k]!=min)
                            {
                                Rtemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        n=Ltemp;
                        while(n<=peaktrough_nearside+Ltemp)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                break;
                            if(peaktroughIn->value[k]<min)
                            {
                                min=peaktroughIn->value[k];
                            }
                        }
                        n=Rtemp;
                        while(n<=peaktrough_nearside+Rtemp)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                break;
                            if(peaktroughIn->value[k]<min)
                            {
                                min=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]>=min/peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=1;
                        }
                    }
                }
            }
            break;
        case MHC_PEAKTROUGH_BOFENG_NEAR2_ABS:
            if(circleMod!=FALSE)
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==1)//����
                    {
                        Int32 min=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        Int32 tempn=1;
                        Int32 Ltemp,Rtemp;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t-tempn;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->value[k]!=min)
                            {
                                Ltemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        tempn=1;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t+tempn;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->value[k]!=min)
                            {
                                Rtemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        n=Ltemp;
                        while(n<=peaktrough_nearside+Ltemp)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->value[k]<min)
                            {
                                min=peaktroughIn->value[k];
                            }
                        }
                        n=Rtemp;
                        while(n<=peaktrough_nearside+Rtemp)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->value[k]<min)
                            {
                                min=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]>=min+peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=1;
                        }
                    }
                }
            }
            else
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==1)//����
                    {
                        Int32 min=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        Int32 tempn=1;
                        Int32 Ltemp,Rtemp;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t-tempn;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->value[k]!=min)
                            {
                                Ltemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        tempn=1;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t+tempn;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->value[k]!=min)
                            {
                                Rtemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        n=Ltemp;
                        while(n<=peaktrough_nearside+Ltemp)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                break;
                            if(peaktroughIn->value[k]<min)
                            {
                                min=peaktroughIn->value[k];
                            }
                        }
                        n=Rtemp;
                        while(n<=peaktrough_nearside+Rtemp)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                break;
                            if(peaktroughIn->value[k]<min)
                            {
                                min=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]>=min+peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=1;
                        }
                    }
                }
            }
            break;
        case MHC_PEAKTROUGH_BOGU_TOWSIZENEAR_PRESENT_ABS:
            if(circleMod!=FALSE)
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==-1)//����
                    {
                        Int32 max1=peaktroughIn->value[t];
                        Int32 max2=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        while(n<=peaktrough_nearside)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->value[k]>max1)
                            {
                                max1=peaktroughIn->value[k];
                            }
                        }
                        n=1;
                        while(n<=peaktrough_nearside)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->value[k]>max2)
                            {
                                max2=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]<=max1*peaktrough_val&&peaktroughIn->value[t]<=max2*peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=-1;
                        }
                    }
                }
            }
            else
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==-1)//����
                    {
                        Int32 max1=peaktroughIn->value[t];
                        Int32 max2=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        while(n<=peaktrough_nearside)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                break;
                            if(peaktroughIn->value[k]>max1)
                            {
                                max1=peaktroughIn->value[k];
                            }
                        }
                        n=1;
                        while(n<=peaktrough_nearside)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                break;
                            if(peaktroughIn->value[k]>max2)
                            {
                                max2=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]<=max1*peaktrough_val&&peaktroughIn->value[t]<=max2*peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=-1;
                        }
                    }
                }
            }
            break;
        case MHC_PEAKTROUGH_BOGU_TOWSIZENEAR_ABS:
            if(circleMod!=FALSE)
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==-1)//����
                    {
                        Int32 max1=peaktroughIn->value[t];
                        Int32 max2=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        while(n<=peaktrough_nearside)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->value[k]>max1)
                            {
                                max1=peaktroughIn->value[k];
                            }
                        }
                        n=1;
                        while(n<=peaktrough_nearside)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->value[k]>max2)
                            {
                                max2=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]<=max1-peaktrough_val&&peaktroughIn->value[t]<=max2-peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=-1;
                        }
                    }
                }
            }
            else
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==-1)//����
                    {
                        Int32 max1=peaktroughIn->value[t];
                        Int32 max2=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        while(n<=peaktrough_nearside)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                break;
                            if(peaktroughIn->value[k]>max1)
                            {
                                max1=peaktroughIn->value[k];
                            }
                        }
                        n=1;
                        while(n<=peaktrough_nearside)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                break;
                            if(peaktroughIn->value[k]>max2)
                            {
                                max2=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]<=max1-peaktrough_val&&peaktroughIn->value[t]<=max2-peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=-1;
                        }
                    }
                }
            }
            break;
        case MHC_PEAKTROUGH_BOFENG_TOWSIZENEAR_PRESENT_ABS:
            if(circleMod!=FALSE)
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==1)//����
                    {
                        Int32 min1=peaktroughIn->value[t];
                        Int32 min2=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        while(n<=peaktrough_nearside)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->value[k]<min1)
                            {
                                min1=peaktroughIn->value[k];
                            }
                        }
                        n=1;
                        while(n<=peaktrough_nearside)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->value[k]<min2)
                            {
                                min2=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]>=min1/peaktrough_val&&peaktroughIn->value[t]>=min2/peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=1;
                        }
                    }
                }
            }
            else
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==1)//����
                    {
                        Int32 min1=peaktroughIn->value[t];
                        Int32 min2=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        while(n<=peaktrough_nearside)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                break;
                            if(peaktroughIn->value[k]<min1)
                            {
                                min1=peaktroughIn->value[k];
                            }
                        }
                        n=1;
                        while(n<=peaktrough_nearside)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                break;
                            if(peaktroughIn->value[k]<min2)
                            {
                                min2=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]>=min1/peaktrough_val&&peaktroughIn->value[t]>=min2/peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=1;
                        }
                    }
                }
            }
            break;
        case MHC_PEAKTROUGH_BOFENG_TOWSIZENEAR_ABS:
            if(circleMod!=FALSE)
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==1)//����
                    {
                        Int32 min1=peaktroughIn->value[t];
                        Int32 min2=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        while(n<=peaktrough_nearside)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->value[k]<min1)
                            {
                                min1=peaktroughIn->value[k];
                            }
                        }
                        n=1;
                        while(n<=peaktrough_nearside)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->value[k]<min2)
                            {
                                min2=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]>=min1+peaktrough_val&&peaktroughIn->value[t]>=min2+peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=1;
                        }
                    }
                }
            }
            else
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==1)//����
                    {
                        Int32 min1=peaktroughIn->value[t];
                        Int32 min2=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        while(n<=peaktrough_nearside)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                break;
                            if(peaktroughIn->value[k]<min1)
                            {
                                min1=peaktroughIn->value[k];
                            }
                        }
                        n=1;
                        while(n<=peaktrough_nearside)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                break;
                            if(peaktroughIn->value[k]<min2)
                            {
                                min2=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]>=min1+peaktrough_val&&peaktroughIn->value[t]>=min2+peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=1;
                        }
                    }
                }
            }
            break;
        case MHC_PEAKTROUGH_BOGU_TOWSIZENEAR2_PRESENT_ABS:
            if(circleMod!=FALSE)
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==-1)//����
                    {
                        Int32 max1=peaktroughIn->value[t];
                        Int32 max2=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        Int32 tempn=1;
                        Int32 Ltemp,Rtemp;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t-tempn;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->value[k]!=max1)
                            {
                                Ltemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        tempn=1;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t+tempn;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->value[k]!=max2)
                            {
                                Rtemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        n=Ltemp;
                        while(n<=peaktrough_nearside+Ltemp)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->value[k]>max1)
                            {
                                max1=peaktroughIn->value[k];
                            }
                        }
                        n=Rtemp;
                        while(n<=peaktrough_nearside+Rtemp)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->value[k]>max2)
                            {
                                max2=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]<=max1*peaktrough_val&&peaktroughIn->value[t]<=max2*peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=-1;
                        }
                    }
                }
            }
            else
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==-1)//����
                    {
                        Int32 max1=peaktroughIn->value[t];
                        Int32 max2=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        Int32 tempn=1;
                        Int32 Ltemp,Rtemp;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t-tempn;
                            if(k<0)
                            {
                                Ltemp=tempn;
                                break;
                            }
                            if(peaktroughIn->value[k]!=max1)
                            {
                                Ltemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        tempn=1;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t+tempn;
                            if(k>=valuenum)
                            {
                                Rtemp=tempn;
                                break;
                            }
                            if(peaktroughIn->value[k]!=max2)
                            {
                                Rtemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        n=Ltemp;
                        while(n<=peaktrough_nearside+Ltemp)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                break;
                            if(peaktroughIn->value[k]>max1)
                            {
                                max1=peaktroughIn->value[k];
                            }
                        }
                        n=Rtemp;
                        while(n<=peaktrough_nearside+Rtemp)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                break;
                            if(peaktroughIn->value[k]>max2)
                            {
                                max2=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]<=max1*peaktrough_val&&peaktroughIn->value[t]<=max2*peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=-1;
                        }
                    }
                }
            }
            break;
        case MHC_PEAKTROUGH_BOGU_TOWSIZENEAR2_ABS:
            if(circleMod!=FALSE)
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==-1)//����
                    {
                        Int32 max1=peaktroughIn->value[t];
                        Int32 max2=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        Int32 tempn=1;
                        Int32 Ltemp,Rtemp;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t-tempn;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->value[k]!=max1)
                            {
                                Ltemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        tempn=1;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t+tempn;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->value[k]!=max2)
                            {
                                Rtemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        n=Ltemp;
                        while(n<=peaktrough_nearside+Ltemp)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->value[k]>max1)
                            {
                                max1=peaktroughIn->value[k];
                            }
                        }
                        n=Rtemp;
                        while(n<=peaktrough_nearside+Rtemp)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->value[k]>max2)
                            {
                                max2=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]<=max1-peaktrough_val&&peaktroughIn->value[t]<=max2-peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=-1;
                        }
                    }
                }
            }
            else
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==-1)//����
                    {
                        Int32 max1=peaktroughIn->value[t];
                        Int32 max2=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        Int32 tempn=1;
                        Int32 Ltemp,Rtemp;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t-tempn;
                            if(k<0)
                            {
                                Ltemp=tempn;
                                break;
                            }
                            if(peaktroughIn->value[k]!=max1)
                            {
                                Ltemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        tempn=1;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t+tempn;
                            if(k>=valuenum)
                            {
                                Rtemp=tempn;
                                break;
                            }
                            if(peaktroughIn->value[k]!=max2)
                            {
                                Rtemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        n=Ltemp;
                        while(n<=peaktrough_nearside+Ltemp)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                break;
                            if(peaktroughIn->value[k]>max1)
                            {
                                max1=peaktroughIn->value[k];
                            }
                        }
                        n=Rtemp;
                        while(n<=peaktrough_nearside+Rtemp)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                break;
                            if(peaktroughIn->value[k]>max2)
                            {
                                max2=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]<=max1-peaktrough_val&&peaktroughIn->value[t]<=max2-peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=-1;
                        }
                    }
                }
            }
            break;
        case MHC_PEAKTROUGH_BOFENG_TOWSIZENEAR2_PRESENT_ABS:
            if(circleMod!=FALSE)
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==1)//����
                    {
                        Int32 min1=peaktroughIn->value[t];
                        Int32 min2=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        Int32 tempn=1;
                        Int32 Ltemp,Rtemp;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t-tempn;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->value[k]!=min1)
                            {
                                Ltemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        tempn=1;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t+tempn;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->value[k]!=min2)
                            {
                                Rtemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        n=Ltemp;
                        while(n<=peaktrough_nearside+Ltemp)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->value[k]<min1)
                            {
                                min1=peaktroughIn->value[k];
                            }
                        }
                        n=Rtemp;
                        while(n<=peaktrough_nearside+Rtemp)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->value[k]<min2)
                            {
                                min2=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]>=min1/peaktrough_val&&peaktroughIn->value[t]>=min2/peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=1;
                        }
                    }
                }
            }
            else
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==1)//����
                    {
                        Int32 min1=peaktroughIn->value[t];
                        Int32 min2=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        Int32 tempn=1;
                        Int32 Ltemp,Rtemp;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t-tempn;
                            if(k<0)
                            {
                                Ltemp=tempn;
                                break;
                            }
                            if(peaktroughIn->value[k]!=min1)
                            {
                                Ltemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        tempn=1;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t+tempn;
                            if(k>=valuenum)
                            {
                                Rtemp=tempn;
                                break;
                            }
                            if(peaktroughIn->value[k]!=min2)
                            {
                                Rtemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        n=Ltemp;
                        while(n<=peaktrough_nearside+Ltemp)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                break;
                            if(peaktroughIn->value[k]<min1)
                            {
                                min1=peaktroughIn->value[k];
                            }
                        }
                        n=Rtemp;
                        while(n<=peaktrough_nearside+Rtemp)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                break;
                            if(peaktroughIn->value[k]<min2)
                            {
                                min2=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]>=min1/peaktrough_val&&peaktroughIn->value[t]>=min2/peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=1;
                        }
                    }
                }
            }
            break;
        case MHC_PEAKTROUGH_BOFENG_TOWSIZENEAR2_ABS:
            if(circleMod!=FALSE)
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==1)//����
                    {
                        Int32 min1=peaktroughIn->value[t];
                        Int32 min2=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        Int32 tempn=1;
                        Int32 Ltemp,Rtemp;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t-tempn;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->value[k]!=min1)
                            {
                                Ltemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        tempn=1;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t+tempn;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->value[k]!=min2)
                            {
                                Rtemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        n=Ltemp;
                        while(n<=peaktrough_nearside+Ltemp)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->value[k]<min1)
                            {
                                min1=peaktroughIn->value[k];
                            }
                        }
                        n=Rtemp;
                        while(n<=peaktrough_nearside+Rtemp)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->value[k]<min2)
                            {
                                min2=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]>=min1+peaktrough_val&&peaktroughIn->value[t]>=min2+peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=1;
                        }
                    }
                }
            }
            else
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==1)//����
                    {
                        Int32 min1=peaktroughIn->value[t];
                        Int32 min2=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        Int32 tempn=1;
                        Int32 Ltemp,Rtemp;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t-tempn;
                            if(k<0)
                            {
                                Ltemp=tempn;
                                break;
                            }
                            if(peaktroughIn->value[k]!=min1)
                            {
                                Ltemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        tempn=1;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t+tempn;
                            if(k>=valuenum)
                            {
                                Rtemp=tempn;
                                break;
                            }
                            if(peaktroughIn->value[k]!=min2)
                            {
                                Rtemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        n=Ltemp;
                        while(n<=peaktrough_nearside+Ltemp)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                break;
                            if(peaktroughIn->value[k]<min1)
                            {
                                min1=peaktroughIn->value[k];
                            }
                        }
                        n=Rtemp;
                        while(n<=peaktrough_nearside+Rtemp)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                break;
                            if(peaktroughIn->value[k]<min2)
                            {
                                min2=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]>=min1+peaktrough_val&&peaktroughIn->value[t]>=min2+peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=1;
                        }
                    }
                }
            }
            break;
        default:
            return 1;
            break;
        }
        return 0;
    }

    Int8 Myselect_peaktrough_132FC(Peak_Trough32FC *peaktroughIn,Peak_Trough32FC *peaktroughOut, peakselecttype_1 Mod,Int32 peaktrough_nearside,double peaktrough_val,Bool circleMod)
    {
        Int32 valuenum=peaktroughIn->valuenum;
        Int32 t;
        peaktroughOut->valuenum=valuenum;
        memcpy(peaktroughOut->value,peaktroughIn->value,valuenum*sizeof(float));
        memset(peaktroughOut->valpeaktrough,0,sizeof(Int8)*valuenum);

        switch(Mod)
        {
        case MHC_PEAKTROUGH_BOGU_NEAR_PRESENT_ABS:
            if(circleMod!=FALSE)
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==-1)//����
                    {
                        float max=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        while(n<=peaktrough_nearside)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->value[k]>max)
                            {
                                max=peaktroughIn->value[k];
                            }
                        }
                        n=1;
                        while(n<=peaktrough_nearside)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->value[k]>max)
                            {
                                max=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]<=max*peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=-1;
                        }
                    }
                }
            }
            else
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==-1)//����
                    {
                        float max=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        while(n<=peaktrough_nearside)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                break;
                            if(peaktroughIn->value[k]>max)
                            {
                                max=peaktroughIn->value[k];
                            }
                        }
                        n=1;
                        while(n<=peaktrough_nearside)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                break;
                            if(peaktroughIn->value[k]>max)
                            {
                                max=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]<=max*peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=-1;
                        }
                    }
                }
            }
            break;
        case MHC_PEAKTROUGH_BOGU_NEAR_ABS:
            if(circleMod!=FALSE)
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==-1)//����
                    {
                        float max=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        while(n<=peaktrough_nearside)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->value[k]>max)
                            {
                                max=peaktroughIn->value[k];
                            }
                        }
                        n=1;
                        while(n<=peaktrough_nearside)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->value[k]>max)
                            {
                                max=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]<=max-peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=-1;
                        }
                    }
                }
            }
            else
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==-1)//����
                    {
                        float max=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        while(n<=peaktrough_nearside)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                break;
                            if(peaktroughIn->value[k]>max)
                            {
                                max=peaktroughIn->value[k];
                            }
                        }
                        n=1;
                        while(n<=peaktrough_nearside)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                break;
                            if(peaktroughIn->value[k]>max)
                            {
                                max=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]<=max-peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=-1;
                        }
                    }
                }
            }
            break;
        case MHC_PEAKTROUGH_BOFENG_NEAR_PRESENT_ABS:
            if(circleMod!=FALSE)
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==1)//����
                    {
                        float min=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        while(n<=peaktrough_nearside)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->value[k]<min)
                            {
                                min=peaktroughIn->value[k];
                            }
                        }
                        n=1;
                        while(n<=peaktrough_nearside)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->value[k]<min)
                            {
                                min=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]>=min/peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=1;
                        }
                    }
                }
            }
            else
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==1)//����
                    {
                        float min=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        while(n<=peaktrough_nearside)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                break;
                            if(peaktroughIn->value[k]<min)
                            {
                                min=peaktroughIn->value[k];
                            }
                        }
                        n=1;
                        while(n<=peaktrough_nearside)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                break;
                            if(peaktroughIn->value[k]<min)
                            {
                                min=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]>=min/peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=1;
                        }
                    }
                }
            }
            break;
        case MHC_PEAKTROUGH_BOFENG_NEAR_ABS:
            if(circleMod!=FALSE)
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==1)//����
                    {
                        float min=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        while(n<=peaktrough_nearside)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->value[k]<min)
                            {
                                min=peaktroughIn->value[k];
                            }
                        }
                        n=1;
                        while(n<=peaktrough_nearside)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->value[k]<min)
                            {
                                min=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]>=min+peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=1;
                        }
                    }
                }
            }
            else
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==1)//����
                    {
                        float min=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        while(n<=peaktrough_nearside)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                break;
                            if(peaktroughIn->value[k]<min)
                            {
                                min=peaktroughIn->value[k];
                            }
                        }
                        n=1;
                        while(n<=peaktrough_nearside)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                break;
                            if(peaktroughIn->value[k]<min)
                            {
                                min=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]>=min+peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=1;
                        }
                    }
                }
            }
            break;

        case MHC_PEAKTROUGH_BOGU_NEAR2_PRESENT_ABS:
            if(circleMod!=FALSE)
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==-1)//����
                    {
                        float max=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        Int32 tempn=1;
                        Int32 Ltemp,Rtemp;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t-tempn;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->value[k]!=max)
                            {
                                Ltemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        tempn=1;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t+tempn;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->value[k]!=max)
                            {
                                Rtemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        n=Ltemp;
                        while(n<=peaktrough_nearside+Ltemp)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->value[k]>max)
                            {
                                max=peaktroughIn->value[k];
                            }
                        }
                        n=Rtemp;
                        while(n<=peaktrough_nearside+Rtemp)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->value[k]>max)
                            {
                                max=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]<=max*peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=-1;
                        }
                    }
                }
            }
            else
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==-1)//����
                    {
                        float max=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        Int32 tempn=1;
                        Int32 Ltemp,Rtemp;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t-tempn;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->value[k]!=max)
                            {
                                Ltemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        tempn=1;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t+tempn;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->value[k]!=max)
                            {
                                Rtemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        n=Ltemp;
                        while(n<=peaktrough_nearside+Ltemp)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                break;
                            if(peaktroughIn->value[k]>max)
                            {
                                max=peaktroughIn->value[k];
                            }
                        }
                        n=Rtemp;
                        while(n<=peaktrough_nearside+Rtemp)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                break;
                            if(peaktroughIn->value[k]>max)
                            {
                                max=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]<=max*peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=-1;
                        }
                    }
                }
            }
            break;
        case MHC_PEAKTROUGH_BOGU_NEAR2_ABS:
            if(circleMod!=FALSE)
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==-1)//����
                    {
                        float max=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        Int32 tempn=1;
                        Int32 Ltemp,Rtemp;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t-tempn;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->value[k]!=max)
                            {
                                Ltemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        tempn=1;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t+tempn;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->value[k]!=max)
                            {
                                Rtemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        n=Ltemp;
                        while(n<=peaktrough_nearside+Ltemp)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->value[k]>max)
                            {
                                max=peaktroughIn->value[k];
                            }
                        }
                        n=Rtemp;
                        while(n<=peaktrough_nearside+Rtemp)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->value[k]>max)
                            {
                                max=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]<=max-peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=-1;
                        }
                    }
                }
            }
            else
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==-1)//����
                    {
                        float max=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        Int32 tempn=1;
                        Int32 Ltemp,Rtemp;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t-tempn;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->value[k]!=max)
                            {
                                Ltemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        tempn=1;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t+tempn;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->value[k]!=max)
                            {
                                Rtemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        n=Ltemp;
                        while(n<=peaktrough_nearside+Ltemp)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                break;
                            if(peaktroughIn->value[k]>max)
                            {
                                max=peaktroughIn->value[k];
                            }
                        }
                        n=Rtemp;
                        while(n<=peaktrough_nearside+Rtemp)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                break;
                            if(peaktroughIn->value[k]>max)
                            {
                                max=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]<=max-peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=-1;
                        }
                    }
                }
            }
            break;
        case MHC_PEAKTROUGH_BOFENG_NEAR2_PRESENT_ABS:
            if(circleMod!=FALSE)
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==1)//����
                    {
                        float min=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        Int32 tempn=1;
                        Int32 Ltemp,Rtemp;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t-tempn;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->value[k]!=min)
                            {
                                Ltemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        tempn=1;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t+tempn;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->value[k]!=min)
                            {
                                Rtemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        n=Ltemp;
                        while(n<=peaktrough_nearside+Ltemp)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->value[k]<min)
                            {
                                min=peaktroughIn->value[k];
                            }
                        }
                        n=Rtemp;
                        while(n<=peaktrough_nearside+Rtemp)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->value[k]<min)
                            {
                                min=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]>=min/peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=1;
                        }
                    }
                }
            }
            else
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==1)//����
                    {
                        float min=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        Int32 tempn=1;
                        Int32 Ltemp,Rtemp;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t-tempn;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->value[k]!=min)
                            {
                                Ltemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        tempn=1;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t+tempn;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->value[k]!=min)
                            {
                                Rtemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        n=Ltemp;
                        while(n<=peaktrough_nearside+Ltemp)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                break;
                            if(peaktroughIn->value[k]<min)
                            {
                                min=peaktroughIn->value[k];
                            }
                        }
                        n=Rtemp;
                        while(n<=peaktrough_nearside+Rtemp)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                break;
                            if(peaktroughIn->value[k]<min)
                            {
                                min=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]>=min/peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=1;
                        }
                    }
                }
            }
            break;
        case MHC_PEAKTROUGH_BOFENG_NEAR2_ABS:
            if(circleMod!=FALSE)
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==1)//����
                    {
                        float min=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        Int32 tempn=1;
                        Int32 Ltemp,Rtemp;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t-tempn;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->value[k]!=min)
                            {
                                Ltemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        tempn=1;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t+tempn;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->value[k]!=min)
                            {
                                Rtemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        n=Ltemp;
                        while(n<=peaktrough_nearside+Ltemp)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->value[k]<min)
                            {
                                min=peaktroughIn->value[k];
                            }
                        }
                        n=Rtemp;
                        while(n<=peaktrough_nearside+Rtemp)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->value[k]<min)
                            {
                                min=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]>=min+peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=1;
                        }
                    }
                }
            }
            else
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==1)//����
                    {
                        float min=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        Int32 tempn=1;
                        Int32 Ltemp,Rtemp;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t-tempn;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->value[k]!=min)
                            {
                                Ltemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        tempn=1;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t+tempn;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->value[k]!=min)
                            {
                                Rtemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        n=Ltemp;
                        while(n<=peaktrough_nearside+Ltemp)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                break;
                            if(peaktroughIn->value[k]<min)
                            {
                                min=peaktroughIn->value[k];
                            }
                        }
                        n=Rtemp;
                        while(n<=peaktrough_nearside+Rtemp)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                break;
                            if(peaktroughIn->value[k]<min)
                            {
                                min=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]>=min+peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=1;
                        }
                    }
                }
            }
            break;
        case MHC_PEAKTROUGH_BOGU_TOWSIZENEAR_PRESENT_ABS:
            if(circleMod!=FALSE)
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==-1)//����
                    {
                        float max1=peaktroughIn->value[t];
                        float max2=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        while(n<=peaktrough_nearside)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->value[k]>max1)
                            {
                                max1=peaktroughIn->value[k];
                            }
                        }
                        n=1;
                        while(n<=peaktrough_nearside)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->value[k]>max2)
                            {
                                max2=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]<=max1*peaktrough_val&&peaktroughIn->value[t]<=max2*peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=-1;
                        }
                    }
                }
            }
            else
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==-1)//����
                    {
                        float max1=peaktroughIn->value[t];
                        float max2=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        while(n<=peaktrough_nearside)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                break;
                            if(peaktroughIn->value[k]>max1)
                            {
                                max1=peaktroughIn->value[k];
                            }
                        }
                        n=1;
                        while(n<=peaktrough_nearside)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                break;
                            if(peaktroughIn->value[k]>max2)
                            {
                                max2=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]<=max1*peaktrough_val&&peaktroughIn->value[t]<=max2*peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=-1;
                        }
                    }
                }
            }
            break;
        case MHC_PEAKTROUGH_BOGU_TOWSIZENEAR_ABS:
            if(circleMod!=FALSE)
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==-1)//����
                    {
                        float max1=peaktroughIn->value[t];
                        float max2=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        while(n<=peaktrough_nearside)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->value[k]>max1)
                            {
                                max1=peaktroughIn->value[k];
                            }
                        }
                        n=1;
                        while(n<=peaktrough_nearside)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->value[k]>max2)
                            {
                                max2=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]<=max1-peaktrough_val&&peaktroughIn->value[t]<=max2-peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=-1;
                        }
                    }
                }
            }
            else
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==-1)//����
                    {
                        float max1=peaktroughIn->value[t];
                        float max2=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        while(n<=peaktrough_nearside)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                break;
                            if(peaktroughIn->value[k]>max1)
                            {
                                max1=peaktroughIn->value[k];
                            }
                        }
                        n=1;
                        while(n<=peaktrough_nearside)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                break;
                            if(peaktroughIn->value[k]>max2)
                            {
                                max2=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]<=max1-peaktrough_val&&peaktroughIn->value[t]<=max2-peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=-1;
                        }
                    }
                }
            }
            break;
        case MHC_PEAKTROUGH_BOFENG_TOWSIZENEAR_PRESENT_ABS:
            if(circleMod!=FALSE)
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==1)//����
                    {
                        float min1=peaktroughIn->value[t];
                        float min2=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        while(n<=peaktrough_nearside)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->value[k]<min1)
                            {
                                min1=peaktroughIn->value[k];
                            }
                        }
                        n=1;
                        while(n<=peaktrough_nearside)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->value[k]<min2)
                            {
                                min2=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]>=min1/peaktrough_val&&peaktroughIn->value[t]>=min2/peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=1;
                        }
                    }
                }
            }
            else
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==1)//����
                    {
                        float min1=peaktroughIn->value[t];
                        float min2=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        while(n<=peaktrough_nearside)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                break;
                            if(peaktroughIn->value[k]<min1)
                            {
                                min1=peaktroughIn->value[k];
                            }
                        }
                        n=1;
                        while(n<=peaktrough_nearside)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                break;
                            if(peaktroughIn->value[k]<min2)
                            {
                                min2=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]>=min1/peaktrough_val&&peaktroughIn->value[t]>=min2/peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=1;
                        }
                    }
                }
            }
            break;
        case MHC_PEAKTROUGH_BOFENG_TOWSIZENEAR_ABS:
            if(circleMod!=FALSE)
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==1)//����
                    {
                        float min1=peaktroughIn->value[t];
                        float min2=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        while(n<=peaktrough_nearside)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->value[k]<min1)
                            {
                                min1=peaktroughIn->value[k];
                            }
                        }
                        n=1;
                        while(n<=peaktrough_nearside)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->value[k]<min2)
                            {
                                min2=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]>=min1+peaktrough_val&&peaktroughIn->value[t]>=min2+peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=1;
                        }
                    }
                }
            }
            else
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==1)//����
                    {
                        float min1=peaktroughIn->value[t];
                        float min2=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        while(n<=peaktrough_nearside)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                break;
                            if(peaktroughIn->value[k]<min1)
                            {
                                min1=peaktroughIn->value[k];
                            }
                        }
                        n=1;
                        while(n<=peaktrough_nearside)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                break;
                            if(peaktroughIn->value[k]<min2)
                            {
                                min2=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]>=min1+peaktrough_val&&peaktroughIn->value[t]>=min2+peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=1;
                        }
                    }
                }
            }
            break;
        case MHC_PEAKTROUGH_BOGU_TOWSIZENEAR2_PRESENT_ABS:
            if(circleMod!=FALSE)
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==-1)//����
                    {
                        float max1=peaktroughIn->value[t];
                        float max2=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        Int32 tempn=1;
                        Int32 Ltemp,Rtemp;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t-tempn;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->value[k]!=max1)
                            {
                                Ltemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        tempn=1;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t+tempn;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->value[k]!=max2)
                            {
                                Rtemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        n=Ltemp;
                        while(n<=peaktrough_nearside+Ltemp)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->value[k]>max1)
                            {
                                max1=peaktroughIn->value[k];
                            }
                        }
                        n=Rtemp;
                        while(n<=peaktrough_nearside+Rtemp)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->value[k]>max2)
                            {
                                max2=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]<=max1*peaktrough_val&&peaktroughIn->value[t]<=max2*peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=-1;
                        }
                    }
                }
            }
            else
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==-1)//����
                    {
                        float max1=peaktroughIn->value[t];
                        float max2=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        Int32 tempn=1;
                        Int32 Ltemp,Rtemp;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t-tempn;
                            if(k<0)
                            {
                                Ltemp=tempn;
                                break;
                            }
                            if(peaktroughIn->value[k]!=max1)
                            {
                                Ltemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        tempn=1;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t+tempn;
                            if(k>=valuenum)
                            {
                                Rtemp=tempn;
                                break;
                            }
                            if(peaktroughIn->value[k]!=max2)
                            {
                                Rtemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        n=Ltemp;
                        while(n<=peaktrough_nearside+Ltemp)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                break;
                            if(peaktroughIn->value[k]>max1)
                            {
                                max1=peaktroughIn->value[k];
                            }
                        }
                        n=Rtemp;
                        while(n<=peaktrough_nearside+Rtemp)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                break;
                            if(peaktroughIn->value[k]>max2)
                            {
                                max2=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]<=max1*peaktrough_val&&peaktroughIn->value[t]<=max2*peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=-1;
                        }
                    }
                }
            }
            break;
        case MHC_PEAKTROUGH_BOGU_TOWSIZENEAR2_ABS:
            if(circleMod!=FALSE)
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==-1)//����
                    {
                        float max1=peaktroughIn->value[t];
                        float max2=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        Int32 tempn=1;
                        Int32 Ltemp,Rtemp;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t-tempn;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->value[k]!=max1)
                            {
                                Ltemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        tempn=1;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t+tempn;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->value[k]!=max2)
                            {
                                Rtemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        n=Ltemp;
                        while(n<=peaktrough_nearside+Ltemp)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->value[k]>max1)
                            {
                                max1=peaktroughIn->value[k];
                            }
                        }
                        n=Rtemp;
                        while(n<=peaktrough_nearside+Rtemp)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->value[k]>max2)
                            {
                                max2=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]<=max1-peaktrough_val&&peaktroughIn->value[t]<=max2-peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=-1;
                        }
                    }
                }
            }
            else
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==-1)//����
                    {
                        float max1=peaktroughIn->value[t];
                        float max2=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        Int32 tempn=1;
                        Int32 Ltemp,Rtemp;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t-tempn;
                            if(k<0)
                            {
                                Ltemp=tempn;
                                break;
                            }
                            if(peaktroughIn->value[k]!=max1)
                            {
                                Ltemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        tempn=1;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t+tempn;
                            if(k>=valuenum)
                            {
                                Rtemp=tempn;
                                break;
                            }
                            if(peaktroughIn->value[k]!=max2)
                            {
                                Rtemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        n=Ltemp;
                        while(n<=peaktrough_nearside+Ltemp)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                break;
                            if(peaktroughIn->value[k]>max1)
                            {
                                max1=peaktroughIn->value[k];
                            }
                        }
                        n=Rtemp;
                        while(n<=peaktrough_nearside+Rtemp)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                break;
                            if(peaktroughIn->value[k]>max2)
                            {
                                max2=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]<=max1-peaktrough_val&&peaktroughIn->value[t]<=max2-peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=-1;
                        }
                    }
                }
            }
            break;
        case MHC_PEAKTROUGH_BOFENG_TOWSIZENEAR2_PRESENT_ABS:
            if(circleMod!=FALSE)
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==1)//����
                    {
                        float min1=peaktroughIn->value[t];
                        float min2=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        Int32 tempn=1;
                        Int32 Ltemp,Rtemp;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t-tempn;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->value[k]!=min1)
                            {
                                Ltemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        tempn=1;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t+tempn;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->value[k]!=min2)
                            {
                                Rtemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        n=Ltemp;
                        while(n<=peaktrough_nearside+Ltemp)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->value[k]<min1)
                            {
                                min1=peaktroughIn->value[k];
                            }
                        }
                        n=Rtemp;
                        while(n<=peaktrough_nearside+Rtemp)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->value[k]<min2)
                            {
                                min2=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]>=min1/peaktrough_val&&peaktroughIn->value[t]>=min2/peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=1;
                        }
                    }
                }
            }
            else
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==1)//����
                    {
                        float min1=peaktroughIn->value[t];
                        float min2=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        Int32 tempn=1;
                        Int32 Ltemp,Rtemp;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t-tempn;
                            if(k<0)
                            {
                                Ltemp=tempn;
                                break;
                            }
                            if(peaktroughIn->value[k]!=min1)
                            {
                                Ltemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        tempn=1;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t+tempn;
                            if(k>=valuenum)
                            {
                                Rtemp=tempn;
                                break;
                            }
                            if(peaktroughIn->value[k]!=min2)
                            {
                                Rtemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        n=Ltemp;
                        while(n<=peaktrough_nearside+Ltemp)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                break;
                            if(peaktroughIn->value[k]<min1)
                            {
                                min1=peaktroughIn->value[k];
                            }
                        }
                        n=Rtemp;
                        while(n<=peaktrough_nearside+Rtemp)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                break;
                            if(peaktroughIn->value[k]<min2)
                            {
                                min2=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]>=min1/peaktrough_val&&peaktroughIn->value[t]>=min2/peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=1;
                        }
                    }
                }
            }
            break;
        case MHC_PEAKTROUGH_BOFENG_TOWSIZENEAR2_ABS:
            if(circleMod!=FALSE)
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==1)//����
                    {
                        float min1=peaktroughIn->value[t];
                        float min2=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        Int32 tempn=1;
                        Int32 Ltemp,Rtemp;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t-tempn;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->value[k]!=min1)
                            {
                                Ltemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        tempn=1;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t+tempn;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->value[k]!=min2)
                            {
                                Rtemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        n=Ltemp;
                        while(n<=peaktrough_nearside+Ltemp)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->value[k]<min1)
                            {
                                min1=peaktroughIn->value[k];
                            }
                        }
                        n=Rtemp;
                        while(n<=peaktrough_nearside+Rtemp)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->value[k]<min2)
                            {
                                min2=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]>=min1+peaktrough_val&&peaktroughIn->value[t]>=min2+peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=1;
                        }
                    }
                }
            }
            else
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==1)//����
                    {
                        float min1=peaktroughIn->value[t];
                        float min2=peaktroughIn->value[t];
                        Int32 n=1;
                        Int32 k;
                        Int32 tempn=1;
                        Int32 Ltemp,Rtemp;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t-tempn;
                            if(k<0)
                            {
                                Ltemp=tempn;
                                break;
                            }
                            if(peaktroughIn->value[k]!=min1)
                            {
                                Ltemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        tempn=1;
                        while(tempn<peaktroughIn->valuenum)
                        {
                            k=t+tempn;
                            if(k>=valuenum)
                            {
                                Rtemp=tempn;
                                break;
                            }
                            if(peaktroughIn->value[k]!=min2)
                            {
                                Rtemp=tempn;
                                break;
                            }
                            tempn++;
                        }
                        n=Ltemp;
                        while(n<=peaktrough_nearside+Ltemp)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                break;
                            if(peaktroughIn->value[k]<min1)
                            {
                                min1=peaktroughIn->value[k];
                            }
                        }
                        n=Rtemp;
                        while(n<=peaktrough_nearside+Rtemp)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                break;
                            if(peaktroughIn->value[k]<min2)
                            {
                                min2=peaktroughIn->value[k];
                            }
                        }
                        if(peaktroughIn->value[t]>=min1+peaktrough_val&&peaktroughIn->value[t]>=min2+peaktrough_val)
                        {
                            peaktroughOut->valpeaktrough[t]=1;
                        }
                    }
                }
            }
            break;
        default:
            return 1;
            break;
        }
        return 0;
    }

    Int8 Myselect_peaktrough_2(Peak_Trough *peaktroughIn,Peak_Trough *peaktroughOut,peakselecttype_2 Mod,Int32 peaktrough_val,Bool circleMod)
    {
        Int32 valuenum=peaktroughIn->valuenum;
        Int32 t;
        peaktroughOut->valuenum=valuenum;
        memcpy(peaktroughOut->value,peaktroughIn->value,valuenum*sizeof(Int32));
        memset(peaktroughOut->valpeaktrough,0,sizeof(Int8)*valuenum);
        switch(Mod)
        {
        case MHC_PEAKTROUGH_BOGU_ABS:
            if(circleMod!=FALSE)
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==-1)//����
                    {
                        Int32 n=1;
                        Int32 k;
                        Bool left=FALSE;
                        Bool right=FALSE;
                        while(n<valuenum)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->valpeaktrough[k]==1)//����
                                break;
                        }
                        if(peaktroughIn->value[k]-peaktroughIn->value[t]>peaktrough_val)
                        {
                            left=TRUE;
                        }
                        n=1;
                        while(n<valuenum)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->valpeaktrough[k]==1)//����
                                break;
                        }
                        if(peaktroughIn->value[k]-peaktroughIn->value[t]>peaktrough_val)
                        {
                            right=TRUE;
                        }
                        if(left==TRUE&&right==TRUE)
                        {
                            peaktroughOut->valpeaktrough[t]=-1;
                        }
                    }
                }
            }
            else
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==-1)//����
                    {
                        Int32 n=t-1;
                        Bool left=FALSE;
                        Bool right=FALSE;
                        while(n>=0)
                        {
                            if(peaktroughIn->valpeaktrough[n]==1)//����
                                break;
                            n--;
                        }
                        if(peaktroughIn->value[n]-peaktroughIn->value[t]>peaktrough_val)
                        {
                            left=TRUE;
                        }
                        n=t+1;
                        while(n<valuenum)
                        {
                            if(peaktroughIn->valpeaktrough[n]==1)//����
                                break;
                            n++;
                        }
                        if(peaktroughIn->value[n]-peaktroughIn->value[t]>peaktrough_val)
                        {
                            right=TRUE;
                        }
                        if(left==TRUE&&right==TRUE)
                        {
                            peaktroughOut->valpeaktrough[t]=-1;
                        }
                    }
                }
            }
            break;
        case MHC_PEAKTROUGH_BOGU_ONESIDE:
            if(circleMod!=FALSE)
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==-1)//����
                    {
                        Int32 n=1;
                        Int32 k;
                        Bool left=FALSE;
                        Bool right=FALSE;
                        while(n<valuenum)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->valpeaktrough[k]==1)//����
                                break;
                        }
                        if(peaktroughIn->value[k]-peaktroughIn->value[t]>peaktrough_val)
                        {
                            left=TRUE;
                        }
                        n=1;
                        while(n<valuenum)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->valpeaktrough[k]==1)//����
                                break;
                        }
                        if(peaktroughIn->value[k]-peaktroughIn->value[t]>peaktrough_val)
                        {
                            right=TRUE;
                        }
                        if(left==TRUE||right==TRUE)
                        {
                            peaktroughOut->valpeaktrough[t]=-1;
                        }
                    }
                }
            }
            else
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==-1)//����
                    {
                        Int32 n=t-1;
                        Bool left=FALSE;
                        Bool right=FALSE;
                        while(n>=0)
                        {
                            if(peaktroughIn->valpeaktrough[n]==1)//����
                                break;
                            n--;
                        }
                        if(peaktroughIn->value[n]-peaktroughIn->value[t]>peaktrough_val)
                        {
                            left=TRUE;
                        }
                        n=t+1;
                        while(n<valuenum)
                        {
                            if(peaktroughIn->valpeaktrough[n]==1)//����
                                break;
                            n++;
                        }
                        if(peaktroughIn->value[n]-peaktroughIn->value[t]>peaktrough_val)
                        {
                            right=TRUE;
                        }
                        if(left==TRUE||right==TRUE)
                        {
                            peaktroughOut->valpeaktrough[t]=-1;
                        }
                    }
                }
            }
        case MHC_PEAKTROUGH_BOFENG_ABS:
            if(circleMod!=FALSE)
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==1)//����
                    {
                        Int32 n=1;
                        Int32 k;
                        Bool left=FALSE;
                        Bool right=FALSE;
                        while(n<valuenum)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->valpeaktrough[k]==-1)//����
                                break;
                        }
                        if(peaktroughIn->value[t]-peaktroughIn->value[k]>peaktrough_val)
                        {
                            left=TRUE;
                        }
                        n=1;
                        while(n<valuenum)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->valpeaktrough[k]==-1)//����
                                break;
                        }
                        if(peaktroughIn->value[t]-peaktroughIn->value[k]>peaktrough_val)
                        {
                            right=TRUE;
                        }
                        if(left==TRUE&&right==TRUE)
                        {
                            peaktroughOut->valpeaktrough[t]=1;
                        }
                    }
                }
            }
            else
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==1)//����
                    {
                        Int32 n=t-1;
                        Bool left=FALSE;
                        Bool right=FALSE;
                        while(n>=0)
                        {
                            if(peaktroughIn->valpeaktrough[n]==-1)//����
                                break;
                            n--;
                        }
                        if(peaktroughIn->value[t]-peaktroughIn->value[n]>peaktrough_val)
                        {
                            left=TRUE;
                        }
                        n=t+1;
                        while(n<valuenum)
                        {
                            if(peaktroughIn->valpeaktrough[n]==-1)//����
                                break;
                            n++;
                        }
                        if(peaktroughIn->value[t]-peaktroughIn->value[n]>peaktrough_val)
                        {
                            right=TRUE;
                        }
                        if(left==TRUE&&right==TRUE)
                        {
                            peaktroughOut->valpeaktrough[t]=1;
                        }
                    }
                }
            }
            break;
        case MHC_PEAKTROUGH_BOFENG_ONESIDE:
            if(circleMod!=FALSE)
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==1)//����
                    {
                        Int32 n=1;
                        Int32 k;
                        Bool left=FALSE;
                        Bool right=FALSE;
                        while(n<valuenum)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->valpeaktrough[k]==-1)//����
                                break;
                        }
                        if(peaktroughIn->value[t]-peaktroughIn->value[k]>peaktrough_val)
                        {
                            left=TRUE;
                        }
                        n=1;
                        while(n<valuenum)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->valpeaktrough[k]==-1)//����
                                break;
                        }
                        if(peaktroughIn->value[t]-peaktroughIn->value[k]>peaktrough_val)
                        {
                            right=TRUE;
                        }
                        if(left==TRUE||right==TRUE)
                        {
                            peaktroughOut->valpeaktrough[t]=1;
                        }
                    }
                }
            }
            else
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==1)//���塤
                    {
                        Int32 n=t-1;
                        Bool left=FALSE;
                        Bool right=FALSE;
                        while(n>=0)
                        {
                            if(peaktroughIn->valpeaktrough[n]==-1)//����
                                break;
                            n--;
                        }
                        if(peaktroughIn->value[t]-peaktroughIn->value[n]>peaktrough_val)
                        {
                            left=TRUE;
                        }
                        n=t+1;
                        while(n<valuenum)
                        {
                            if(peaktroughIn->valpeaktrough[n]==-1)//����
                                break;
                            n++;
                        }
                        if(peaktroughIn->value[t]-peaktroughIn->value[n]>peaktrough_val)
                        {
                            right=TRUE;
                        }
                        if(left==TRUE||right==TRUE)
                        {
                            peaktroughOut->valpeaktrough[t]=1;
                        }
                    }
                }
            }
            break;
        default:
            return 1;
            break;
        }
        return 0;
    }

    Int8 Myselect_peaktrough_232FC(Peak_Trough32FC *peaktroughIn,Peak_Trough32FC *peaktroughOut,peakselecttype_2 Mod,float peaktrough_val, Bool circleMod)
    {
        Int32 valuenum=peaktroughIn->valuenum;
        Int32 t;
        peaktroughOut->valuenum=valuenum;
        memcpy(peaktroughOut->value,peaktroughIn->value,valuenum*sizeof(float));
        memset(peaktroughOut->valpeaktrough,0,sizeof(Int8)*valuenum);
        switch(Mod)
        {
        case MHC_PEAKTROUGH_BOGU_ABS:
            if(circleMod!=FALSE)
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==-1)//����
                    {
                        Int32 n=1;
                        Int32 k;
                        Bool left=FALSE;
                        Bool right=FALSE;
                        while(n<valuenum)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->valpeaktrough[k]==1)//����
                                break;
                        }
                        if(peaktroughIn->value[k]-peaktroughIn->value[t]>peaktrough_val)
                        {
                            left=TRUE;
                        }
                        n=1;
                        while(n<valuenum)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->valpeaktrough[k]==1)//����
                                break;
                        }
                        if(peaktroughIn->value[k]-peaktroughIn->value[t]>peaktrough_val)
                        {
                            right=TRUE;
                        }
                        if(left==TRUE&&right==TRUE)
                        {
                            peaktroughOut->valpeaktrough[t]=-1;
                        }
                    }
                }
            }
            else
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==-1)//����
                    {
                        Int32 n=t-1;
                        Bool left=FALSE;
                        Bool right=FALSE;
                        while(n>=0)
                        {
                            if(peaktroughIn->valpeaktrough[n]==1)//����
                                break;
                            n--;
                        }
                        if(peaktroughIn->value[n]-peaktroughIn->value[t]>peaktrough_val)
                        {
                            left=TRUE;
                        }
                        n=t+1;
                        while(n<valuenum)
                        {
                            if(peaktroughIn->valpeaktrough[n]==1)//����
                                break;
                            n++;
                        }
                        if(peaktroughIn->value[n]-peaktroughIn->value[t]>peaktrough_val)
                        {
                            right=TRUE;
                        }
                        if(left==TRUE&&right==TRUE)
                        {
                            peaktroughOut->valpeaktrough[t]=-1;
                        }
                    }
                }
            }
            break;
        case MHC_PEAKTROUGH_BOGU_ONESIDE:
            if(circleMod!=FALSE)
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==-1)//����
                    {
                        Int32 n=1;
                        Int32 k;
                        Bool left=FALSE;
                        Bool right=FALSE;
                        while(n<valuenum)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->valpeaktrough[k]==1)//����
                                break;
                        }
                        if(peaktroughIn->value[k]-peaktroughIn->value[t]>peaktrough_val)
                        {
                            left=TRUE;
                        }
                        n=1;
                        while(n<valuenum)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->valpeaktrough[k]==1)//����
                                break;
                        }
                        if(peaktroughIn->value[k]-peaktroughIn->value[t]>peaktrough_val)
                        {
                            right=TRUE;
                        }
                        if(left==TRUE||right==TRUE)
                        {
                            peaktroughOut->valpeaktrough[t]=-1;
                        }
                    }
                }
            }
            else
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==-1)//����
                    {
                        Int32 n=t-1;
                        Bool left=FALSE;
                        Bool right=FALSE;
                        while(n>=0)
                        {
                            if(peaktroughIn->valpeaktrough[n]==1)//����
                                break;
                            n--;
                        }
                        if(peaktroughIn->value[n]-peaktroughIn->value[t]>peaktrough_val)
                        {
                            left=TRUE;
                        }
                        n=t+1;
                        while(n<valuenum)
                        {
                            if(peaktroughIn->valpeaktrough[n]==1)//����
                                break;
                            n++;
                        }
                        if(peaktroughIn->value[n]-peaktroughIn->value[t]>peaktrough_val)
                        {
                            right=TRUE;
                        }
                        if(left==TRUE||right==TRUE)
                        {
                            peaktroughOut->valpeaktrough[t]=-1;
                        }
                    }
                }
            }
        case MHC_PEAKTROUGH_BOFENG_ABS:
            if(circleMod!=FALSE)
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==1)//����
                    {
                        Int32 n=1;
                        Int32 k;
                        Bool left=FALSE;
                        Bool right=FALSE;
                        while(n<valuenum)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->valpeaktrough[k]==-1)//����
                                break;
                        }
                        if(peaktroughIn->value[t]-peaktroughIn->value[k]>peaktrough_val)
                        {
                            left=TRUE;
                        }
                        n=1;
                        while(n<valuenum)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->valpeaktrough[k]==-1)//����
                                break;
                        }
                        if(peaktroughIn->value[t]-peaktroughIn->value[k]>peaktrough_val)
                        {
                            right=TRUE;
                        }
                        if(left==TRUE&&right==TRUE)
                        {
                            peaktroughOut->valpeaktrough[t]=1;
                        }
                    }
                }
            }
            else
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==1)//����
                    {
                        Int32 n=t-1;
                        Bool left=FALSE;
                        Bool right=FALSE;
                        while(n>=0)
                        {
                            if(peaktroughIn->valpeaktrough[n]==-1)//����
                                break;
                            n--;
                        }
                        if(peaktroughIn->value[t]-peaktroughIn->value[n]>peaktrough_val)
                        {
                            left=TRUE;
                        }
                        n=t+1;
                        while(n<valuenum)
                        {
                            if(peaktroughIn->valpeaktrough[n]==-1)//����
                                break;
                            n++;
                        }
                        if(peaktroughIn->value[t]-peaktroughIn->value[n]>peaktrough_val)
                        {
                            right=TRUE;
                        }
                        if(left==TRUE&&right==TRUE)
                        {
                            peaktroughOut->valpeaktrough[t]=1;
                        }
                    }
                }
            }
            break;
        case MHC_PEAKTROUGH_BOFENG_ONESIDE:
            if(circleMod!=FALSE)
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==1)//����
                    {
                        Int32 n=1;
                        Int32 k;
                        Bool left=FALSE;
                        Bool right=FALSE;
                        while(n<valuenum)
                        {
                            k=t-n;
                            n++;
                            if(k<0)
                                k=k+valuenum;
                            if(peaktroughIn->valpeaktrough[k]==-1)//����
                                break;
                        }
                        if(peaktroughIn->value[t]-peaktroughIn->value[k]>peaktrough_val)
                        {
                            left=TRUE;
                        }
                        n=1;
                        while(n<valuenum)
                        {
                            k=t+n;
                            n++;
                            if(k>=valuenum)
                                k=k-valuenum;
                            if(peaktroughIn->valpeaktrough[k]==-1)//����
                                break;
                        }
                        if(peaktroughIn->value[t]-peaktroughIn->value[k]>peaktrough_val)
                        {
                            right=TRUE;
                        }
                        if(left==TRUE||right==TRUE)
                        {
                            peaktroughOut->valpeaktrough[t]=1;
                        }
                    }
                }
            }
            else
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==1)//���塤
                    {
                        Int32 n=t-1;
                        Bool left=FALSE;
                        Bool right=FALSE;
                        while(n>=0)
                        {
                            if(peaktroughIn->valpeaktrough[n]==-1)//����
                                break;
                            n--;
                        }
                        if(peaktroughIn->value[t]-peaktroughIn->value[n]>peaktrough_val)
                        {
                            left=TRUE;
                        }
                        n=t+1;
                        while(n<valuenum)
                        {
                            if(peaktroughIn->valpeaktrough[n]==-1)//����
                                break;
                            n++;
                        }
                        if(peaktroughIn->value[t]-peaktroughIn->value[n]>peaktrough_val)
                        {
                            right=TRUE;
                        }
                        if(left==TRUE||right==TRUE)
                        {
                            peaktroughOut->valpeaktrough[t]=1;
                        }
                    }
                }
            }
            break;
        default:
            return 1;
            break;
        }
        return 0;
    }

    Int8 Mylvbo1size_peaktrough(Peak_Trough *peaktroughIn,Peak_Trough *peaktroughOut,peaklvbotype Mod,Bool circleMod)
    {
        Int32 valuenum=peaktroughIn->valuenum;
        Int32 n;
        peaktroughOut->valuenum=valuenum;
        memcpy(peaktroughOut->value,peaktroughIn->value,valuenum*sizeof(Int32));
        memcpy(peaktroughOut->valpeaktrough,peaktroughIn->valpeaktrough,sizeof(Int8)*valuenum);
        switch(Mod)
        {
        case MHC_PEAKTROUGH_BOFENG_LVBO://�����˲���ȥ�������Ĳ��壩
            for(n=0;n<valuenum;n++)
            {
                if(peaktroughOut->valpeaktrough[n]==1)
                {
                    Int32 lk=n-1;
                    Int32 rk=n+1;
                    if(circleMod!=FALSE)
                    {
                        if(lk<0)
                            lk=lk+valuenum;
                        if(lk>=valuenum)
                            lk=lk-valuenum;
                        if(rk<0)
                            rk=rk+valuenum;
                        if(rk>=valuenum)
                            rk=rk-valuenum;
                        if(peaktroughOut->valpeaktrough[lk]==-1&&peaktroughOut->valpeaktrough[rk]==-1)//���඼����
                        {
                            Int32 valuelk=peaktroughIn->value[lk];
                            Int32 valuerk=peaktroughIn->value[rk];
                            Int32 value=valuelk;
                            peaktroughOut->valpeaktrough[n]=-1;
                            if(value>valuerk)
                                value=valuerk;
                            peaktroughOut->value[n]=value;
                        }
                    }
                    else
                    {
                        if(lk<0)
                            lk=0;
                        if(lk>=valuenum)
                            lk=valuenum-1;
                        if(rk<0)
                            rk=0;
                        if(rk>=valuenum)
                            rk=valuenum-1;
                        if(peaktroughOut->valpeaktrough[lk]==-1&&peaktroughOut->valpeaktrough[rk]==-1)//���඼����
                        {

                            Int32 valuelk=peaktroughIn->value[lk];
                            Int32 valuerk=peaktroughIn->value[rk];
                            Int32 value=valuelk;
                            peaktroughOut->valpeaktrough[n]=-1;
                            if(value>valuerk)
                                value=valuerk;
                            peaktroughOut->value[n]=value;
                        }
                    }
                }
            }
            break;
        case MHC_PEAKTROUGH_BOGU_LVBO://�����˲���ȥ�������Ĳ��ȣ�
            for(n=0;n<valuenum;n++)
            {
                if(peaktroughOut->valpeaktrough[n]==-1)
                {
                    Int32 lk=n-1;
                    Int32 rk=n+1;
                    if(circleMod!=FALSE)
                    {
                        if(lk<0)
                            lk=lk+valuenum;
                        if(lk>=valuenum)
                            lk=lk-valuenum;
                        if(rk<0)
                            rk=rk+valuenum;
                        if(rk>=valuenum)
                            rk=rk-valuenum;
                        if(peaktroughOut->valpeaktrough[lk]==1&&peaktroughOut->valpeaktrough[rk]==1)//���඼����
                        {
                            Int32 valuelk=peaktroughIn->value[lk];
                            Int32 valuerk=peaktroughIn->value[rk];
                            Int32 value=valuelk;
                            peaktroughOut->valpeaktrough[n]=1;
                            if(value<valuerk)
                                value=valuerk;
                            peaktroughOut->value[n]=value;
                        }
                    }
                    else
                    {
                        if(lk<0)
                            lk=0;
                        if(lk>=valuenum)
                            lk=valuenum-1;
                        if(rk<0)
                            rk=0;
                        if(rk>=valuenum)
                            rk=valuenum-1;
                        if(peaktroughOut->valpeaktrough[lk]==1&&peaktroughOut->valpeaktrough[rk]==1)//���඼����
                        {
                            Int32 valuelk=peaktroughIn->value[lk];
                            Int32 valuerk=peaktroughIn->value[rk];
                            Int32 value=valuelk;
                            peaktroughOut->valpeaktrough[n]=1;
                            if(value<valuerk)
                                value=valuerk;
                            peaktroughOut->value[n]=value;
                        }
                    }
                }
            }
            break;
        default:
            return 1;
            break;
        }
        return 0;
    }

    Int8 Mylvbo1size_peaktrough32FC(Peak_Trough32FC *peaktroughIn,Peak_Trough32FC *peaktroughOut,peaklvbotype Mod,Bool circleMod)
    {
        Int32 valuenum=peaktroughIn->valuenum;
        Int32 n;
        peaktroughOut->valuenum=valuenum;
        memcpy(peaktroughOut->value,peaktroughIn->value,valuenum*sizeof(float));
        memcpy(peaktroughOut->valpeaktrough,peaktroughIn->valpeaktrough,sizeof(Int8)*valuenum);
        switch(Mod)
        {
        case MHC_PEAKTROUGH_BOFENG_LVBO://�����˲���ȥ�������Ĳ��壩
            for(n=0;n<valuenum;n++)
            {
                if(peaktroughOut->valpeaktrough[n]==1)
                {
                    Int32 lk=n-1;
                    Int32 rk=n+1;
                    if(circleMod!=FALSE)
                    {
                        if(lk<0)
                            lk=lk+valuenum;
                        if(lk>=valuenum)
                            lk=lk-valuenum;
                        if(rk<0)
                            rk=rk+valuenum;
                        if(rk>=valuenum)
                            rk=rk-valuenum;
                        if(peaktroughOut->valpeaktrough[lk]==-1&&peaktroughOut->valpeaktrough[rk]==-1)//���඼����
                        {
                            float valuelk=peaktroughIn->value[lk];
                            float valuerk=peaktroughIn->value[rk];
                            float value=valuelk;
                            peaktroughOut->valpeaktrough[n]=-1;
                            if(value>valuerk)
                                value=valuerk;
                            peaktroughOut->value[n]=value;
                        }
                    }
                    else
                    {
                        if(lk<0)
                            lk=0;
                        if(lk>=valuenum)
                            lk=valuenum-1;
                        if(rk<0)
                            rk=0;
                        if(rk>=valuenum)
                            rk=valuenum-1;
                        if(peaktroughOut->valpeaktrough[lk]==-1&&peaktroughOut->valpeaktrough[rk]==-1)//���඼����
                        {

                            float valuelk=peaktroughIn->value[lk];
                            float valuerk=peaktroughIn->value[rk];
                            float value=valuelk;
                            peaktroughOut->valpeaktrough[n]=-1;
                            if(value>valuerk)
                                value=valuerk;
                            peaktroughOut->value[n]=value;
                        }
                    }
                }
            }
            break;
        case MHC_PEAKTROUGH_BOGU_LVBO://�����˲���ȥ�������Ĳ��ȣ�
            for(n=0;n<valuenum;n++)
            {
                if(peaktroughOut->valpeaktrough[n]==-1)
                {
                    Int32 lk=n-1;
                    Int32 rk=n+1;
                    if(circleMod!=FALSE)
                    {
                        if(lk<0)
                            lk=lk+valuenum;
                        if(lk>=valuenum)
                            lk=lk-valuenum;
                        if(rk<0)
                            rk=rk+valuenum;
                        if(rk>=valuenum)
                            rk=rk-valuenum;
                        if(peaktroughOut->valpeaktrough[lk]==1&&peaktroughOut->valpeaktrough[rk]==1)//���඼����
                        {
                            float valuelk=peaktroughIn->value[lk];
                            float valuerk=peaktroughIn->value[rk];
                            float value=valuelk;
                            peaktroughOut->valpeaktrough[n]=1;
                            if(value<valuerk)
                                value=valuerk;
                            peaktroughOut->value[n]=value;
                        }
                    }
                    else
                    {
                        if(lk<0)
                            lk=0;
                        if(lk>=valuenum)
                            lk=valuenum-1;
                        if(rk<0)
                            rk=0;
                        if(rk>=valuenum)
                            rk=valuenum-1;
                        if(peaktroughOut->valpeaktrough[lk]==1&&peaktroughOut->valpeaktrough[rk]==1)//���඼����
                        {
                            float valuelk=peaktroughIn->value[lk];
                            float valuerk=peaktroughIn->value[rk];
                            float value=valuelk;
                            peaktroughOut->valpeaktrough[n]=1;
                            if(value<valuerk)
                                value=valuerk;
                            peaktroughOut->value[n]=value;
                        }
                    }
                }
            }
            break;
        default:
            return 1;
            break;
        }
        return 0;
    }

    Int8 Mywatershed_peaktrough(Peak_Trough *peaktroughIn,watershed *datawaterIn_Out,Int32 waterheight,Int32 waterwidth,peakwatertype Mod,Bool circleMod)
    {
        Int32 t;
        Int32 valuenum=peaktroughIn->valuenum;

        memset(datawaterIn_Out,0,sizeof(watershed)*valuenum);

        switch(Mod)
        {
        case MHC_PEAKTROUGH_BOGU_WATER:
            if(circleMod!=FALSE)
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==-1)
                    {
                        Int32 nLeftMax=-1;
                        Int32 nRightMax=-1;
                        Int32 allMaxTemp;
                        Int32 allMax;
                        Int32 n=1;
                        Int32 k;
                        Int32 sun=0;
                        Int16 width=1;
                        while(n<waterwidth)
                        {
                            k=t-n;
                            if(k<0)
                                k=k+valuenum;
                            if(nLeftMax<peaktroughIn->value[k])
                                nLeftMax=peaktroughIn->value[k];
                            n++;
                        }
                        n=1;
                        while(n<waterwidth)
                        {
                            k=t+n;
                            if(k>valuenum)
                                k=k-valuenum;
                            if(nRightMax<peaktroughIn->value[k])
                                nRightMax=peaktroughIn->value[k];
                            n++;
                        }
                        if(nLeftMax==-1||nRightMax==-1)
                            continue;
                        allMaxTemp=MIN(nLeftMax,nRightMax);
                        allMax=MIN(allMaxTemp,peaktroughIn->value[t]+waterheight);

                        sun=allMax-peaktroughIn->value[t];
                        n=1;
                        while(n<waterwidth)
                        {
                            k=t-n;
                            if(k<0)
                                k=k+valuenum;
                            if(allMax<peaktroughIn->value[k])
                            {
                                width=width+(n-1);
                                break;
                            }
                            else
                                sun=sun+allMax-peaktroughIn->value[t];
                            n++;
                        }
                        n=1;
                        while(n<waterwidth)
                        {
                            k=t+n;
                            if(k>valuenum)
                                k=k-valuenum;
                            if(allMax<peaktroughIn->value[k])
                            {
                                width=width+(n-1);
                                break;
                            }
                            else
                                sun=sun+allMax-peaktroughIn->value[t];
                            n++;
                        }
                        datawaterIn_Out[t].volume=sun;
                        datawaterIn_Out[t].deep=allMax-peaktroughIn->value[t];
                        datawaterIn_Out[t].width=width;
                    }
                }
            }
            else
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==-1)
                    {
                        Int32 nLeftMax=0x80000000;
                        Int32 nRightMax=0x80000000;
                        Int32 allMaxTemp;
                        Int32 allMax;
                        Int32 n=1;
                        Int32 k;
                        Int32 sun=0;
                        Int16 width=1;
                        while(n<waterwidth)
                        {
                            k=t-n;
                            if(k<0)
                                break;
                            if(nLeftMax<peaktroughIn->value[k])
                                nLeftMax=peaktroughIn->value[k];
                            n++;
                        }
                        n=1;
                        while(n<waterwidth)
                        {
                            k=t+n;
                            if(k>valuenum)
                                break;
                            if(nRightMax<peaktroughIn->value[k])
                                nRightMax=peaktroughIn->value[k];
                            n++;
                        }
                        if(nLeftMax==0x80000000||nRightMax==0x80000000)
                            continue;
                        allMaxTemp=MIN(nLeftMax,nRightMax);
                        allMax=MIN(allMaxTemp,peaktroughIn->value[t]+waterheight);

                        sun=allMax-peaktroughIn->value[t];
                        n=1;
                        while(n<waterwidth)
                        {
                            k=t-n;
                            if(k<0)
                                break;
                            if(allMax<peaktroughIn->value[k])
                            {
                                width=width+(n-1);
                                break;
                            }
                            else
                                sun=sun+allMax-peaktroughIn->value[t];
                            n++;
                        }
                        n=1;
                        while(n<waterwidth)
                        {
                            k=t+n;
                            if(k>valuenum)
                                break;
                            if(allMax<peaktroughIn->value[k])
                            {
                                width=width+(n-1);
                                break;
                            }
                            else
                                sun=sun+allMax-peaktroughIn->value[t];
                            n++;
                        }
                        datawaterIn_Out[t].volume=sun;
                        datawaterIn_Out[t].deep=allMax-peaktroughIn->value[t];
                        datawaterIn_Out[t].width=width;
                    }
                }
            }
            break;
        case MHC_PEAKTROUGH_BOFENG_WATER:
            if(circleMod!=FALSE)
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==1)
                    {
                        Int32 nLeftMin=0x7fffffff;
                        Int32 nRightMin=0x7fffffff;
                        Int32 allMinTemp;
                        Int32 allMin;
                        Int32 n=1;
                        Int32 k;
                        Int32 sun=0;
                        Int16 width=1;
                        while(n<waterwidth)
                        {
                            k=t-n;
                            if(k<0)
                                k=k+valuenum;
                            if(nLeftMin>peaktroughIn->value[k])
                                nLeftMin=peaktroughIn->value[k];
                            n++;
                        }
                        n=1;
                        while(n<waterwidth)
                        {
                            k=t+n;
                            if(k>valuenum)
                                k=k-valuenum;
                            if(nRightMin>peaktroughIn->value[k])
                                nRightMin=peaktroughIn->value[k];
                            n++;
                        }
                        if(nLeftMin==0x7fffffff||nRightMin==0x7fffffff)
                            continue;
                        allMinTemp=MAX(nLeftMin,nRightMin);
                        allMin=MAX(allMinTemp,peaktroughIn->value[t]-waterheight);

                        sun=peaktroughIn->value[t]-allMin;
                        n=1;
                        while(n<waterwidth)
                        {
                            k=t-n;
                            if(k<0)
                                k=k+valuenum;
                            if(allMin>peaktroughIn->value[k])
                            {
                                width=width+(n-1);
                                break;
                            }
                            else
                                sun=sun+peaktroughIn->value[t]-allMin;
                            n++;
                        }
                        n=1;
                        while(n<waterwidth)
                        {
                            k=t+n;
                            if(k>valuenum)
                                k=k-valuenum;
                            if(allMin>peaktroughIn->value[k])
                            {
                                width=width+(n-1);
                                break;
                            }
                            else
                                sun=sun+peaktroughIn->value[t]-allMin;
                            n++;
                        }
                        datawaterIn_Out[t].volume=sun;
                        datawaterIn_Out[t].deep=peaktroughIn->value[t]-allMin;
                        datawaterIn_Out[t].width=width;
                    }
                }
            }
            else
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==1)
                    {
                        Int32 nLeftMin=0x7fffffff;
                        Int32 nRightMin=0x7fffffff;
                        Int32 allMinTemp;
                        Int32 allMin;
                        Int32 n=1;
                        Int32 k;
                        Int32 sun=0;
                        Int16 width=1;
                        while(n<waterwidth)
                        {
                            k=t-n;
                            if(k<0)
                                break;
                            if(nLeftMin>peaktroughIn->value[k])
                                nLeftMin=peaktroughIn->value[k];
                            n++;
                        }
                        n=1;
                        while(n<waterwidth)
                        {
                            k=t+n;
                            if(k>valuenum)
                                break;
                            if(nRightMin>peaktroughIn->value[k])
                                nRightMin=peaktroughIn->value[k];
                            n++;
                        }
                        if(nLeftMin==0x7fffffff||nRightMin==0x7fffffff)
                            continue;
                        allMinTemp=MAX(nLeftMin,nRightMin);
                        allMin=MAX(allMinTemp,peaktroughIn->value[t]-waterheight);

                        sun=peaktroughIn->value[t]-allMin;
                        n=1;
                        while(n<waterwidth)
                        {
                            k=t-n;
                            if(k<0)
                                break;
                            if(allMin>peaktroughIn->value[k])
                            {
                                width=width+(n-1);
                                break;
                            }
                            else
                                sun=sun+peaktroughIn->value[t]-allMin;
                            n++;
                        }
                        n=1;
                        while(n<waterwidth)
                        {
                            k=t+n;
                            if(k>valuenum)
                                break;
                            if(allMin>peaktroughIn->value[k])
                            {
                                width=width+(n-1);
                                break;
                            }
                            else
                                sun=sun+peaktroughIn->value[t]-allMin;
                            n++;
                        }
                        datawaterIn_Out[t].volume=sun;
                        datawaterIn_Out[t].deep=peaktroughIn->value[t]-allMin;
                        datawaterIn_Out[t].width=width;
                    }
                }
            }
            break;
        default:
            return 1;
            break;
        }
        return 0;
    }

    Int8 Mywatershed_peaktrough32FC(Peak_Trough32FC *peaktroughIn,watershed32FC *datawaterIn_Out,float waterheight,Int32 waterwidth,peakwatertype Mod,Bool circleMod)
    {
        Int32 t;
        Int32 valuenum=peaktroughIn->valuenum;

        memset(datawaterIn_Out,0,sizeof(watershed32FC)*valuenum);

        switch(Mod)
        {
        case MHC_PEAKTROUGH_BOGU_WATER:
            if(circleMod!=FALSE)
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==-1)
                    {
                        float nLeftMax=peaktroughIn->value[t];
                        float nRightMax=peaktroughIn->value[t];
                        Uint8 left_t=FALSE;
                        Uint8 right_t=FALSE;
                        float allMaxTemp;
                        float allMax;
                        Int32 n=1;
                        Int32 k;
                        float sun=0;
                        Int16 width=1;
                        while(n<waterwidth)
                        {
                            k=t-n;
                            if(k<0)
                                k=k+valuenum;
                            if(nLeftMax<peaktroughIn->value[k])
                            {
                                nLeftMax=peaktroughIn->value[k];
                                left_t=TRUE;
                            }
                            n++;
                        }
                        n=1;
                        while(n<waterwidth)
                        {
                            k=t+n;
                            if(k>valuenum)
                                k=k-valuenum;
                            if(nRightMax<peaktroughIn->value[k])
                            {
                                nRightMax=peaktroughIn->value[k];
                                right_t=TRUE;
                            }
                            n++;
                        }
                        if(left_t==FALSE||right_t==FALSE)
                            continue;
                        allMaxTemp=MIN(nLeftMax,nRightMax);
                        allMax=MIN(allMaxTemp,peaktroughIn->value[t]+waterheight);

                        sun=allMax-peaktroughIn->value[t];
                        n=1;
                        while(n<waterwidth)
                        {
                            k=t-n;
                            if(k<0)
                                k=k+valuenum;
                            if(allMax<peaktroughIn->value[k])
                            {
                                width=width+(n-1);
                                break;
                            }
                            else
                                sun=sun+allMax-peaktroughIn->value[t];
                            n++;
                        }
                        n=1;
                        while(n<waterwidth)
                        {
                            k=t+n;
                            if(k>valuenum)
                                k=k-valuenum;
                            if(allMax<peaktroughIn->value[k])
                            {
                                width=width+(n-1);
                                break;
                            }
                            else
                                sun=sun+allMax-peaktroughIn->value[t];
                            n++;
                        }
                        datawaterIn_Out[t].volume=sun;
                        datawaterIn_Out[t].deep=allMax-peaktroughIn->value[t];
                        datawaterIn_Out[t].width=width;
                    }
                }
            }
            else
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==-1)
                    {
                        float nLeftMax=peaktroughIn->value[t];
                        float nRightMax=peaktroughIn->value[t];
                        Uint8 left_t=FALSE;
                        Uint8 right_t=FALSE;
                        float allMaxTemp;
                        float allMax;
                        Int32 n=1;
                        Int32 k;
                        float sun=0;
                        Int16 width=1;
                        while(n<waterwidth)
                        {
                            k=t-n;
                            if(k<0)
                                break;
                            if(nLeftMax<peaktroughIn->value[k])
                            {
                                nLeftMax=peaktroughIn->value[k];
                                left_t=TRUE;
                            }
                            n++;
                        }
                        n=1;
                        while(n<waterwidth)
                        {
                            k=t+n;
                            if(k>valuenum)
                                break;
                            if(nRightMax<peaktroughIn->value[k])
                            {
                                nRightMax=peaktroughIn->value[k];
                                right_t=TRUE;
                            }
                            n++;
                        }
                        if(left_t==FALSE||right_t==FALSE)
                            continue;
                        allMaxTemp=MIN(nLeftMax,nRightMax);
                        allMax=MIN(allMaxTemp,peaktroughIn->value[t]+waterheight);

                        sun=allMax-peaktroughIn->value[t];
                        n=1;
                        while(n<waterwidth)
                        {
                            k=t-n;
                            if(k<0)
                                break;
                            if(allMax<peaktroughIn->value[k])
                            {
                                width=width+(n-1);
                                break;
                            }
                            else
                                sun=sun+allMax-peaktroughIn->value[t];
                            n++;
                        }
                        n=1;
                        while(n<waterwidth)
                        {
                            k=t+n;
                            if(k>valuenum)
                                break;
                            if(allMax<peaktroughIn->value[k])
                            {
                                width=width+(n-1);
                                break;
                            }
                            else
                                sun=sun+allMax-peaktroughIn->value[t];
                            n++;
                        }
                        datawaterIn_Out[t].volume=sun;
                        datawaterIn_Out[t].deep=allMax-peaktroughIn->value[t];
                        datawaterIn_Out[t].width=width;
                    }
                }
            }
            break;
        case MHC_PEAKTROUGH_BOFENG_WATER:
            if(circleMod!=FALSE)
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==1)
                    {
                        float nLeftMin=peaktroughIn->value[t];
                        float nRightMin=peaktroughIn->value[t];
                        Uint8 left_t=FALSE;
                        Uint8 right_t=FALSE;
                        float allMinTemp;
                        float allMin;
                        Int32 n=1;
                        Int32 k;
                        float sun=0;
                        Int16 width=1;
                        while(n<waterwidth)
                        {
                            k=t-n;
                            if(k<0)
                                k=k+valuenum;
                            if(nLeftMin>peaktroughIn->value[k])
                            {
                                nLeftMin=peaktroughIn->value[k];
                                left_t=TRUE;
                            }
                            n++;
                        }
                        n=1;
                        while(n<waterwidth)
                        {
                            k=t+n;
                            if(k>valuenum)
                                k=k-valuenum;
                            if(nRightMin>peaktroughIn->value[k])
                            {
                                nRightMin=peaktroughIn->value[k];
                                right_t=TRUE;
                            }
                            n++;
                        }
                        if(left_t==FALSE||right_t==FALSE)
                            continue;
                        allMinTemp=MAX(nLeftMin,nRightMin);
                        allMin=MAX(allMinTemp,peaktroughIn->value[t]-waterheight);

                        sun=peaktroughIn->value[t]-allMin;
                        n=1;
                        while(n<waterwidth)
                        {
                            k=t-n;
                            if(k<0)
                                k=k+valuenum;
                            if(allMin>peaktroughIn->value[k])
                            {
                                width=width+(n-1);
                                break;
                            }
                            else
                                sun=sun+peaktroughIn->value[t]-allMin;
                            n++;
                        }
                        n=1;
                        while(n<waterwidth)
                        {
                            k=t+n;
                            if(k>valuenum)
                                k=k-valuenum;
                            if(allMin>peaktroughIn->value[k])
                            {
                                width=width+(n-1);
                                break;
                            }
                            else
                                sun=sun+peaktroughIn->value[t]-allMin;
                            n++;
                        }
                        datawaterIn_Out[t].volume=sun;
                        datawaterIn_Out[t].deep=peaktroughIn->value[t]-allMin;
                        datawaterIn_Out[t].width=width;
                    }
                }
            }
            else
            {
                for(t=0;t<peaktroughIn->valuenum;t++)
                {
                    if(peaktroughIn->valpeaktrough[t]==1)
                    {
                        float nLeftMin=peaktroughIn->value[t];
                        float nRightMin=peaktroughIn->value[t];
                        Uint8 left_t=FALSE;
                        Uint8 right_t=FALSE;
                        float allMinTemp;
                        float allMin;
                        Int32 n=1;
                        Int32 k;
                        float sun=0;
                        Int16 width=1;
                        while(n<waterwidth)
                        {
                            k=t-n;
                            if(k<0)
                                break;
                            if(nLeftMin>peaktroughIn->value[k])
                            {
                                nLeftMin=peaktroughIn->value[k];
                                left_t=TRUE;
                            }
                            n++;
                        }
                        n=1;
                        while(n<waterwidth)
                        {
                            k=t+n;
                            if(k>valuenum)
                                break;
                            if(nRightMin>peaktroughIn->value[k])
                            {
                                nRightMin=peaktroughIn->value[k];
                                right_t=TRUE;
                            }
                            n++;
                        }
                        if(left_t==FALSE||right_t==FALSE)
                            continue;
                        allMinTemp=MAX(nLeftMin,nRightMin);
                        allMin=MAX(allMinTemp,peaktroughIn->value[t]-waterheight);

                        sun=peaktroughIn->value[t]-allMin;
                        n=1;
                        while(n<waterwidth)
                        {
                            k=t-n;
                            if(k<0)
                                break;
                            if(allMin>peaktroughIn->value[k])
                            {
                                width=width+(n-1);
                                break;
                            }
                            else
                                sun=sun+peaktroughIn->value[t]-allMin;
                            n++;
                        }
                        n=1;
                        while(n<waterwidth)
                        {
                            k=t+n;
                            if(k>valuenum)
                                break;
                            if(allMin>peaktroughIn->value[k])
                            {
                                width=width+(n-1);
                                break;
                            }
                            else
                                sun=sun+peaktroughIn->value[t]-allMin;
                            n++;
                        }
                        datawaterIn_Out[t].volume=sun;
                        datawaterIn_Out[t].deep=peaktroughIn->value[t]-allMin;
                        datawaterIn_Out[t].width=width;
                    }
                }
            }
            break;
        default:
            return 1;
            break;
        }
        return 0;
    }

    Int8 MyGetthin(MyConect *ImageConectIn,getthin Mod,Int32 value,Mat *matOut,Mat *HoughOut)
    {
        Int32 nnWidth=ImageConectIn->nWidth;
        Int32 nnHeight=ImageConectIn->nHeight;
        Int32 nStartX;
        Int32 nStartY;
        Int32 nEndX;
        Int32 nEndY;
        Int32 i,j;
        Int32 n;
        Uint16 *pEdgeMapList=(Uint16*)u8_buffer_x1Temp2;
        Uint16 pEdgeMapListNum=0;
        Mat lab;
        lab=MatCreat(nnHeight,nnWidth,CCV_8UC1,u8_buffer_x1Temp1);
        Myregion_to_label(ImageConectIn,&lab);
        getcloneinfo(lab,matOut);
        MatSet1col(matOut,0);
        switch(Mod)
        {
            case THIN_X:
                for(n=0;n<ImageConectIn->AllMarkPointCount;n++)
                {
                    nStartX=ImageConectIn->AllMarkPoint[n].left;
                    nStartY=ImageConectIn->AllMarkPoint[n].top;
                    nEndX=ImageConectIn->AllMarkPoint[n].right;
                    nEndY=ImageConectIn->AllMarkPoint[n].bottom;
                    for(j=nStartY;j<=nEndY;j++)
                    {
                        Int32 starti=-1;
                        Int32 endi=-1;
                        for(i=nStartX;i<=nEndX;i++)
                        {
                            if(lab.data[j*nnWidth+i]==n+1)
                            {
                                starti=i;
                                break;
                            }
                        }
                        for(i=nEndX;i>=nStartX;i--)
                        {
                            if(lab.data[j*nnWidth+i]==n+1)
                            {
                                endi=i;
                                break;
                            }
                        }
                        if(starti!=-1&&endi!=-1&&endi-starti<=value)
                        {
                            for(i=starti;i<=endi;i++)
                            {
                                if(lab.data[j*nnWidth+i]==n+1)
                                {
                                    matOut->data[j*nnWidth+i]=255;
                                    pEdgeMapList[pEdgeMapListNum*2]=(Uint16)i;
                                    pEdgeMapList[pEdgeMapListNum*2+1]=(Uint16)j;
                                    pEdgeMapListNum++;
                                }
                            }
                        }
                    }
                }
            break;
            case THIN_Y:
                for(n=0;n<ImageConectIn->AllMarkPointCount;n++)
                {
                    nStartX=ImageConectIn->AllMarkPoint[n].left;
                    nStartY=ImageConectIn->AllMarkPoint[n].top;
                    nEndX=ImageConectIn->AllMarkPoint[n].right;
                    nEndY=ImageConectIn->AllMarkPoint[n].bottom;
                    for(i=nStartX;i<=nEndX;i++)
                    {
                        Int32 startj=-1;
                        Int32 endj=-1;
                        for(j=nStartY;j<=nEndY;j++)
                        {
                            if(lab.data[j*nnWidth+i]==n+1)
                            {
                                startj=j;
                                break;
                            }
                        }
                        for(j=nEndY;j>=nStartY;j--)
                        {
                            if(lab.data[j*nnWidth+i]==n+1)
                            {
                                endj=j;
                                break;
                            }
                        }
                        if(startj!=-1&&endj!=-1&&endj-startj<=value)
                        {
                            for(j=startj;j<=endj;j++)
                            {
                                if(lab.data[j*nnWidth+i]==n+1)
                                {
                                    matOut->data[j*nnWidth+i]=255;
                                    pEdgeMapList[pEdgeMapListNum*2]=(Uint16)i;
                                    pEdgeMapList[pEdgeMapListNum*2+1]=(Uint16)j;
                                    pEdgeMapListNum++;
                                }
                            }
                        }
                    }
                }
            break;
            case THIN_45:
                for(n=0;n<ImageConectIn->AllMarkPointCount;n++)
                {
                    Int32 step=nnWidth-1;
                    Int32 p;
                    Int32 nWidth=ImageConectIn->AllMarkPoint[n].right-ImageConectIn->AllMarkPoint[n].left+1;
                    Int32 nHeight=ImageConectIn->AllMarkPoint[n].bottom-ImageConectIn->AllMarkPoint[n].top+1;
                    Int32 minSide=MIN(nWidth,nHeight);
                    Int32 ST;
                    Int32 ED;
                    nStartX=ImageConectIn->AllMarkPoint[n].left;
                    nStartY=ImageConectIn->AllMarkPoint[n].top;

                    if(nWidth>=nHeight)
                    {

                        for(p=0;p<minSide;p++)
                        {
                            Int32 num=p+1;
                            Int32 i;
                            Uint8 *ptr=&lab.data[nStartY*nnWidth+p+nStartX];
                            Uint8 *ptrIm_st=&matOut->data[nStartY*nnWidth+p+nStartX];
                            Uint8 *ptr_ed=ptr+step*(num-1);
                            Uint8 *ptr_st=ptr;
                            ST=-1;
                            ED=-1;
                            for(i=0;i<num;i++)
                            {
                                if(*ptr==n+1)
                                {
                                    ST=i;
                                    break;
                                }
                                ptr=ptr+step;
                            }
                            ptr=ptr_ed;
                            for(i=num-1;i>=0;i--)
                            {
                                if(*ptr==n+1)
                                {
                                    ED=i;
                                    break;
                                }
                                ptr=ptr-step;
                            }
                            if(ED!=-1&&ST!=-1&&ED-ST<=value)
                            {
                                ptr=ptr_st;
                                for(i=0;i<num;i++)
                                {
                                    if(*ptr==n+1)
                                    {
                                        Uint8 *ptrIm=ptrIm_st+(ptr-ptr_st);
                                        *ptrIm=255;
                                        pEdgeMapList[pEdgeMapListNum*2]=(Uint16)(ptr-lab.data)-(i+nStartY)*nnWidth;
                                        pEdgeMapList[pEdgeMapListNum*2+1]=(Uint16)i+nStartY;
                                        pEdgeMapListNum++;
                                    }
                                    ptr=ptr+step;
                                }
                            }
                        }

                        for(p=minSide;p<nWidth-1;p++)
                        {
                            Int32 num=minSide;
                            Int32 i;
                            Uint8 *ptr=&lab.data[nStartY*nnWidth+p+nStartX];
                            Uint8 *ptrIm_st=&matOut->data[nStartY*nnWidth+p+nStartX];
                            Uint8 *ptr_ed=ptr+step*(num-1);
                            Uint8 *ptr_st=ptr;
                            ST=-1;
                            ED=-1;
                            for(i=0;i<num;i++)
                            {
                                if(*ptr==n+1)
                                {
                                    ST=i;
                                    break;
                                }
                                ptr=ptr+step;
                            }
                            ptr=ptr_ed;
                            for(i=num-1;i>=0;i--)
                            {
                                if(*ptr==n+1)
                                {
                                    ED=i;
                                    break;
                                }
                                ptr=ptr-step;
                            }
                            if(ED!=-1&&ST!=-1&&ED-ST<=value)
                            {
                                ptr=ptr_st;
                                for(i=0;i<num;i++)
                                {
                                    if(*ptr==n+1)
                                    {
                                        Uint8 *ptrIm=ptrIm_st+(ptr-ptr_st);
                                        *ptrIm=255;
                                        pEdgeMapList[pEdgeMapListNum*2]=(Uint16)(ptr-lab.data)-(i+nStartY)*nnWidth;
                                        pEdgeMapList[pEdgeMapListNum*2+1]=(Uint16)i+nStartY;
                                        pEdgeMapListNum++;
                                    }
                                    ptr=ptr+step;
                                }
                            }
                        }

                        for(p=0;p<minSide;p++)
                        {
                            Int32 num=minSide-p;
                            Int32 i;
                            Uint8 *ptr=&lab.data[(nStartY+p)*nnWidth+nStartX+nWidth-1];
                            Uint8 *ptrIm_st=&matOut->data[(nStartY+p)*nnWidth+nStartX+nWidth-1];
                            Uint8 *ptr_ed=ptr+step*(num-1);
                            Uint8 *ptr_st=ptr;
                            ST=-1;
                            ED=-1;
                            for(i=0;i<num;i++)
                            {
                                if(*ptr==n+1)
                                {
                                    ST=i;
                                    break;
                                }
                                ptr=ptr+step;
                            }
                            ptr=ptr_ed;
                            for(i=num-1;i>=0;i--)
                            {
                                if(*ptr==n+1)
                                {
                                    ED=i;
                                    break;
                                }
                                ptr=ptr-step;
                            }
                            if(ED!=-1&&ST!=-1&&ED-ST<=value)
                            {
                                ptr=ptr_st;
                                for(i=0;i<num;i++)
                                {
                                    if(*ptr==n+1)
                                    {
                                        Uint8 *ptrIm=ptrIm_st+(ptr-ptr_st);
                                        *ptrIm=255;
                                        pEdgeMapList[pEdgeMapListNum*2]=(Uint16)(ptr-lab.data)-(p+i+nStartY)*nnWidth;
                                        pEdgeMapList[pEdgeMapListNum*2+1]=(Uint16)p+i+nStartY;
                                        pEdgeMapListNum++;
                                    }
                                    ptr=ptr+step;
                                }
                            }
                        }
                    }
                    else
                    {

                        for(p=0;p<minSide;p++)
                        {
                            Int32 num=p+1;
                            Int32 i;
                            Uint8 *ptr=&lab.data[nStartY*nnWidth+p+nStartX];
                            Uint8 *ptrIm_st=&matOut->data[nStartY*nnWidth+p+nStartX];
                            Uint8 *ptr_ed=ptr+step*(num-1);
                            Uint8 *ptr_st=ptr;
                            ST=-1;
                            ED=-1;
                            for(i=0;i<num;i++)
                            {
                                if(*ptr==n+1)
                                {
                                    ST=i;
                                    break;
                                }
                                ptr=ptr+step;
                            }
                            ptr=ptr_ed;
                            for(i=num-1;i>=0;i--)
                            {
                                if(*ptr==n+1)
                                {
                                    ED=i;
                                    break;
                                }
                                ptr=ptr-step;
                            }
                            if(ED!=-1&&ST!=-1&&ED-ST<=value)
                            {
                                ptr=ptr_st;
                                for(i=0;i<num;i++)
                                {
                                    if(*ptr==n+1)
                                    {
                                        Uint8 *ptrIm=ptrIm_st+(ptr-ptr_st);
                                        *ptrIm=255;
                                        pEdgeMapList[pEdgeMapListNum*2]=(Uint16)(ptr-lab.data)-(i+nStartY)*nnWidth;
                                        pEdgeMapList[pEdgeMapListNum*2+1]=(Uint16)i+nStartY;
                                        pEdgeMapListNum++;
                                    }
                                    ptr=ptr+step;
                                }
                            }
                        }

                        for(p=minSide;p<nHeight;p++)
                        {
                            Int32 num=minSide;
                            Int32 i;
                            Uint8 *ptr=&lab.data[(nStartY+p-minSide)*nnWidth+nStartX+nWidth-1];
                            Uint8 *ptrIm_st=&matOut->data[(nStartY+p-minSide)*nnWidth+nStartX+nWidth-1];
                            Uint8 *ptr_ed=ptr+step*(num-1);
                            Uint8 *ptr_st=ptr;
                            ST=-1;
                            ED=-1;
                            for(i=0;i<num;i++)
                            {
                                if(*ptr==n+1)
                                {
                                    ST=i;
                                    break;
                                }
                                ptr=ptr+step;
                            }
                            ptr=ptr_ed;
                            for(i=num-1;i>=0;i--)
                            {
                                if(*ptr==n+1)
                                {
                                    ED=i;
                                    break;
                                }
                                ptr=ptr-step;
                            }
                            if(ED!=-1&&ST!=-1&&ED-ST<=value)
                            {
                                ptr=ptr_st;
                                for(i=0;i<num;i++)
                                {
                                    if(*ptr==n+1)
                                    {
                                        Uint8 *ptrIm=ptrIm_st+(ptr-ptr_st);
                                        *ptrIm=255;
                                        pEdgeMapList[pEdgeMapListNum*2]=(Uint16)(ptr-lab.data)-(p-minSide+i+nStartY)*nnWidth;
                                        pEdgeMapList[pEdgeMapListNum*2+1]=(Uint16)p-minSide+i+nStartY;
                                        pEdgeMapListNum++;
                                    }
                                    ptr=ptr+step;
                                }
                            }
                        }

                        for(p=nHeight-minSide;p<nHeight;p++)
                        {
                            Int32 num=minSide-(p-minSide);
                            Int32 i;
                            Uint8 *ptr=&lab.data[(nStartY+p)*nnWidth+nStartX+nWidth-1];
                            Uint8 *ptrIm_st=&matOut->data[(nStartY+p)*nnWidth+nStartX+nWidth-1];
                            Uint8 *ptr_ed=ptr+step*(num-1);
                            Uint8 *ptr_st=ptr;
                            ST=-1;
                            ED=-1;
                            for(i=0;i<num;i++)
                            {
                                if(*ptr==n+1)
                                {
                                    ST=i;
                                    break;
                                }
                                ptr=ptr+step;
                            }
                            ptr=ptr_ed;
                            for(i=num-1;i>=0;i--)
                            {
                                if(*ptr==n+1)
                                {
                                    ED=i;
                                    break;
                                }
                                ptr=ptr-step;
                            }
                            if(ED!=-1&&ST!=-1&&ED-ST<=value)
                            {
                                ptr=ptr_st;
                                for(i=0;i<num;i++)
                                {
                                    if(*ptr==n+1)
                                    {
                                        Uint8 *ptrIm=ptrIm_st+(ptr-ptr_st);
                                        *ptrIm=255;
                                        pEdgeMapList[pEdgeMapListNum*2]=(Uint16)(ptr-lab.data)-(p+i+nStartY)*nnWidth;
                                        pEdgeMapList[pEdgeMapListNum*2+1]=(Uint16)p+i+nStartY;
                                        pEdgeMapListNum++;
                                    }
                                    ptr=ptr+step;
                                }
                            }
                        }
                    }
                }
            break;
            case THIN_135:
                for(n=0;n<ImageConectIn->AllMarkPointCount;n++)
                {
                    Int32 step=nnWidth+1;
                    Int32 p;
                    Int32 nWidth=ImageConectIn->AllMarkPoint[n].right-ImageConectIn->AllMarkPoint[n].left+1;
                    Int32 nHeight=ImageConectIn->AllMarkPoint[n].bottom-ImageConectIn->AllMarkPoint[n].top+1;
                    Int32 minSide=MIN(nWidth,nHeight);
                    Int32 ST;
                    Int32 ED;

                    nStartX=ImageConectIn->AllMarkPoint[n].left;
                    nStartY=ImageConectIn->AllMarkPoint[n].top;

                    if(nWidth>=nHeight)
                    {
                        for(p=0;p<minSide;p++)
                        {
                            Int32 num=minSide-p;
                            Int32 i;
                            Uint8 *ptr=&lab.data[(nStartY+p)*nnWidth+nStartX];
                            Uint8 *ptrIm_st=&matOut->data[(nStartY+p)*nnWidth+nStartX];
                            Uint8 *ptr_ed=ptr+step*(num-1);
                            Uint8 *ptr_st=ptr;
                            ST=-1;
                            ED=-1;
                            for(i=0;i<num;i++)
                            {
                                if(*ptr==n+1)
                                {
                                    ST=i;
                                    break;
                                }
                                ptr=ptr+step;
                            }
                            ptr=ptr_ed;
                            for(i=num-1;i>=0;i--)
                            {
                                if(*ptr==n+1)
                                {
                                    ED=i;
                                    break;
                                }
                                ptr=ptr-step;
                            }
                            if(ED!=-1&&ST!=-1&&ED-ST<=value)
                            {
                                ptr=ptr_st;
                                for(i=0;i<num;i++)
                                {
                                    if(*ptr==n+1)
                                    {
                                        Uint8 *ptrIm=ptrIm_st+(ptr-ptr_st);
                                        *ptrIm=255;
                                        pEdgeMapList[pEdgeMapListNum*2]=(Uint16)(ptr-lab.data)-(p+i+nStartY)*nnWidth;
                                        pEdgeMapList[pEdgeMapListNum*2+1]=(Uint16)p+i+nStartY;
                                        pEdgeMapListNum++;
                                    }
                                    ptr=ptr+step;
                                }
                            }
                        }

                        for(p=1;p<nWidth-minSide;p++)
                        {
                            Int32 num=minSide;
                            Int32 i;
                            Uint8 *ptr=&lab.data[nStartY*nnWidth+nStartX+p];
                            Uint8 *ptrIm_st=&matOut->data[nStartY*nnWidth+nStartX+p];
                            Uint8 *ptr_ed=ptr+step*(num-1);
                            Uint8 *ptr_st=ptr;
                            ST=-1;
                            ED=-1;
                            for(i=0;i<num;i++)
                            {
                                if(*ptr==n+1)
                                {
                                    ST=i;
                                    break;
                                }
                                ptr=ptr+step;
                            }
                            ptr=ptr_ed;
                            for(i=num-1;i>=0;i--)
                            {
                                if(*ptr==n+1)
                                {
                                    ED=i;
                                    break;
                                }
                                ptr=ptr-step;
                            }
                            if(ED!=-1&&ST!=-1&&ED-ST<=value)
                            {
                                ptr=ptr_st;
                                for(i=0;i<num;i++)
                                {
                                    if(*ptr==n+1)
                                    {
                                        Uint8 *ptrIm=ptrIm_st+(ptr-ptr_st);
                                        *ptrIm=255;
                                        pEdgeMapList[pEdgeMapListNum*2]=(Uint16)(ptr-lab.data)-(i+nStartY)*nnWidth;
                                        pEdgeMapList[pEdgeMapListNum*2+1]=(Uint16)i+nStartY;
                                        pEdgeMapListNum++;
                                    }
                                    ptr=ptr+step;
                                }
                            }
                        }

                        for(p=nWidth-minSide;p<nWidth;p++)
                        {
                            Int32 num=nWidth-p;
                            Int32 i;
                            Uint8 *ptr=&lab.data[nStartY*nnWidth+nStartX+p];
                            Uint8 *ptrIm_st=&matOut->data[nStartY*nnWidth+nStartX+p];
                            Uint8 *ptr_ed=ptr+step*(num-1);
                            Uint8 *ptr_st=ptr;
                            ST=-1;
                            ED=-1;
                            for(i=0;i<num;i++)
                            {
                                if(*ptr==n+1)
                                {
                                    ST=i;
                                    break;
                                }
                                ptr=ptr+step;
                            }
                            ptr=ptr_ed;
                            for(i=num-1;i>=0;i--)
                            {
                                if(*ptr==n+1)
                                {
                                    ED=i;
                                    break;
                                }
                                ptr=ptr-step;
                            }
                            if(ED!=-1&&ST!=-1&&ED-ST<=value)
                            {
                                ptr=ptr_st;
                                for(i=0;i<num;i++)
                                {
                                    if(*ptr==n+1)
                                    {
                                        Uint8 *ptrIm=ptrIm_st+(ptr-ptr_st);
                                        *ptrIm=255;
                                        pEdgeMapList[pEdgeMapListNum*2]=(Uint16)(ptr-lab.data)-(i+nStartY)*nnWidth;
                                        pEdgeMapList[pEdgeMapListNum*2+1]=(Uint16)i+nStartY;
                                        pEdgeMapListNum++;
                                    }
                                    ptr=ptr+step;
                                }
                            }
                        }
                    }
                    else
                    {

                        for(p=nHeight-minSide;p<nHeight;p++)
                        {
                            Int32 num=nHeight-p;
                            Int32 i;
                            Uint8 *ptr=&lab.data[(nStartY+p)*nnWidth+nStartX];
                            Uint8 *ptrIm_st=&matOut->data[(nStartY+p)*nnWidth+nStartX];
                            Uint8 *ptr_ed=ptr+step*(num-1);
                            Uint8 *ptr_st=ptr;
                            ST=-1;
                            ED=-1;
                            for(i=0;i<num;i++)
                            {
                                if(*ptr==n+1)
                                {
                                    ST=i;
                                    break;
                                }
                                ptr=ptr+step;
                            }
                            ptr=ptr_ed;
                            for(i=num-1;i>=0;i--)
                            {
                                if(*ptr==n+1)
                                {
                                    ED=i;
                                    break;
                                }
                                ptr=ptr-step;
                            }
                            if(ED!=-1&&ST!=-1&&ED-ST<=value)
                            {
                                ptr=ptr_st;
                                for(i=0;i<num;i++)
                                {
                                    if(*ptr==n+1)
                                    {
                                        Uint8 *ptrIm=ptrIm_st+(ptr-ptr_st);
                                        *ptrIm=255;
                                        pEdgeMapList[pEdgeMapListNum*2]=(Uint16)(ptr-lab.data)-(p+i+nStartY)*nnWidth;
                                        pEdgeMapList[pEdgeMapListNum*2+1]=(Uint16)p+i+nStartY;
                                        pEdgeMapListNum++;
                                    }
                                    ptr=ptr+step;
                                }
                            }
                        }

                        for(p=1;p<nHeight-minSide;p++)
                        {
                            Int32 num=minSide;
                            Int32 i;
                            Uint8 *ptr=&lab.data[(nStartY+p)*nnWidth+nStartX];
                            Uint8 *ptrIm_st=&matOut->data[(nStartY+p)*nnWidth+nStartX];
                            Uint8 *ptr_ed=ptr+step*(num-1);
                            Uint8 *ptr_st=ptr;
                            ST=-1;
                            ED=-1;
                            for(i=0;i<num;i++)
                            {
                                if(*ptr==n+1)
                                {
                                    ST=i;
                                    break;
                                }
                                ptr=ptr+step;
                            }
                            ptr=ptr_ed;
                            for(i=num-1;i>=0;i--)
                            {
                                if(*ptr==n+1)
                                {
                                    ED=i;
                                    break;
                                }
                                ptr=ptr-step;
                            }
                            if(ED!=-1&&ST!=-1&&ED-ST<=value)
                            {
                                ptr=ptr_st;
                                for(i=0;i<num;i++)
                                {
                                    if(*ptr==n+1)
                                    {
                                        Uint8 *ptrIm=ptrIm_st+(ptr-ptr_st);
                                        *ptrIm=255;
                                        pEdgeMapList[pEdgeMapListNum*2]=(Uint16)(ptr-lab.data)-(p+i+nStartY)*nnWidth;
                                        pEdgeMapList[pEdgeMapListNum*2+1]=(Uint16)p+i+nStartY;
                                        pEdgeMapListNum++;
                                    }
                                    ptr=ptr+step;
                                }
                            }
                        }

                        for(p=0;p<minSide;p++)
                        {
                            Int32 num=minSide-p;
                            Int32 i;
                            Uint8 *ptr=&lab.data[nStartY*nnWidth+nStartX+p];
                            Uint8 *ptrIm_st=&matOut->data[nStartY*nnWidth+nStartX+p];
                            Uint8 *ptr_ed=ptr+step*(num-1);
                            Uint8 *ptr_st=ptr;
                            ST=-1;
                            ED=-1;
                            for(i=0;i<num;i++)
                            {
                                if(*ptr==n+1)
                                {
                                    ST=i;
                                    break;
                                }
                                ptr=ptr+step;
                            }
                            ptr=ptr_ed;
                            for(i=num-1;i>=0;i--)
                            {
                                if(*ptr==n+1)
                                {
                                    ED=i;
                                    break;
                                }
                                ptr=ptr-step;
                            }
                            if(ED!=-1&&ST!=-1&&ED-ST<=value)
                            {
                                ptr=ptr_st;
                                for(i=0;i<num;i++)
                                {
                                    if(*ptr==n+1)
                                    {
                                        Uint8 *ptrIm=ptrIm_st+(ptr-ptr_st);
                                        *ptrIm=255;
                                        pEdgeMapList[pEdgeMapListNum*2]=(Uint16)(ptr-lab.data)-(i+nStartY)*nnWidth;
                                        pEdgeMapList[pEdgeMapListNum*2+1]=(Uint16)i+nStartY;
                                        pEdgeMapListNum++;
                                    }
                                    ptr=ptr+step;
                                }
                            }
                        }
                    }
                }
            break;
            default:
                return 1;
            break;
        }
        MyPoint_to_Hough(pEdgeMapList,nnWidth,nnHeight,pEdgeMapListNum,HoughOut);
        return 0;
    }

    Int8 MyGetthinNoHough(MyConect *ImageConectIn,getthin Mod,Int32 value,Mat *matOut)
    {
        Uint32 nnWidth=ImageConectIn->nWidth;
        Uint32 nnHeight=ImageConectIn->nHeight;
        Int32 nStartX;
        Int32 nStartY;
        Int32 nEndX;
        Int32 nEndY;
        Int32 i,j;
        Int32 n;
        Mat lab;
        lab=MatCreat(nnHeight,nnWidth,CCV_8UC1,u8_buffer_x1Temp1);
        Myregion_to_label(ImageConectIn,&lab);
        getcloneinfo(lab,matOut);
        MatSet1col(matOut,0);
        switch(Mod)
        {
            case THIN_X:
                for(n=0;n<ImageConectIn->AllMarkPointCount;n++)
                {
                    nStartX=ImageConectIn->AllMarkPoint[n].left;
                    nStartY=ImageConectIn->AllMarkPoint[n].top;
                    nEndX=ImageConectIn->AllMarkPoint[n].right;
                    nEndY=ImageConectIn->AllMarkPoint[n].bottom;
                    for(j=nStartY;j<=nEndY;j++)
                    {
                        Int32 starti=-1;
                        Int32 endi=-1;
                        for(i=nStartX;i<=nEndX;i++)
                        {
                            if(lab.data[j*nnWidth+i]==n+1)
                            {
                                starti=i;
                                break;
                            }
                        }
                        for(i=nEndX;i>=nStartX;i--)
                        {
                            if(lab.data[j*nnWidth+i]==n+1)
                            {
                                endi=i;
                                break;
                            }
                        }
                        if(starti!=-1&&endi!=-1&&endi-starti<=value)
                        {
                            for(i=starti;i<=endi;i++)
                            {
                                if(lab.data[j*nnWidth+i]==n+1)
                                {
                                    matOut->data[j*nnWidth+i]=255;
                                }
                            }
                        }
                    }
                }
            break;
            case THIN_Y:
                for(n=0;n<ImageConectIn->AllMarkPointCount;n++)
                {
                    nStartX=ImageConectIn->AllMarkPoint[n].left;
                    nStartY=ImageConectIn->AllMarkPoint[n].top;
                    nEndX=ImageConectIn->AllMarkPoint[n].right;
                    nEndY=ImageConectIn->AllMarkPoint[n].bottom;
                    for(i=nStartX;i<=nEndX;i++)
                    {
                        Int32 startj=-1;
                        Int32 endj=-1;
                        for(j=nStartY;j<=nEndY;j++)
                        {
                            if(lab.data[j*nnWidth+i]==n+1)
                            {
                                startj=j;
                                break;
                            }
                        }
                        for(j=nEndY;j>=nStartY;j--)
                        {
                            if(lab.data[j*nnWidth+i]==n+1)
                            {
                                endj=j;
                                break;
                            }
                        }
                        if(startj!=-1&&endj!=-1&&endj-startj<=value)
                        {
                            for(j=startj;j<=endj;j++)
                            {
                                if(lab.data[j*nnWidth+i]==n+1)
                                {
                                    matOut->data[j*nnWidth+i]=255;
                                }
                            }
                        }
                    }
                }
            break;
            case THIN_45:
                for(n=0;n<ImageConectIn->AllMarkPointCount;n++)
                {
                    Int32 step=nnWidth-1;
                    Int32 p;
                    Int32 nWidth=ImageConectIn->AllMarkPoint[n].right-ImageConectIn->AllMarkPoint[n].left+1;
                    Int32 nHeight=ImageConectIn->AllMarkPoint[n].bottom-ImageConectIn->AllMarkPoint[n].top+1;
                    Int32 minSide=MIN(nWidth,nHeight);
                    Int32 ST;
                    Int32 ED;
                    nStartX=ImageConectIn->AllMarkPoint[n].left;
                    nStartY=ImageConectIn->AllMarkPoint[n].top;

                    if(nWidth>=nHeight)
                    {

                        for(p=0;p<minSide;p++)
                        {
                            Int32 num=p+1;
                            Int32 i;
                            Uint8 *ptr=&lab.data[nStartY*nnWidth+p+nStartX];
                            Uint8 *ptrIm_st=&matOut->data[nStartY*nnWidth+p+nStartX];
                            Uint8 *ptr_ed=ptr+step*(num-1);
                            Uint8 *ptr_st=ptr;
                            ST=-1;
                            ED=-1;
                            for(i=0;i<num;i++)
                            {
                                if(*ptr==n+1)
                                {
                                    ST=i;
                                    break;
                                }
                                ptr=ptr+step;
                            }
                            ptr=ptr_ed;
                            for(i=num-1;i>=0;i--)
                            {
                                if(*ptr==n+1)
                                {
                                    ED=i;
                                    break;
                                }
                                ptr=ptr-step;
                            }
                            if(ED!=-1&&ST!=-1&&ED-ST<=value)
                            {
                                ptr=ptr_st;
                                for(i=0;i<num;i++)
                                {
                                    if(*ptr==n+1)
                                    {
                                        Uint8 *ptrIm=ptrIm_st+(ptr-ptr_st);
                                        *ptrIm=255;
                                    }
                                    ptr=ptr+step;
                                }
                            }
                        }

                        for(p=minSide;p<nWidth-1;p++)
                        {
                            Int32 num=minSide;
                            Int32 i;
                            Uint8 *ptr=&lab.data[nStartY*nnWidth+p+nStartX];
                            Uint8 *ptrIm_st=&matOut->data[nStartY*nnWidth+p+nStartX];
                            Uint8 *ptr_ed=ptr+step*(num-1);
                            Uint8 *ptr_st=ptr;
                            ST=-1;
                            ED=-1;
                            for(i=0;i<num;i++)
                            {
                                if(*ptr==n+1)
                                {
                                    ST=i;
                                    break;
                                }
                                ptr=ptr+step;
                            }
                            ptr=ptr_ed;
                            for(i=num-1;i>=0;i--)
                            {
                                if(*ptr==n+1)
                                {
                                    ED=i;
                                    break;
                                }
                                ptr=ptr-step;
                            }
                            if(ED!=-1&&ST!=-1&&ED-ST<=value)
                            {
                                ptr=ptr_st;
                                for(i=0;i<num;i++)
                                {
                                    if(*ptr==n+1)
                                    {
                                        Uint8 *ptrIm=ptrIm_st+(ptr-ptr_st);
                                        *ptrIm=255;
                                    }
                                    ptr=ptr+step;
                                }
                            }
                        }

                        for(p=0;p<minSide;p++)
                        {
                            Int32 num=minSide-p;
                            Int32 i;
                            Uint8 *ptr=&lab.data[(nStartY+p)*nnWidth+nStartX+nWidth-1];
                            Uint8 *ptrIm_st=&matOut->data[(nStartY+p)*nnWidth+nStartX+nWidth-1];
                            Uint8 *ptr_ed=ptr+step*(num-1);
                            Uint8 *ptr_st=ptr;
                            ST=-1;
                            ED=-1;
                            for(i=0;i<num;i++)
                            {
                                if(*ptr==n+1)
                                {
                                    ST=i;
                                    break;
                                }
                                ptr=ptr+step;
                            }
                            ptr=ptr_ed;
                            for(i=num-1;i>=0;i--)
                            {
                                if(*ptr==n+1)
                                {
                                    ED=i;
                                    break;
                                }
                                ptr=ptr-step;
                            }
                            if(ED!=-1&&ST!=-1&&ED-ST<=value)
                            {
                                ptr=ptr_st;
                                for(i=0;i<num;i++)
                                {
                                    if(*ptr==n+1)
                                    {
                                        Uint8 *ptrIm=ptrIm_st+(ptr-ptr_st);
                                        *ptrIm=255;
                                    }
                                    ptr=ptr+step;
                                }
                            }
                        }
                    }
                    else
                    {
                        for(p=0;p<minSide;p++)
                        {
                            Int32 num=p+1;
                            Int32 i;
                            Uint8 *ptr=&lab.data[nStartY*nnWidth+p+nStartX];
                            Uint8 *ptrIm_st=&matOut->data[nStartY*nnWidth+p+nStartX];
                            Uint8 *ptr_ed=ptr+step*(num-1);
                            Uint8 *ptr_st=ptr;
                            ST=-1;
                            ED=-1;
                            for(i=0;i<num;i++)
                            {
                                if(*ptr==n+1)
                                {
                                    ST=i;
                                    break;
                                }
                                ptr=ptr+step;
                            }
                            ptr=ptr_ed;
                            for(i=num-1;i>=0;i--)
                            {
                                if(*ptr==n+1)
                                {
                                    ED=i;
                                    break;
                                }
                                ptr=ptr-step;
                            }
                            if(ED!=-1&&ST!=-1&&ED-ST<=value)
                            {
                                ptr=ptr_st;
                                for(i=0;i<num;i++)
                                {
                                    if(*ptr==n+1)
                                    {
                                        Uint8 *ptrIm=ptrIm_st+(ptr-ptr_st);
                                        *ptrIm=255;
                                    }
                                    ptr=ptr+step;
                                }
                            }
                        }

                        for(p=minSide;p<nHeight;p++)
                        {
                            Int32 num=minSide;
                            Int32 i;
                            Uint8 *ptr=&lab.data[(nStartY+p-minSide)*nnWidth+nStartX+nWidth-1];
                            Uint8 *ptrIm_st=&matOut->data[(nStartY+p-minSide)*nnWidth+nStartX+nWidth-1];
                            Uint8 *ptr_ed=ptr+step*(num-1);
                            Uint8 *ptr_st=ptr;
                            ST=-1;
                            ED=-1;
                            for(i=0;i<num;i++)
                            {
                                if(*ptr==n+1)
                                {
                                    ST=i;
                                    break;
                                }
                                ptr=ptr+step;
                            }
                            ptr=ptr_ed;
                            for(i=num-1;i>=0;i--)
                            {
                                if(*ptr==n+1)
                                {
                                    ED=i;
                                    break;
                                }
                                ptr=ptr-step;
                            }
                            if(ED!=-1&&ST!=-1&&ED-ST<=value)
                            {
                                ptr=ptr_st;
                                for(i=0;i<num;i++)
                                {
                                    if(*ptr==n+1)
                                    {
                                        Uint8 *ptrIm=ptrIm_st+(ptr-ptr_st);
                                        *ptrIm=255;
                                    }
                                    ptr=ptr+step;
                                }
                            }
                        }

                        for(p=nHeight-minSide;p<nHeight;p++)
                        {
                            Int32 num=minSide-(p-minSide);
                            Int32 i;
                            Uint8 *ptr=&lab.data[(nStartY+p)*nnWidth+nStartX+nWidth-1];
                            Uint8 *ptrIm_st=&matOut->data[(nStartY+p)*nnWidth+nStartX+nWidth-1];
                            Uint8 *ptr_ed=ptr+step*(num-1);
                            Uint8 *ptr_st=ptr;
                            ST=-1;
                            ED=-1;
                            for(i=0;i<num;i++)
                            {
                                if(*ptr==n+1)
                                {
                                    ST=i;
                                    break;
                                }
                                ptr=ptr+step;
                            }
                            ptr=ptr_ed;
                            for(i=num-1;i>=0;i--)
                            {
                                if(*ptr==n+1)
                                {
                                    ED=i;
                                    break;
                                }
                                ptr=ptr-step;
                            }
                            if(ED!=-1&&ST!=-1&&ED-ST<=value)
                            {
                                ptr=ptr_st;
                                for(i=0;i<num;i++)
                                {
                                    if(*ptr==n+1)
                                    {
                                        Uint8 *ptrIm=ptrIm_st+(ptr-ptr_st);
                                        *ptrIm=255;
                                    }
                                    ptr=ptr+step;
                                }
                            }
                        }
                    }
                }
            break;
            case THIN_135:
                for(n=0;n<ImageConectIn->AllMarkPointCount;n++)
                {
                    Int32 step=nnWidth+1;
                    Int32 p;
                    Int32 nWidth=ImageConectIn->AllMarkPoint[n].right-ImageConectIn->AllMarkPoint[n].left+1;
                    Int32 nHeight=ImageConectIn->AllMarkPoint[n].bottom-ImageConectIn->AllMarkPoint[n].top+1;
                    Int32 minSide=MIN(nWidth,nHeight);
                    Int32 ST;
                    Int32 ED;

                    nStartX=ImageConectIn->AllMarkPoint[n].left;
                    nStartY=ImageConectIn->AllMarkPoint[n].top;

                    if(nWidth>=nHeight)
                    {
                        for(p=0;p<minSide;p++)
                        {
                            Int32 num=minSide-p;
                            Int32 i;
                            Uint8 *ptr=&lab.data[(nStartY+p)*nnWidth+nStartX];
                            Uint8 *ptrIm_st=&matOut->data[(nStartY+p)*nnWidth+nStartX];
                            Uint8 *ptr_ed=ptr+step*(num-1);
                            Uint8 *ptr_st=ptr;
                            ST=-1;
                            ED=-1;
                            for(i=0;i<num;i++)
                            {
                                if(*ptr==n+1)
                                {
                                    ST=i;
                                    break;
                                }
                                ptr=ptr+step;
                            }
                            ptr=ptr_ed;
                            for(i=num-1;i>=0;i--)
                            {
                                if(*ptr==n+1)
                                {
                                    ED=i;
                                    break;
                                }
                                ptr=ptr-step;
                            }
                            if(ED!=-1&&ST!=-1&&ED-ST<=value)
                            {
                                ptr=ptr_st;
                                for(i=0;i<num;i++)
                                {
                                    if(*ptr==n+1)
                                    {
                                        Uint8 *ptrIm=ptrIm_st+(ptr-ptr_st);
                                        *ptrIm=255;
                                    }
                                    ptr=ptr+step;
                                }
                            }
                        }

                        for(p=1;p<nWidth-minSide;p++)
                        {
                            Int32 num=minSide;
                            Int32 i;
                            Uint8 *ptr=&lab.data[nStartY*nnWidth+nStartX+p];
                            Uint8 *ptrIm_st=&matOut->data[nStartY*nnWidth+nStartX+p];
                            Uint8 *ptr_ed=ptr+step*(num-1);
                            Uint8 *ptr_st=ptr;
                            ST=-1;
                            ED=-1;
                            for(i=0;i<num;i++)
                            {
                                if(*ptr==n+1)
                                {
                                    ST=i;
                                    break;
                                }
                                ptr=ptr+step;
                            }
                            ptr=ptr_ed;
                            for(i=num-1;i>=0;i--)
                            {
                                if(*ptr==n+1)
                                {
                                    ED=i;
                                    break;
                                }
                                ptr=ptr-step;
                            }
                            if(ED!=-1&&ST!=-1&&ED-ST<=value)
                            {
                                ptr=ptr_st;
                                for(i=0;i<num;i++)
                                {
                                    if(*ptr==n+1)
                                    {
                                        Uint8 *ptrIm=ptrIm_st+(ptr-ptr_st);
                                        *ptrIm=255;
                                    }
                                    ptr=ptr+step;
                                }
                            }
                        }

                        for(p=nWidth-minSide;p<nWidth;p++)
                        {
                            Int32 num=nWidth-p;
                            Int32 i;
                            Uint8 *ptr=&lab.data[nStartY*nnWidth+nStartX+p];
                            Uint8 *ptrIm_st=&matOut->data[nStartY*nnWidth+nStartX+p];
                            Uint8 *ptr_ed=ptr+step*(num-1);
                            Uint8 *ptr_st=ptr;
                            ST=-1;
                            ED=-1;
                            for(i=0;i<num;i++)
                            {
                                if(*ptr==n+1)
                                {
                                    ST=i;
                                    break;
                                }
                                ptr=ptr+step;
                            }
                            ptr=ptr_ed;
                            for(i=num-1;i>=0;i--)
                            {
                                if(*ptr==n+1)
                                {
                                    ED=i;
                                    break;
                                }
                                ptr=ptr-step;
                            }
                            if(ED!=-1&&ST!=-1&&ED-ST<=value)
                            {
                                ptr=ptr_st;
                                for(i=0;i<num;i++)
                                {
                                    if(*ptr==n+1)
                                    {
                                        Uint8 *ptrIm=ptrIm_st+(ptr-ptr_st);
                                        *ptrIm=255;
                                    }
                                    ptr=ptr+step;
                                }
                            }
                        }
                    }
                    else
                    {

                        for(p=nHeight-minSide;p<nHeight;p++)
                        {
                            Int32 num=nHeight-p;
                            Int32 i;
                            Uint8 *ptr=&lab.data[(nStartY+p)*nnWidth+nStartX];
                            Uint8 *ptrIm_st=&matOut->data[(nStartY+p)*nnWidth+nStartX];
                            Uint8 *ptr_ed=ptr+step*(num-1);
                            Uint8 *ptr_st=ptr;
                            ST=-1;
                            ED=-1;
                            for(i=0;i<num;i++)
                            {
                                if(*ptr==n+1)
                                {
                                    ST=i;
                                    break;
                                }
                                ptr=ptr+step;
                            }
                            ptr=ptr_ed;
                            for(i=num-1;i>=0;i--)
                            {
                                if(*ptr==n+1)
                                {
                                    ED=i;
                                    break;
                                }
                                ptr=ptr-step;
                            }
                            if(ED!=-1&&ST!=-1&&ED-ST<=value)
                            {
                                ptr=ptr_st;
                                for(i=0;i<num;i++)
                                {
                                    if(*ptr==n+1)
                                    {
                                        Uint8 *ptrIm=ptrIm_st+(ptr-ptr_st);
                                        *ptrIm=255;
                                    }
                                    ptr=ptr+step;
                                }
                            }
                        }

                        for(p=1;p<nHeight-minSide;p++)
                        {
                            Int32 num=minSide;
                            Int32 i;
                            Uint8 *ptr=&lab.data[(nStartY+p)*nnWidth+nStartX];
                            Uint8 *ptrIm_st=&matOut->data[(nStartY+p)*nnWidth+nStartX];
                            Uint8 *ptr_ed=ptr+step*(num-1);
                            Uint8 *ptr_st=ptr;
                            ST=-1;
                            ED=-1;
                            for(i=0;i<num;i++)
                            {
                                if(*ptr==n+1)
                                {
                                    ST=i;
                                    break;
                                }
                                ptr=ptr+step;
                            }
                            ptr=ptr_ed;
                            for(i=num-1;i>=0;i--)
                            {
                                if(*ptr==n+1)
                                {
                                    ED=i;
                                    break;
                                }
                                ptr=ptr-step;
                            }
                            if(ED!=-1&&ST!=-1&&ED-ST<=value)
                            {
                                ptr=ptr_st;
                                for(i=0;i<num;i++)
                                {
                                    if(*ptr==n+1)
                                    {
                                        Uint8 *ptrIm=ptrIm_st+(ptr-ptr_st);
                                        *ptrIm=255;
                                    }
                                    ptr=ptr+step;
                                }
                            }
                        }

                        for(p=0;p<minSide;p++)
                        {
                            Int32 num=minSide-p;
                            Int32 i;
                            Uint8 *ptr=&lab.data[nStartY*nnWidth+nStartX+p];
                            Uint8 *ptrIm_st=&matOut->data[nStartY*nnWidth+nStartX+p];
                            Uint8 *ptr_ed=ptr+step*(num-1);
                            Uint8 *ptr_st=ptr;
                            ST=-1;
                            ED=-1;
                            for(i=0;i<num;i++)
                            {
                                if(*ptr==n+1)
                                {
                                    ST=i;
                                    break;
                                }
                                ptr=ptr+step;
                            }
                            ptr=ptr_ed;
                            for(i=num-1;i>=0;i--)
                            {
                                if(*ptr==n+1)
                                {
                                    ED=i;
                                    break;
                                }
                                ptr=ptr-step;
                            }
                            if(ED!=-1&&ST!=-1&&ED-ST<=value)
                            {
                                ptr=ptr_st;
                                for(i=0;i<num;i++)
                                {
                                    if(*ptr==n+1)
                                    {
                                        Uint8 *ptrIm=ptrIm_st+(ptr-ptr_st);
                                        *ptrIm=255;
                                    }
                                    ptr=ptr+step;
                                }
                            }
                        }
                    }
                }
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 MyGetlxthinNoHough(Mat matIn,getthin Mod,Int32 value,Int32 kongxi,Mat *matOut)
    {
        Uint32 nnWidth=matIn.nWidth;
        Uint32 nnHeight=matIn.nHeight;
        Int32 x,y,dy;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        Int32 sT,eD;
        Uint8 havejishu;
        Uint8 nohave;

        memcpy(matOut->data,matIn.data,nnHeight*nnWidth);
        switch(Mod)
        {
            case THIN_X:
                for(y=nStartY;y<nStartY+nHeight;y++)
                {
                    havejishu=0;
                    for(x=nStartX;x<nStartX+nWidth;x++)
                    {
                        if(matIn.ptr_uchar[y*nnWidth+x]!=0)
                        {
                            if(havejishu==0)
                            {
                                havejishu=1;
                                nohave=0;
                                sT=x;
                                eD=x;
                            }
                            else if(havejishu==1)
                            {
                                eD=x;
                                nohave=0;
                            }
                        }
                        else if(havejishu==1)
                        {
                            nohave++;
                            if(nohave>kongxi)
                            {
                                havejishu=0;
                                if(eD-sT>value)
                                {
                                    memset(&matOut->ptr_uchar[y*nnWidth+sT],0,eD-sT+1);
                                }
                                if(sT==nStartX)
                                {
                                    memset(&matOut->ptr_uchar[y*nnWidth+sT],0,eD-sT+1);
                                }
                            }
                        }
                    }
                    if(havejishu==1&&eD-sT>value)
                    {
                        memset(&matOut->ptr_uchar[y*nnWidth+sT],0,eD-sT+1);
                    }
                    if(havejishu==1&&sT==nStartX)
                    {
                        memset(&matOut->ptr_uchar[y*nnWidth+sT],0,eD-sT+1);
                    }
                    if(havejishu==1&&eD==nStartX+nWidth-1)
                    {
                        memset(&matOut->ptr_uchar[y*nnWidth+sT],0,eD-sT+1);
                    }
                }
            break;
            case THIN_Y:
                for(x=nStartX;x<nStartX+nWidth;x++)
                {
                    havejishu=0;
                    for(y=nStartY;y<nStartY+nHeight;y++)
                    {
                        if(matIn.ptr_uchar[y*nnWidth+x]!=0)
                        {
                            if(havejishu==0)
                            {
                                havejishu=1;
                                nohave=0;
                                sT=y;
                                eD=y;
                            }
                            else if(havejishu==1)
                            {
                                eD=y;
                                nohave=0;
                            }
                        }
                        else if(havejishu==1)
                        {
                            nohave++;
                            if(nohave>kongxi)
                            {
                                havejishu=0;
                                if(eD-sT>value)
                                {
                                    for(dy=sT;dy<=eD;dy++)
                                    {
                                        matOut->ptr_uchar[dy*nnWidth+x]=0;
                                    }
                                }
                                if(sT==nStartY)
                                {
                                    for(dy=sT;dy<=eD;dy++)
                                    {
                                        matOut->ptr_uchar[dy*nnWidth+x]=0;
                                    }
                                }
                            }
                        }
                    }
                    if(havejishu==1&&eD-sT>value)
                    {
                        for(dy=sT;dy<=eD;dy++)
                        {
                            matOut->ptr_uchar[dy*nnWidth+x]=0;
                        }
                    }
                    if(havejishu==1&&sT==nStartY)
                    {
                        for(dy=sT;dy<=eD;dy++)
                        {
                            matOut->ptr_uchar[dy*nnWidth+x]=0;
                        }
                    }
                    if(havejishu==1&&eD==nStartY+nHeight-1)
                    {
                        for(dy=sT;dy<=eD;dy++)
                        {
                            matOut->ptr_uchar[dy*nnWidth+x]=0;
                        }
                    }
                }
            break;
            case THIN_45:
            {
                Int32 minSide=MIN(nWidth,nHeight);
                Int32 step=nnWidth-1;
                Int32 p;
                if(nWidth>=nHeight)
                {

                    for(p=0;p<minSide;p++)
                    {
                        Int32 num=p+1;
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[nStartY*nnWidth+p+nStartX];
                        Uint8 *ptrIm_st=&matOut->ptr_uchar[nStartY*nnWidth+p+nStartX];
                        havejishu=0;

                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                if(havejishu==0)
                                {
                                    havejishu=1;
                                    nohave=0;
                                    sT=n;
                                    eD=n;
                                }
                                else if(havejishu==1)
                                {
                                    eD=n;
                                    nohave=0;
                                }
                            }
                            else if(havejishu==1)
                            {
                                nohave++;
                                if(nohave>kongxi)
                                {
                                    havejishu=0;
                                    if(eD-sT>value)
                                    {
                                        for(dy=sT;dy<=eD;dy++)
                                        {
                                            Uint8 *ptrIm=ptrIm_st+dy*step;
                                            *ptrIm=0;
                                        }
                                    }
                                    if(sT==0)
                                    {
                                        for(dy=sT;dy<=eD;dy++)
                                        {
                                            Uint8 *ptrIm=ptrIm_st+dy*step;
                                            *ptrIm=0;
                                        }
                                    }
                                }
                            }
                            ptr=ptr+step;
                        }
                        if(havejishu==1&&eD-sT>value)
                        {
                            for(dy=sT;dy<=eD;dy++)
                            {
                                Uint8 *ptrIm=ptrIm_st+dy*step;
                                *ptrIm=0;
                            }
                        }
                        if(havejishu==1&&sT==nStartY)
                        {
                            for(dy=sT;dy<=eD;dy++)
                            {
                                Uint8 *ptrIm=ptrIm_st+dy*step;
                                *ptrIm=0;
                            }
                        }
                        if(havejishu==1&&eD==nStartY+nHeight-1)
                        {
                            for(dy=sT;dy<=eD;dy++)
                            {
                                Uint8 *ptrIm=ptrIm_st+dy*step;
                                *ptrIm=0;
                            }
                        }
                    }

                    for(p=minSide;p<nWidth-1;p++)
                    {
                        Int32 num=minSide;
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[nStartY*nnWidth+p+nStartX];
                        Uint8 *ptrIm_st=&matOut->ptr_uchar[nStartY*nnWidth+p+nStartX];
                        havejishu=0;

                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                if(havejishu==0)
                                {
                                    havejishu=1;
                                    nohave=0;
                                    sT=n;
                                    eD=n;
                                }
                                else if(havejishu==1)
                                {
                                    eD=n;
                                    nohave=0;
                                }
                            }
                            else if(havejishu==1)
                            {
                                nohave++;
                                if(nohave>kongxi)
                                {
                                    havejishu=0;
                                    if(eD-sT>value)
                                    {
                                        for(dy=sT;dy<=eD;dy++)
                                        {
                                            Uint8 *ptrIm=ptrIm_st+dy*step;
                                            *ptrIm=0;
                                        }
                                    }
                                    if(sT==0)
                                    {
                                        for(dy=sT;dy<=eD;dy++)
                                        {
                                            Uint8 *ptrIm=ptrIm_st+dy*step;
                                            *ptrIm=0;
                                        }
                                    }
                                }
                            }
                            ptr=ptr+step;
                        }
                        if(havejishu==1&&eD-sT>value)
                        {
                            for(dy=sT;dy<=eD;dy++)
                            {
                                Uint8 *ptrIm=ptrIm_st+dy*step;
                                *ptrIm=0;
                            }
                        }
                        if(havejishu==1&&sT==nStartY)
                        {
                            for(dy=sT;dy<=eD;dy++)
                            {
                                Uint8 *ptrIm=ptrIm_st+dy*step;
                                *ptrIm=0;
                            }
                        }
                        if(havejishu==1&&eD==nStartY+nHeight-1)
                        {
                            for(dy=sT;dy<=eD;dy++)
                            {
                                Uint8 *ptrIm=ptrIm_st+dy*step;
                                *ptrIm=0;
                            }
                        }
                    }

                    for(p=0;p<minSide;p++)
                    {
                        Int32 num=minSide-p;
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[(nStartY+p)*nnWidth+nStartX+nWidth-1];
                        Uint8 *ptrIm_st=&matOut->ptr_uchar[(nStartY+p)*nnWidth+nStartX+nWidth-1];
                        havejishu=0;

                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                if(havejishu==0)
                                {
                                    havejishu=1;
                                    nohave=0;
                                    sT=n;
                                    eD=n;
                                }
                                else if(havejishu==1)
                                {
                                    eD=n;
                                    nohave=0;
                                }
                            }
                            else if(havejishu==1)
                            {
                                nohave++;
                                if(nohave>kongxi)
                                {
                                    havejishu=0;
                                    if(eD-sT>value)
                                    {
                                        for(dy=sT;dy<=eD;dy++)
                                        {
                                            Uint8 *ptrIm=ptrIm_st+dy*step;
                                            *ptrIm=0;
                                        }
                                    }
                                    if(sT==0)
                                    {
                                        for(dy=sT;dy<=eD;dy++)
                                        {
                                            Uint8 *ptrIm=ptrIm_st+dy*step;
                                            *ptrIm=0;
                                        }
                                    }
                                }
                            }
                            ptr=ptr+step;
                        }
                        if(havejishu==1&&eD-sT>value)
                        {
                            for(dy=sT;dy<=eD;dy++)
                            {
                                Uint8 *ptrIm=ptrIm_st+dy*step;
                                *ptrIm=0;
                            }
                        }
                        if(havejishu==1&&sT==nStartY)
                        {
                            for(dy=sT;dy<=eD;dy++)
                            {
                                Uint8 *ptrIm=ptrIm_st+dy*step;
                                *ptrIm=0;
                            }
                        }
                        if(havejishu==1&&eD==nStartY+nHeight-1)
                        {
                            for(dy=sT;dy<=eD;dy++)
                            {
                                Uint8 *ptrIm=ptrIm_st+dy*step;
                                *ptrIm=0;
                            }
                        }
                    }
                }
                else
                {

                    for(p=0;p<minSide;p++)
                    {
                        Int32 num=p+1;
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[nStartY*nnWidth+p+nStartX];
                        Uint8 *ptrIm_st=&matOut->ptr_uchar[nStartY*nnWidth+p+nStartX];
                        havejishu=0;

                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                if(havejishu==0)
                                {
                                    havejishu=1;
                                    nohave=0;
                                    sT=n;
                                    eD=n;
                                }
                                else if(havejishu==1)
                                {
                                    eD=n;
                                    nohave=0;
                                }
                            }
                            else if(havejishu==1)
                            {
                                nohave++;
                                if(nohave>kongxi)
                                {
                                    havejishu=0;
                                    if(eD-sT>value)
                                    {
                                        for(dy=sT;dy<=eD;dy++)
                                        {
                                            Uint8 *ptrIm=ptrIm_st+dy*step;
                                            *ptrIm=0;
                                        }
                                    }
                                    if(sT==0)
                                    {
                                        for(dy=sT;dy<=eD;dy++)
                                        {
                                            Uint8 *ptrIm=ptrIm_st+dy*step;
                                            *ptrIm=0;
                                        }
                                    }
                                }
                            }
                            ptr=ptr+step;
                        }
                        if(havejishu==1&&eD-sT>value)
                        {
                            for(dy=sT;dy<=eD;dy++)
                            {
                                Uint8 *ptrIm=ptrIm_st+dy*step;
                                *ptrIm=0;
                            }
                        }
                        if(havejishu==1&&sT==nStartY)
                        {
                            for(dy=sT;dy<=eD;dy++)
                            {
                                Uint8 *ptrIm=ptrIm_st+dy*step;
                                *ptrIm=0;
                            }
                        }
                        if(havejishu==1&&eD==nStartY+nHeight-1)
                        {
                            for(dy=sT;dy<=eD;dy++)
                            {
                                Uint8 *ptrIm=ptrIm_st+dy*step;
                                *ptrIm=0;
                            }
                        }
                    }

                    for(p=minSide;p<nHeight;p++)
                    {
                        Int32 num=minSide;
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[(nStartY+p-minSide)*nnWidth+nStartX+nWidth-1];
                        Uint8 *ptrIm_st=&matOut->ptr_uchar[(nStartY+p-minSide)*nnWidth+nStartX+nWidth-1];
                        havejishu=0;

                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                if(havejishu==0)
                                {
                                    havejishu=1;
                                    nohave=0;
                                    sT=n;
                                    eD=n;
                                }
                                else if(havejishu==1)
                                {
                                    eD=n;
                                    nohave=0;
                                }
                            }
                            else if(havejishu==1)
                            {
                                nohave++;
                                if(nohave>kongxi)
                                {
                                    havejishu=0;
                                    if(eD-sT>value)
                                    {
                                        for(dy=sT;dy<=eD;dy++)
                                        {
                                            Uint8 *ptrIm=ptrIm_st+dy*step;
                                            *ptrIm=0;
                                        }
                                    }
                                    if(sT==0)
                                    {
                                        for(dy=sT;dy<=eD;dy++)
                                        {
                                            Uint8 *ptrIm=ptrIm_st+dy*step;
                                            *ptrIm=0;
                                        }
                                    }
                                }
                            }
                            ptr=ptr+step;
                        }
                        if(havejishu==1&&eD-sT>value)
                        {
                            for(dy=sT;dy<=eD;dy++)
                            {
                                Uint8 *ptrIm=ptrIm_st+dy*step;
                                *ptrIm=0;
                            }
                        }
                        if(havejishu==1&&sT==nStartY)
                        {
                            for(dy=sT;dy<=eD;dy++)
                            {
                                Uint8 *ptrIm=ptrIm_st+dy*step;
                                *ptrIm=0;
                            }
                        }
                        if(havejishu==1&&eD==nStartY+nHeight-1)
                        {
                            for(dy=sT;dy<=eD;dy++)
                            {
                                Uint8 *ptrIm=ptrIm_st+dy*step;
                                *ptrIm=0;
                            }
                        }
                    }

                    for(p=nHeight-minSide;p<nHeight;p++)
                    {
                        Int32 num=minSide-(p-minSide);
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[(nStartY+p)*nnWidth+nStartX+nWidth-1];
                        Uint8 *ptrIm_st=&matOut->ptr_uchar[(nStartY+p)*nnWidth+nStartX+nWidth-1];
                        havejishu=0;

                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                if(havejishu==0)
                                {
                                    havejishu=1;
                                    nohave=0;
                                    sT=n;
                                    eD=n;
                                }
                                else if(havejishu==1)
                                {
                                    eD=n;
                                    nohave=0;
                                }
                            }
                            else if(havejishu==1)
                            {
                                nohave++;
                                if(nohave>kongxi)
                                {
                                    havejishu=0;
                                    if(eD-sT>value)
                                    {
                                        for(dy=sT;dy<=eD;dy++)
                                        {
                                            Uint8 *ptrIm=ptrIm_st+dy*step;
                                            *ptrIm=0;
                                        }
                                    }
                                    if(sT==0)
                                    {
                                        for(dy=sT;dy<=eD;dy++)
                                        {
                                            Uint8 *ptrIm=ptrIm_st+dy*step;
                                            *ptrIm=0;
                                        }
                                    }
                                }
                            }
                            ptr=ptr+step;
                        }
                        if(havejishu==1&&eD-sT>value)
                        {
                            for(dy=sT;dy<=eD;dy++)
                            {
                                Uint8 *ptrIm=ptrIm_st+dy*step;
                                *ptrIm=0;
                            }
                        }
                        if(havejishu==1&&sT==nStartY)
                        {
                            for(dy=sT;dy<=eD;dy++)
                            {
                                Uint8 *ptrIm=ptrIm_st+dy*step;
                                *ptrIm=0;
                            }
                        }
                        if(havejishu==1&&eD==nStartY+nHeight-1)
                        {
                            for(dy=sT;dy<=eD;dy++)
                            {
                                Uint8 *ptrIm=ptrIm_st+dy*step;
                                *ptrIm=0;
                            }
                        }
                    }
                }
            }
            break;
            case THIN_135:
            {
                Int32 minSide=MIN(nWidth,nHeight);
                Int32 step=nnWidth+1;
                Int32 p;
                if(nWidth>=nHeight)
                {
                    for(p=0;p<minSide;p++)
                    {
                        Int32 num=minSide-p;
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[(nStartY+p)*nnWidth+nStartX];
                        Uint8 *ptrIm_st=&matOut->ptr_uchar[(nStartY+p)*nnWidth+nStartX];
                        havejishu=0;

                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                if(havejishu==0)
                                {
                                    havejishu=1;
                                    nohave=0;
                                    sT=n;
                                    eD=n;
                                }
                                else if(havejishu==1)
                                {
                                    eD=n;
                                    nohave=0;
                                }
                            }
                            else if(havejishu==1)
                            {
                                nohave++;
                                if(nohave>kongxi)
                                {
                                    havejishu=0;
                                    if(eD-sT>value)
                                    {
                                        for(dy=sT;dy<=eD;dy++)
                                        {
                                            Uint8 *ptrIm=ptrIm_st+dy*step;
                                            *ptrIm=0;
                                        }
                                    }
                                    if(sT==0)
                                    {
                                        for(dy=sT;dy<=eD;dy++)
                                        {
                                            Uint8 *ptrIm=ptrIm_st+dy*step;
                                            *ptrIm=0;
                                        }
                                    }
                                }
                            }
                            ptr=ptr+step;
                        }
                        if(havejishu==1&&eD-sT>value)
                        {
                            for(dy=sT;dy<=eD;dy++)
                            {
                                Uint8 *ptrIm=ptrIm_st+dy*step;
                                *ptrIm=0;
                            }
                        }
                        if(havejishu==1&&sT==nStartY)
                        {
                            for(dy=sT;dy<=eD;dy++)
                            {
                                Uint8 *ptrIm=ptrIm_st+dy*step;
                                *ptrIm=0;
                            }
                        }
                        if(havejishu==1&&eD==nStartY+nHeight-1)
                        {
                            for(dy=sT;dy<=eD;dy++)
                            {
                                Uint8 *ptrIm=ptrIm_st+dy*step;
                                *ptrIm=0;
                            }
                        }
                    }

                    for(p=1;p<nWidth-minSide;p++)
                    {
                        Int32 num=minSide;
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[nStartY*nnWidth+nStartX+p];
                        Uint8 *ptrIm_st=&matOut->ptr_uchar[nStartY*nnWidth+nStartX+p];
                        havejishu=0;

                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                if(havejishu==0)
                                {
                                    havejishu=1;
                                    nohave=0;
                                    sT=n;
                                    eD=n;
                                }
                                else if(havejishu==1)
                                {
                                    eD=n;
                                    nohave=0;
                                }
                            }
                            else if(havejishu==1)
                            {
                                nohave++;
                                if(nohave>kongxi)
                                {
                                    havejishu=0;
                                    if(eD-sT>value)
                                    {
                                        for(dy=sT;dy<=eD;dy++)
                                        {
                                            Uint8 *ptrIm=ptrIm_st+dy*step;
                                            *ptrIm=0;
                                        }
                                    }
                                    if(sT==0)
                                    {
                                        for(dy=sT;dy<=eD;dy++)
                                        {
                                            Uint8 *ptrIm=ptrIm_st+dy*step;
                                            *ptrIm=0;
                                        }
                                    }
                                }
                            }
                            ptr=ptr+step;
                        }
                        if(havejishu==1&&eD-sT>value)
                        {
                            for(dy=sT;dy<=eD;dy++)
                            {
                                Uint8 *ptrIm=ptrIm_st+dy*step;
                                *ptrIm=0;
                            }
                        }
                        if(havejishu==1&&sT==nStartY)
                        {
                            for(dy=sT;dy<=eD;dy++)
                            {
                                Uint8 *ptrIm=ptrIm_st+dy*step;
                                *ptrIm=0;
                            }
                        }
                        if(havejishu==1&&eD==nStartY+nHeight-1)
                        {
                            for(dy=sT;dy<=eD;dy++)
                            {
                                Uint8 *ptrIm=ptrIm_st+dy*step;
                                *ptrIm=0;
                            }
                        }
                    }

                    for(p=nWidth-minSide;p<nWidth;p++)
                    {
                        Int32 num=nWidth-p;
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[nStartY*nnWidth+nStartX+p];
                        Uint8 *ptrIm_st=&matOut->ptr_uchar[nStartY*nnWidth+nStartX+p];
                        havejishu=0;

                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                if(havejishu==0)
                                {
                                    havejishu=1;
                                    nohave=0;
                                    sT=n;
                                    eD=n;
                                }
                                else if(havejishu==1)
                                {
                                    eD=n;
                                    nohave=0;
                                }
                            }
                            else if(havejishu==1)
                            {
                                nohave++;
                                if(nohave>kongxi)
                                {
                                    havejishu=0;
                                    if(eD-sT>value)
                                    {
                                        for(dy=sT;dy<=eD;dy++)
                                        {
                                            Uint8 *ptrIm=ptrIm_st+dy*step;
                                            *ptrIm=0;
                                        }
                                    }
                                    if(sT==0)
                                    {
                                        for(dy=sT;dy<=eD;dy++)
                                        {
                                            Uint8 *ptrIm=ptrIm_st+dy*step;
                                            *ptrIm=0;
                                        }
                                    }
                                }
                            }
                            ptr=ptr+step;
                        }
                        if(havejishu==1&&eD-sT>value)
                        {
                            for(dy=sT;dy<=eD;dy++)
                            {
                                Uint8 *ptrIm=ptrIm_st+dy*step;
                                *ptrIm=0;
                            }
                        }
                        if(havejishu==1&&sT==nStartY)
                        {
                            for(dy=sT;dy<=eD;dy++)
                            {
                                Uint8 *ptrIm=ptrIm_st+dy*step;
                                *ptrIm=0;
                            }
                        }
                        if(havejishu==1&&eD==nStartY+nHeight-1)
                        {
                            for(dy=sT;dy<=eD;dy++)
                            {
                                Uint8 *ptrIm=ptrIm_st+dy*step;
                                *ptrIm=0;
                            }
                        }
                    }
                }
                else
                {

                    for(p=nHeight-minSide;p<nHeight;p++)
                    {
                        Int32 num=nHeight-p;
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[(nStartY+p)*nnWidth+nStartX];
                        Uint8 *ptrIm_st=&matOut->ptr_uchar[(nStartY+p)*nnWidth+nStartX];
                        havejishu=0;

                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                if(havejishu==0)
                                {
                                    havejishu=1;
                                    nohave=0;
                                    sT=n;
                                    eD=n;
                                }
                                else if(havejishu==1)
                                {
                                    eD=n;
                                    nohave=0;
                                }
                            }
                            else if(havejishu==1)
                            {
                                nohave++;
                                if(nohave>kongxi)
                                {
                                    havejishu=0;
                                    if(eD-sT>value)
                                    {
                                        for(dy=sT;dy<=eD;dy++)
                                        {
                                            Uint8 *ptrIm=ptrIm_st+dy*step;
                                            *ptrIm=0;
                                        }
                                    }
                                    if(sT==0)
                                    {
                                        for(dy=sT;dy<=eD;dy++)
                                        {
                                            Uint8 *ptrIm=ptrIm_st+dy*step;
                                            *ptrIm=0;
                                        }
                                    }
                                }
                            }
                            ptr=ptr+step;
                        }
                        if(havejishu==1&&eD-sT>value)
                        {
                            for(dy=sT;dy<=eD;dy++)
                            {
                                Uint8 *ptrIm=ptrIm_st+dy*step;
                                *ptrIm=0;
                            }
                        }
                        if(havejishu==1&&sT==nStartY)
                        {
                            for(dy=sT;dy<=eD;dy++)
                            {
                                Uint8 *ptrIm=ptrIm_st+dy*step;
                                *ptrIm=0;
                            }
                        }
                        if(havejishu==1&&eD==nStartY+nHeight-1)
                        {
                            for(dy=sT;dy<=eD;dy++)
                            {
                                Uint8 *ptrIm=ptrIm_st+dy*step;
                                *ptrIm=0;
                            }
                        }
                    }

                    for(p=1;p<nHeight-minSide;p++)
                    {
                        Int32 num=minSide;
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[(nStartY+p)*nnWidth+nStartX];
                        Uint8 *ptrIm_st=&matOut->ptr_uchar[(nStartY+p)*nnWidth+nStartX];
                        havejishu=0;

                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                if(havejishu==0)
                                {
                                    havejishu=1;
                                    nohave=0;
                                    sT=n;
                                    eD=n;
                                }
                                else if(havejishu==1)
                                {
                                    eD=n;
                                    nohave=0;
                                }
                            }
                            else if(havejishu==1)
                            {
                                nohave++;
                                if(nohave>kongxi)
                                {
                                    havejishu=0;
                                    if(eD-sT>value)
                                    {
                                        for(dy=sT;dy<=eD;dy++)
                                        {
                                            Uint8 *ptrIm=ptrIm_st+dy*step;
                                            *ptrIm=0;
                                        }
                                    }
                                    if(sT==0)
                                    {
                                        for(dy=sT;dy<=eD;dy++)
                                        {
                                            Uint8 *ptrIm=ptrIm_st+dy*step;
                                            *ptrIm=0;
                                        }
                                    }
                                }
                            }
                            ptr=ptr+step;
                        }
                        if(havejishu==1&&eD-sT>value)
                        {
                            for(dy=sT;dy<=eD;dy++)
                            {
                                Uint8 *ptrIm=ptrIm_st+dy*step;
                                *ptrIm=0;
                            }
                        }
                        if(havejishu==1&&sT==nStartY)
                        {
                            for(dy=sT;dy<=eD;dy++)
                            {
                                Uint8 *ptrIm=ptrIm_st+dy*step;
                                *ptrIm=0;
                            }
                        }
                        if(havejishu==1&&eD==nStartY+nHeight-1)
                        {
                            for(dy=sT;dy<=eD;dy++)
                            {
                                Uint8 *ptrIm=ptrIm_st+dy*step;
                                *ptrIm=0;
                            }
                        }
                    }

                    for(p=0;p<minSide;p++)
                    {
                        Int32 num=minSide-p;
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[nStartY*nnWidth+nStartX+p];
                        Uint8 *ptrIm_st=&matOut->ptr_uchar[nStartY*nnWidth+nStartX+p];
                        havejishu=0;

                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                if(havejishu==0)
                                {
                                    havejishu=1;
                                    nohave=0;
                                    sT=n;
                                    eD=n;
                                }
                                else if(havejishu==1)
                                {
                                    eD=n;
                                    nohave=0;
                                }
                            }
                            else if(havejishu==1)
                            {
                                nohave++;
                                if(nohave>kongxi)
                                {
                                    havejishu=0;
                                    if(eD-sT>value)
                                    {
                                        for(dy=sT;dy<=eD;dy++)
                                        {
                                            Uint8 *ptrIm=ptrIm_st+dy*step;
                                            *ptrIm=0;
                                        }
                                    }
                                    if(sT==0)
                                    {
                                        for(dy=sT;dy<=eD;dy++)
                                        {
                                            Uint8 *ptrIm=ptrIm_st+dy*step;
                                            *ptrIm=0;
                                        }
                                    }
                                }
                            }
                            ptr=ptr+step;
                        }
                        if(havejishu==1&&eD-sT>value)
                        {
                            for(dy=sT;dy<=eD;dy++)
                            {
                                Uint8 *ptrIm=ptrIm_st+dy*step;
                                *ptrIm=0;
                            }
                        }
                        if(havejishu==1&&sT==nStartY)
                        {
                            for(dy=sT;dy<=eD;dy++)
                            {
                                Uint8 *ptrIm=ptrIm_st+dy*step;
                                *ptrIm=0;
                            }
                        }
                        if(havejishu==1&&eD==nStartY+nHeight-1)
                        {
                            for(dy=sT;dy<=eD;dy++)
                            {
                                Uint8 *ptrIm=ptrIm_st+dy*step;
                                *ptrIm=0;
                            }
                        }
                    }
                }
            }
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 MyGetlathinNoHough(Mat matIn,getthin Mod,Int32 value,Mat *matOut)
    {
        Uint32 nnWidth=matIn.nWidth;
        Int32 x,y;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        Int32 havejishu=0;
        switch(matIn._type)
        {
        case CCV_8UC1:
            break;
        default:
            return 1;
            break;
        }
        MatClone(matIn,matOut);
        switch(Mod)
        {
            case THIN_X:
                for(y=nStartY;y<nStartY+nHeight;y++)
                {
                    havejishu=0;
                    for(x=nStartX;x<nStartX+nWidth;x++)
                    {
                        if(matIn.ptr_uchar[y*nnWidth+x]!=0)
                        {
                            havejishu++;
                        }
                    }
                    if(havejishu>value)
                    {
                        memset(&matOut->data[y*nnWidth+nStartX],0,nWidth);
                    }
                }
            break;
            case THIN_Y:
                for(x=nStartX;x<nStartX+nWidth;x++)
                {
                    havejishu=0;
                    for(y=nStartY;y<nStartY+nHeight;y++)
                    {
                        if(matIn.ptr_uchar[y*nnWidth+x]!=0)
                        {
                            havejishu++;
                        }
                    }
                    if(havejishu>value)
                    {
                        for(y=nStartY;y<nStartY+nHeight;y++)
                        {
                            matOut->ptr_uchar[y*nnWidth+x]=0;
                        }
                    }
                }
            break;
            case THIN_45:
            {
                Int32 minSide=MIN(nWidth,nHeight);
                Int32 step=nnWidth-1;
                Int32 p;
                if(nWidth>=nHeight)
                {

                    for(p=0;p<minSide;p++)
                    {
                        Int32 num=p+1;
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[nStartY*nnWidth+p+nStartX];
                        Uint8 *ptrIm=&matOut->ptr_uchar[nStartY*nnWidth+p+nStartX];
                        havejishu=0;

                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                havejishu++;
                            }
                            ptr=ptr+step;
                        }
                        if(havejishu>value)
                        {
                            for(n=0;n<num;n++)
                            {
                                *ptrIm=0;
                                ptrIm=ptrIm+step;
                            }
                        }
                    }

                    for(p=minSide;p<nWidth-1;p++)
                    {
                        Int32 num=minSide;
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[nStartY*nnWidth+p+nStartX];
                        Uint8 *ptrIm=&matOut->ptr_uchar[nStartY*nnWidth+p+nStartX];
                        havejishu=0;

                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                havejishu++;
                            }
                            ptr=ptr+step;
                        }
                        if(havejishu>value)
                        {
                            for(n=0;n<num;n++)
                            {
                                *ptrIm=0;
                                ptrIm=ptrIm+step;
                            }
                        }
                    }

                    for(p=0;p<minSide;p++)
                    {
                        Int32 num=minSide-p;
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[(nStartY+p)*nnWidth+nStartX+nWidth-1];
                        Uint8 *ptrIm=&matOut->ptr_uchar[(nStartY+p)*nnWidth+nStartX+nWidth-1];
                        havejishu=0;

                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                havejishu++;
                            }
                            ptr=ptr+step;
                        }
                        if(havejishu>value)
                        {
                            for(n=0;n<num;n++)
                            {
                                *ptrIm=0;
                                ptrIm=ptrIm+step;
                            }
                        }
                    }
                }
                else
                {

                    for(p=0;p<minSide;p++)
                    {
                        Int32 num=p+1;
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[nStartY*nnWidth+p+nStartX];
                        Uint8 *ptrIm=&matOut->ptr_uchar[nStartY*nnWidth+p+nStartX];
                        havejishu=0;

                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                havejishu++;
                            }
                            ptr=ptr+step;
                        }
                        if(havejishu>value)
                        {
                            for(n=0;n<num;n++)
                            {
                                *ptrIm=0;
                                ptrIm=ptrIm+step;
                            }
                        }
                    }

                    for(p=minSide;p<nHeight;p++)
                    {
                        Int32 num=minSide;
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[(nStartY+p-minSide)*nnWidth+nStartX+nWidth-1];
                        Uint8 *ptrIm=&matOut->ptr_uchar[(nStartY+p-minSide)*nnWidth+nStartX+nWidth-1];
                        havejishu=0;

                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                havejishu++;
                            }
                            ptr=ptr+step;
                        }
                        if(havejishu>value)
                        {
                            for(n=0;n<num;n++)
                            {
                                *ptrIm=0;
                                ptrIm=ptrIm+step;
                            }
                        }
                    }

                    for(p=nHeight-minSide;p<nHeight;p++)
                    {
                        Int32 num=minSide-(p-minSide);
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[(nStartY+p)*nnWidth+nStartX+nWidth-1];
                        Uint8 *ptrIm=&matOut->ptr_uchar[(nStartY+p)*nnWidth+nStartX+nWidth-1];
                        havejishu=0;

                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                havejishu++;
                            }
                            ptr=ptr+step;
                        }
                        if(havejishu>value)
                        {
                            for(n=0;n<num;n++)
                            {
                                *ptrIm=0;
                                ptrIm=ptrIm+step;
                            }
                        }
                    }
                }
            }
            break;
            case THIN_135:
            {
                Int32 minSide=MIN(nWidth,nHeight);
                Int32 step=nnWidth+1;
                Int32 p;
                if(nWidth>=nHeight)
                {

                    for(p=0;p<minSide;p++)
                    {
                        Int32 num=minSide-p;
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[(nStartY+p)*nnWidth+nStartX];
                        Uint8 *ptrIm=&matOut->ptr_uchar[(nStartY+p)*nnWidth+nStartX];
                        havejishu=0;

                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                havejishu++;
                            }
                            ptr=ptr+step;
                        }
                        if(havejishu>value)
                        {
                            for(n=0;n<num;n++)
                            {
                                *ptrIm=0;
                                ptrIm=ptrIm+step;
                            }
                        }
                    }

                    for(p=1;p<nWidth-minSide;p++)
                    {
                        Int32 num=minSide;
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[nStartY*nnWidth+nStartX+p];
                        Uint8 *ptrIm=&matOut->ptr_uchar[nStartY*nnWidth+nStartX+p];
                        havejishu=0;

                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                havejishu++;
                            }
                            ptr=ptr+step;
                        }
                        if(havejishu>value)
                        {
                            for(n=0;n<num;n++)
                            {
                                *ptrIm=0;
                                ptrIm=ptrIm+step;
                            }
                        }
                    }

                    for(p=nWidth-minSide;p<nWidth;p++)
                    {
                        Int32 num=nWidth-p;
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[nStartY*nnWidth+nStartX+p];
                        Uint8 *ptrIm=&matOut->ptr_uchar[nStartY*nnWidth+nStartX+p];
                        havejishu=0;

                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                havejishu++;
                            }
                            ptr=ptr+step;
                        }
                        if(havejishu>value)
                        {
                            for(n=0;n<num;n++)
                            {
                                *ptrIm=0;
                                ptrIm=ptrIm+step;
                            }
                        }
                    }
                }
                else
                {

                    for(p=nHeight-minSide;p<nHeight;p++)
                    {
                        Int32 num=nHeight-p;
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[(nStartY+p)*nnWidth+nStartX];
                        Uint8 *ptrIm=&matOut->ptr_uchar[(nStartY+p)*nnWidth+nStartX];
                        havejishu=0;

                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                havejishu++;
                            }
                            ptr=ptr+step;
                        }
                        if(havejishu>value)
                        {
                            for(n=0;n<num;n++)
                            {
                                *ptrIm=0;
                                ptrIm=ptrIm+step;
                            }
                        }
                    }

                    for(p=1;p<nHeight-minSide;p++)
                    {
                        Int32 num=minSide;
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[(nStartY+p)*nnWidth+nStartX];
                        Uint8 *ptrIm=&matOut->ptr_uchar[(nStartY+p)*nnWidth+nStartX];
                        havejishu=0;

                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                havejishu++;
                            }
                            ptr=ptr+step;
                        }
                        if(havejishu>value)
                        {
                            for(n=0;n<num;n++)
                            {
                                *ptrIm=0;
                                ptrIm=ptrIm+step;
                            }
                        }
                    }

                    for(p=0;p<minSide;p++)
                    {
                        Int32 num=minSide-p;
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[nStartY*nnWidth+nStartX+p];
                        Uint8 *ptrIm=&matOut->ptr_uchar[nStartY*nnWidth+nStartX+p];
                        havejishu=0;

                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                havejishu++;
                            }
                            ptr=ptr+step;
                        }
                        if(havejishu>value)
                        {
                            for(n=0;n<num;n++)
                            {
                                *ptrIm=0;
                                ptrIm=ptrIm+step;
                            }
                        }
                    }
                }
            }
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 MyGetlanothinNoHough(Mat matIn,getthin Mod,Int32 value,Mat *matOut)
    {
        Uint32 nnWidth=matIn.nWidth;
        Int32 x,y;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        Int32 ST,ED;
        switch(matIn._type)
        {
        case CCV_8UC1:
            break;
        default:
            return 1;
            break;
        }
        MatClone(matIn,matOut);
        switch(Mod)
        {
            case THIN_X:
                for(y=nStartY;y<nStartY+nHeight;y++)
                {
                    ST=-1;
                    ED=-1;
                    for(x=nStartX;x<nStartX+nWidth;x++)
                    {
                        if(matIn.ptr_uchar[y*nnWidth+x]!=0)
                        {
                            ST=x;
                            break;
                        }
                    }
                    for(x=nStartX+nWidth-1;x>=nStartX;x--)
                    {
                        if(matIn.ptr_uchar[y*nnWidth+x]!=0)
                        {
                            ED=x;
                            break;
                        }
                    }
                    if(ED!=-1)
                    {
                        if(ED-ST>value||ED==nStartX+nWidth-1||ST==nStartX)
                        memset(&matOut->data[y*nnWidth+nStartX],0,nWidth);
                    }
                }
            break;
            case THIN_Y:
                for(x=nStartX;x<nStartX+nWidth;x++)
                {
                    ST=-1;
                    ED=-1;
                    for(y=nStartY;y<nStartY+nHeight;y++)
                    {
                        if(matIn.ptr_uchar[y*nnWidth+x]!=0)
                        {
                            ST=y;
                            break;
                        }
                    }
                    for(y=nStartY+nHeight-1;y>=nStartY;y--)
                    {
                        if(matIn.ptr_uchar[y*nnWidth+x]!=0)
                        {
                            ED=y;
                            break;
                        }
                    }
                    if(ED!=-1)
                    {
                        if(ED-ST>value||ED==nStartY+nHeight-1||ST==nStartY)
                        {
                            for(y=nStartY;y<nStartY+nHeight;y++)
                            {
                                matOut->ptr_uchar[y*nnWidth+x]=0;
                            }
                        }
                    }
                }
            break;
            case THIN_45:
            {
                Int32 minSide=MIN(nWidth,nHeight);
                Int32 step=nnWidth-1;
                Int32 p;
                if(nWidth>=nHeight)
                {
                    for(p=0;p<minSide;p++)
                    {
                        Int32 num=p+1;
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[nStartY*nnWidth+p+nStartX];
                        Uint8 *ptr_ed=ptr+step*(num-1);
                        Uint8 *ptrIm_st=&matOut->ptr_uchar[nStartY*nnWidth+p+nStartX];
                        ST=-1;
                        ED=-1;
                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                ST=n;
                                break;
                            }
                            ptr=ptr+step;
                        }
                        ptr=ptr_ed;
                        for(n=num-1;n>=0;n--)
                        {
                            if(*ptr!=0)
                            {
                                ED=n;
                                break;
                            }
                            ptr=ptr-step;
                        }
                        if(ED!=-1)
                        {
                            if(ED-ST>value||ED==num-1||ST==0)
                            {
                                for(n=0;n<num;n++)
                                {
                                    *ptrIm_st=0;
                                    ptrIm_st=ptrIm_st+step;
                                }
                            }
                        }
                    }
                    for(p=minSide;p<nWidth-1;p++)
                    {
                        Int32 num=minSide;
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[nStartY*nnWidth+p+nStartX];
                        Uint8 *ptr_ed=ptr+step*(num-1);
                        Uint8 *ptrIm_st=&matOut->ptr_uchar[nStartY*nnWidth+p+nStartX];
                        ST=-1;
                        ED=-1;
                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                ST=n;
                                break;
                            }
                            ptr=ptr+step;
                        }
                        ptr=ptr_ed;
                        for(n=num-1;n>=0;n--)
                        {
                            if(*ptr!=0)
                            {
                                ED=n;
                                break;
                            }
                            ptr=ptr-step;
                        }
                        if(ED!=-1)
                        {
                            if(ED-ST>value||ED==num-1||ST==0)
                            {
                                for(n=0;n<num;n++)
                                {
                                    *ptrIm_st=0;
                                    ptrIm_st=ptrIm_st+step;
                                }
                            }
                        }
                    }
                    for(p=0;p<minSide;p++)
                    {
                        Int32 num=minSide-p;
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[(nStartY+p)*nnWidth+nStartX+nWidth-1];
                        Uint8 *ptr_ed=ptr+step*(num-1);
                        Uint8 *ptrIm_st=&matOut->ptr_uchar[(nStartY+p)*nnWidth+nStartX+nWidth-1];
                        ST=-1;
                        ED=-1;
                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                ST=n;
                                break;
                            }
                            ptr=ptr+step;
                        }
                        ptr=ptr_ed;
                        for(n=num-1;n>=0;n--)
                        {
                            if(*ptr!=0)
                            {
                                ED=n;
                                break;
                            }
                            ptr=ptr-step;
                        }
                        if(ED!=-1)
                        {
                            if(ED-ST>value||ED==num-1||ST==0)
                            {
                                for(n=0;n<num;n++)
                                {
                                    *ptrIm_st=0;
                                    ptrIm_st=ptrIm_st+step;
                                }
                            }
                        }
                    }
                }
                else
                {
                    for(p=0;p<minSide;p++)
                    {
                        Int32 num=p+1;
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[nStartY*nnWidth+p+nStartX];
                        Uint8 *ptr_ed=ptr+step*(num-1);
                        Uint8 *ptrIm_st=&matOut->ptr_uchar[nStartY*nnWidth+p+nStartX];
                        ST=-1;
                        ED=-1;
                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                ST=n;
                                break;
                            }
                            ptr=ptr+step;
                        }
                        ptr=ptr_ed;
                        for(n=num-1;n>=0;n--)
                        {
                            if(*ptr!=0)
                            {
                                ED=n;
                                break;
                            }
                            ptr=ptr-step;
                        }
                        if(ED!=-1)
                        {
                            if(ED-ST>value||ED==num-1||ST==0)
                            {
                                for(n=0;n<num;n++)
                                {
                                    *ptrIm_st=0;
                                    ptrIm_st=ptrIm_st+step;
                                }
                            }
                        }
                    }
                    for(p=minSide;p<nHeight;p++)
                    {
                        Int32 num=minSide;
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[(nStartY+p-minSide)*nnWidth+nStartX+nWidth-1];
                        Uint8 *ptr_ed=ptr+step*(num-1);
                        Uint8 *ptrIm_st=&matOut->ptr_uchar[(nStartY+p-minSide)*nnWidth+nStartX+nWidth-1];
                        ST=-1;
                        ED=-1;
                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                ST=n;
                                break;
                            }
                            ptr=ptr+step;
                        }
                        ptr=ptr_ed;
                        for(n=num-1;n>=0;n--)
                        {
                            if(*ptr!=0)
                            {
                                ED=n;
                                break;
                            }
                            ptr=ptr-step;
                        }
                        if(ED!=-1)
                        {
                            if(ED-ST>value||ED==num-1||ST==0)
                            {
                                for(n=0;n<num;n++)
                                {
                                    *ptrIm_st=0;
                                    ptrIm_st=ptrIm_st+step;
                                }
                            }
                        }
                    }
                    for(p=nHeight-minSide;p<nHeight;p++)
                    {
                        Int32 num=minSide-(p-minSide);
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[(nStartY+p)*nnWidth+nStartX+nWidth-1];
                        Uint8 *ptr_ed=ptr+step*(num-1);
                        Uint8 *ptrIm_st=&matOut->ptr_uchar[(nStartY+p)*nnWidth+nStartX+nWidth-1];
                        ST=-1;
                        ED=-1;
                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                ST=n;
                                break;
                            }
                            ptr=ptr+step;
                        }
                        ptr=ptr_ed;
                        for(n=num-1;n>=0;n--)
                        {
                            if(*ptr!=0)
                            {
                                ED=n;
                                break;
                            }
                            ptr=ptr-step;
                        }
                        if(ED!=-1)
                        {
                            if(ED-ST>value||ED==num-1||ST==0)
                            {
                                for(n=0;n<num;n++)
                                {
                                    *ptrIm_st=0;
                                    ptrIm_st=ptrIm_st+step;
                                }
                            }
                        }
                    }
                }
            }
            break;
            case THIN_135:
            {
                Int32 minSide=MIN(nWidth,nHeight);
                Int32 step=nnWidth+1;
                Int32 p;
                if(nWidth>=nHeight)
                {
                    for(p=0;p<minSide;p++)
                    {
                        Int32 num=minSide-p;
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[(nStartY+p)*nnWidth+nStartX];
                        Uint8 *ptr_ed=ptr+step*(num-1);
                        Uint8 *ptrIm_st=&matOut->ptr_uchar[(nStartY+p)*nnWidth+nStartX];
                        ST=-1;
                        ED=-1;
                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                ST=n;
                                break;
                            }
                            ptr=ptr+step;
                        }
                        ptr=ptr_ed;
                        for(n=num-1;n>=0;n--)
                        {
                            if(*ptr!=0)
                            {
                                ED=n;
                                break;
                            }
                            ptr=ptr-step;
                        }
                        if(ED!=-1)
                        {
                            if(ED-ST>value||ED==num-1||ST==0)
                            {
                                for(n=0;n<num;n++)
                                {
                                    *ptrIm_st=0;
                                    ptrIm_st=ptrIm_st+step;
                                }
                            }
                        }
                    }

                    for(p=1;p<nWidth-minSide;p++)
                    {
                        Int32 num=minSide;
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[nStartY*nnWidth+nStartX+p];
                        Uint8 *ptr_ed=ptr+step*(num-1);
                        Uint8 *ptrIm_st=&matOut->ptr_uchar[nStartY*nnWidth+nStartX+p];
                        ST=-1;
                        ED=-1;
                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                ST=n;
                                break;
                            }
                            ptr=ptr+step;
                        }
                        ptr=ptr_ed;
                        for(n=num-1;n>=0;n--)
                        {
                            if(*ptr!=0)
                            {
                                ED=n;
                                break;
                            }
                            ptr=ptr-step;
                        }
                        if(ED!=-1)
                        {
                            if(ED-ST>value||ED==num-1||ST==0)
                            {
                                for(n=0;n<num;n++)
                                {
                                    *ptrIm_st=0;
                                    ptrIm_st=ptrIm_st+step;
                                }
                            }
                        }
                    }

                    for(p=nWidth-minSide;p<nWidth;p++)
                    {
                        Int32 num=nWidth-p;
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[nStartY*nnWidth+nStartX+p];
                        Uint8 *ptr_ed=ptr+step*(num-1);
                        Uint8 *ptrIm_st=&matOut->ptr_uchar[nStartY*nnWidth+nStartX+p];
                        ST=-1;
                        ED=-1;
                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                ST=n;
                                break;
                            }
                            ptr=ptr+step;
                        }
                        ptr=ptr_ed;
                        for(n=num-1;n>=0;n--)
                        {
                            if(*ptr!=0)
                            {
                                ED=n;
                                break;
                            }
                            ptr=ptr-step;
                        }
                        if(ED!=-1)
                        {
                            if(ED-ST>value||ED==num-1||ST==0)
                            {
                                for(n=0;n<num;n++)
                                {
                                    *ptrIm_st=0;
                                    ptrIm_st=ptrIm_st+step;
                                }
                            }
                        }
                    }
                }
                else
                {
                    for(p=nHeight-minSide;p<nHeight;p++)
                    {
                        Int32 num=nHeight-p;
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[(nStartY+p)*nnWidth+nStartX];
                        Uint8 *ptr_ed=ptr+step*(num-1);
                        Uint8 *ptrIm_st=&matOut->ptr_uchar[(nStartY+p)*nnWidth+nStartX];
                        ST=-1;
                        ED=-1;
                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                ST=n;
                                break;
                            }
                            ptr=ptr+step;
                        }
                        ptr=ptr_ed;
                        for(n=num-1;n>=0;n--)
                        {
                            if(*ptr!=0)
                            {
                                ED=n;
                                break;
                            }
                            ptr=ptr-step;
                        }
                        if(ED!=-1)
                        {
                            if(ED-ST>value||ED==num-1||ST==0)
                            {
                                for(n=0;n<num;n++)
                                {
                                    *ptrIm_st=0;
                                    ptrIm_st=ptrIm_st+step;
                                }
                            }
                        }
                    }
                    for(p=1;p<nHeight-minSide;p++)
                    {
                        Int32 num=minSide;
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[(nStartY+p)*nnWidth+nStartX];
                        Uint8 *ptr_ed=ptr+step*(num-1);
                        Uint8 *ptrIm_st=&matOut->ptr_uchar[(nStartY+p)*nnWidth+nStartX];
                        ST=-1;
                        ED=-1;
                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                ST=n;
                                break;
                            }
                            ptr=ptr+step;
                        }
                        ptr=ptr_ed;
                        for(n=num-1;n>=0;n--)
                        {
                            if(*ptr!=0)
                            {
                                ED=n;
                                break;
                            }
                            ptr=ptr-step;
                        }
                        if(ED!=-1)
                        {
                            if(ED-ST>value||ED==num-1||ST==0)
                            {
                                for(n=0;n<num;n++)
                                {
                                    *ptrIm_st=0;
                                    ptrIm_st=ptrIm_st+step;
                                }
                            }
                        }
                    }
                    for(p=0;p<minSide;p++)
                    {
                        Int32 num=minSide-p;
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[nStartY*nnWidth+nStartX+p];
                        Uint8 *ptr_ed=ptr+step*(num-1);
                        Uint8 *ptrIm_st=&matOut->ptr_uchar[nStartY*nnWidth+nStartX+p];
                        ST=-1;
                        ED=-1;
                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                ST=n;
                                break;
                            }
                            ptr=ptr+step;
                        }
                        ptr=ptr_ed;
                        for(n=num-1;n>=0;n--)
                        {
                            if(*ptr!=0)
                            {
                                ED=n;
                                break;
                            }
                            ptr=ptr-step;
                        }
                        if(ED!=-1)
                        {
                            if(ED-ST>value||ED==num-1||ST==0)
                            {
                                for(n=0;n<num;n++)
                                {
                                    *ptrIm_st=0;
                                    ptrIm_st=ptrIm_st+step;
                                }
                            }
                        }
                    }
                }
            }
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 MyGeteverfirstbry(Mat matIn,getever Mod,Int32 kongxi,Mat *matOut)
    {
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        Int32 nnWidth=matIn.nWidth;
        Int32 x,y,dy;
        Uint8 havejishu;
        Int32 sT,eD;
        Uint8 nohave;
        switch(matIn._type)
        {
        case CCV_8UC1:
            break;
        default:
            return 1;
            break;
        }
        MatClone(matIn,matOut);
        switch(Mod)
        {
            case MHC_R_TO_L:
                for(y=nStartY;y<nStartY+nHeight;y++)
                {
                    havejishu=0;
                    for(x=nStartX+nWidth-1;x>=nStartX;x--)
                    {
                        if(matIn.ptr_uchar[y*nnWidth+x]!=0)
                        {
                            if(havejishu==0)
                            {
                                havejishu=1;
                                nohave=0;
                                sT=x;
                            }
                            else if(havejishu==1)
                            {
                                sT=x;
                                nohave=0;
                            }
                        }
                        else if(havejishu==1)
                        {
                            nohave++;
                            if(nohave>kongxi)
                            {
                                havejishu=0;
                                memset(&matOut->ptr_uchar[y*nnWidth],0,sT);
                                break;
                            }
                        }
                    }
                }
            break;
            case MHC_L_TO_R:
                for(y=nStartY;y<nStartY+nHeight;y++)
                {
                    havejishu=0;
                    for(x=nStartX;x<nStartX+nWidth;x++)
                    {
                        if(matIn.ptr_uchar[y*nnWidth+x]!=0)
                        {
                            if(havejishu==0)
                            {
                                havejishu=1;
                                nohave=0;
                                eD=x;
                            }
                            else if(havejishu==1)
                            {
                                eD=x;
                                nohave=0;
                            }
                        }
                        else if(havejishu==1)
                        {
                            nohave++;
                            if(nohave>kongxi)
                            {
                                havejishu=0;
                                memset(&matOut->ptr_uchar[y*nnWidth+eD+1],0,nStartX+nWidth-(eD+1));
                                break;
                            }
                        }
                    }
                }
            break;
            case MHC_T_TO_B:
                for(x=nStartX;x<nStartX+nWidth;x++)
                {
                    havejishu=0;
                    for(y=nStartY;y<nStartY+nHeight;y++)
                    {
                        if(matIn.ptr_uchar[y*nnWidth+x]!=0)
                        {
                            if(havejishu==0)
                            {
                                havejishu=1;
                                nohave=0;
                                sT=x;
                            }
                            else if(havejishu==1)
                            {
                                sT=x;
                                nohave=0;
                            }
                        }
                        else if(havejishu==1)
                        {
                            nohave++;
                            if(nohave>kongxi)
                            {
                                havejishu=0;
                                for(dy=sT+1;dy<nStartY+nHeight;dy++)
                                {
                                    matOut->ptr_uchar[dy*nnWidth+x]=0;
                                }
                                break;
                            }
                        }
                    }
                }
            break;
            case MHC_B_TO_T:
                for(x=nStartX;x<nStartX+nWidth;x++)
                {
                    havejishu=0;
                    for(y=nStartY+nHeight-1;y>=nStartY;y--)
                    {
                        if(matIn.ptr_uchar[y*nnWidth+x]!=0)
                        {
                            if(havejishu==0)
                            {
                                havejishu=1;
                                nohave=0;
                                eD=x;
                            }
                            else if(havejishu==1)
                            {
                                eD=x;
                                nohave=0;
                            }
                        }
                        else if(havejishu==1)
                        {
                            nohave++;
                            if(nohave>kongxi)
                            {
                                havejishu=0;
                                for(dy=0;dy<eD-1;dy++)
                                {
                                    matOut->ptr_uchar[dy*nnWidth+x]=0;
                                }
                                break;
                            }
                        }
                    }
                }
            break;
            case MHC_T_TO_B_45:
            {
                Int32 minSide=MIN(nWidth,nHeight);
                Int32 step=nnWidth-1;
                Int32 p;
                if(nWidth>=nHeight)
                {
                    for(p=0;p<minSide;p++)
                    {
                        Int32 num=p+1;
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[nStartY*nnWidth+p+nStartX];
                        Int32 count;
                        havejishu=0;
                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                if(havejishu==0)
                                {
                                    havejishu=1;
                                    nohave=0;
                                    eD=n;
                                }
                                else if(havejishu==1)
                                {
                                    eD=n;
                                    nohave=0;
                                }
                            }
                            else if(havejishu==1)
                            {
                                nohave++;
                                if(nohave>kongxi)
                                {
                                    Int32 t,st;
                                    havejishu=0;
                                    st=eD+1;
                                    if(st>num)
                                        st=num;
                                    count=num-st;
                                    for(t=0;t<count;t++)
                                    {
                                        ptr=ptr+step;
                                        *ptr=0;
                                    }
                                    break;
                                }
                            }
                            ptr=ptr+step;
                        }
                    }

                    for(p=minSide;p<nWidth-1;p++)
                    {
                        Int32 num=minSide;
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[nStartY*nnWidth+p+nStartX];
                        Int32 count;
                        havejishu=0;
                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                if(havejishu==0)
                                {
                                    havejishu=1;
                                    nohave=0;
                                    eD=n;
                                }
                                else if(havejishu==1)
                                {
                                    eD=n;
                                    nohave=0;
                                }
                            }
                            else if(havejishu==1)
                            {
                                nohave++;
                                if(nohave>kongxi)
                                {
                                    Int32 t,st;
                                    havejishu=0;
                                    st=eD+1;
                                    if(st>num)
                                        st=num;
                                    count=num-st;
                                    for(t=0;t<count;t++)
                                    {
                                        ptr=ptr+step;
                                        *ptr=0;
                                    }
                                    break;
                                }
                            }
                            ptr=ptr+step;
                        }
                    }

                    for(p=0;p<minSide;p++)
                    {
                        Int32 num=minSide-p;
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[(nStartY+p)*nnWidth+nStartX+nWidth-1];
                        Int32 count;
                        havejishu=0;
                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                if(havejishu==0)
                                {
                                    havejishu=1;
                                    nohave=0;
                                    eD=n;
                                }
                                else if(havejishu==1)
                                {
                                    eD=n;
                                    nohave=0;
                                }
                            }
                            else if(havejishu==1)
                            {
                                nohave++;
                                if(nohave>kongxi)
                                {
                                    Int32 t,st;
                                    havejishu=0;
                                    st=eD+1;
                                    if(st>num)
                                        st=num;
                                    count=num-st;
                                    for(t=0;t<count;t++)
                                    {
                                        ptr=ptr+step;
                                        *ptr=0;
                                    }
                                    break;
                                }
                            }
                            ptr=ptr+step;
                        }
                    }
                }
                else
                {
                    for(p=0;p<minSide;p++)
                    {
                        Int32 num=p+1;
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[nStartY*nnWidth+p+nStartX];
                        Int32 count;
                        havejishu=0;
                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                if(havejishu==0)
                                {
                                    havejishu=1;
                                    nohave=0;
                                    eD=n;
                                }
                                else if(havejishu==1)
                                {
                                    eD=n;
                                    nohave=0;
                                }
                            }
                            else if(havejishu==1)
                            {
                                nohave++;
                                if(nohave>kongxi)
                                {
                                    Int32 t,st;
                                    havejishu=0;
                                    st=eD+1;
                                    if(st>num)
                                        st=num;
                                    count=num-st;
                                    for(t=0;t<count;t++)
                                    {
                                        ptr=ptr+step;
                                        *ptr=0;
                                    }
                                    break;
                                }
                            }
                            ptr=ptr+step;
                        }
                    }

                    for(p=minSide;p<nHeight;p++)
                    {
                        Int32 num=minSide;
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[(nStartY+p-minSide)*nnWidth+nStartX+nWidth-1];
                        Int32 count;
                        havejishu=0;
                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                if(havejishu==0)
                                {
                                    havejishu=1;
                                    nohave=0;
                                    eD=n;
                                }
                                else if(havejishu==1)
                                {
                                    eD=n;
                                    nohave=0;
                                }
                            }
                            else if(havejishu==1)
                            {
                                nohave++;
                                if(nohave>kongxi)
                                {
                                    Int32 t,st;
                                    havejishu=0;
                                    st=eD+1;
                                    if(st>num)
                                        st=num;
                                    count=num-st;
                                    for(t=0;t<count;t++)
                                    {
                                        ptr=ptr+step;
                                        *ptr=0;
                                    }
                                    break;
                                }
                            }
                            ptr=ptr+step;
                        }
                    }

                    for(p=nHeight-minSide;p<nHeight;p++)
                    {
                        Int32 num=minSide-(p-minSide);
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[(nStartY+p)*nnWidth+nStartX+nWidth-1];
                        Int32 count;
                        havejishu=0;
                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                if(havejishu==0)
                                {
                                    havejishu=1;
                                    nohave=0;
                                    eD=n;
                                }
                                else if(havejishu==1)
                                {
                                    eD=n;
                                    nohave=0;
                                }
                            }
                            else if(havejishu==1)
                            {
                                nohave++;
                                if(nohave>kongxi)
                                {
                                    Int32 t,st;
                                    havejishu=0;
                                    st=eD+1;
                                    if(st>num)
                                        st=num;
                                    count=num-st;
                                    for(t=0;t<count;t++)
                                    {
                                        ptr=ptr+step;
                                        *ptr=0;
                                    }
                                    break;
                                }
                            }
                            ptr=ptr+step;
                        }
                    }
                }
            }
            break;
            case MHC_B_TO_T_45:
            {
                Int32 minSide=MIN(nWidth,nHeight);
                Int32 step=nnWidth-1;
                Int32 p;
                if(nWidth>=nHeight)
                {

                    for(p=0;p<minSide;p++)
                    {
                        Int32 num=p+1;
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[nStartY*nnWidth+p+nStartX];
                        Uint8 *ptr_ed=ptr+step*(num-1);
                        Int32 count;
                        havejishu=0;
                        ptr=ptr_ed;
                        for(n=num-1;n>=0;n--)
                        {
                            if(*ptr!=0)
                            {
                                if(havejishu==0)
                                {
                                    havejishu=1;
                                    nohave=0;
                                    eD=n;
                                }
                                else if(havejishu==1)
                                {
                                    eD=n;
                                    nohave=0;
                                }
                            }
                            else if(havejishu==1)
                            {
                                nohave++;
                                if(nohave>kongxi)
                                {
                                    Int32 t,st;
                                    havejishu=0;
                                    st=eD-1;
                                    if(st<0)
                                        st=0;
                                    count=st;
                                    for(t=0;t<count;t++)
                                    {
                                        ptr=ptr-step;
                                        *ptr=0;
                                    }
                                    break;
                                }
                            }
                            ptr=ptr-step;
                        }
                    }

                    for(p=minSide;p<nWidth-1;p++)
                    {
                        Int32 num=minSide;
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[nStartY*nnWidth+p+nStartX];
                        Uint8 *ptr_ed=ptr+step*(num-1);
                        Int32 count;
                        havejishu=0;
                        ptr=ptr_ed;
                        for(n=num-1;n>=0;n--)
                        {
                            if(*ptr!=0)
                            {
                                if(havejishu==0)
                                {
                                    havejishu=1;
                                    nohave=0;
                                    eD=n;
                                }
                                else if(havejishu==1)
                                {
                                    eD=n;
                                    nohave=0;
                                }
                            }
                            else if(havejishu==1)
                            {
                                nohave++;
                                if(nohave>kongxi)
                                {
                                    Int32 t,st;
                                    havejishu=0;
                                    st=eD-1;
                                    if(st<0)
                                        st=0;
                                    count=st;
                                    for(t=0;t<count;t++)
                                    {
                                        ptr=ptr-step;
                                        *ptr=0;
                                    }
                                    break;
                                }
                            }
                            ptr=ptr-step;
                        }
                    }

                    for(p=0;p<minSide;p++)
                    {
                        Int32 num=minSide-p;
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[(nStartY+p)*nnWidth+nStartX+nWidth-1];
                        Uint8 *ptr_ed=ptr+step*(num-1);
                        Int32 count;
                        havejishu=0;
                        ptr=ptr_ed;
                        for(n=num-1;n>=0;n--)
                        {
                            if(*ptr!=0)
                            {
                                if(havejishu==0)
                                {
                                    havejishu=1;
                                    nohave=0;
                                    eD=n;
                                }
                                else if(havejishu==1)
                                {
                                    eD=n;
                                    nohave=0;
                                }
                            }
                            else if(havejishu==1)
                            {
                                nohave++;
                                if(nohave>kongxi)
                                {
                                    Int32 t,st;
                                    havejishu=0;
                                    st=eD-1;
                                    if(st<0)
                                        st=0;
                                    count=st;
                                    for(t=0;t<count;t++)
                                    {
                                        ptr=ptr-step;
                                        *ptr=0;
                                    }
                                    break;
                                }
                            }
                            ptr=ptr-step;
                        }
                    }
                }
                else
                {
                    for(p=0;p<minSide;p++)
                    {
                        Int32 num=p+1;
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[nStartY*nnWidth+p+nStartX];
                        Uint8 *ptr_ed=ptr+step*(num-1);
                        Int32 count;
                        havejishu=0;
                        ptr=ptr_ed;
                        for(n=num-1;n>=0;n--)
                        {
                            if(*ptr!=0)
                            {
                                if(havejishu==0)
                                {
                                    havejishu=1;
                                    nohave=0;
                                    eD=n;
                                }
                                else if(havejishu==1)
                                {
                                    eD=n;
                                    nohave=0;
                                }
                            }
                            else if(havejishu==1)
                            {
                                nohave++;
                                if(nohave>kongxi)
                                {
                                    Int32 t,st;
                                    havejishu=0;
                                    st=eD-1;
                                    if(st<0)
                                        st=0;
                                    count=st;
                                    for(t=0;t<count;t++)
                                    {
                                        ptr=ptr-step;
                                        *ptr=0;
                                    }
                                    break;
                                }
                            }
                            ptr=ptr-step;
                        }
                    }

                    for(p=minSide;p<nHeight;p++)
                    {
                        Int32 num=minSide;
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[(nStartY+p-minSide)*nnWidth+nStartX+nWidth-1];
                        Uint8 *ptr_ed=ptr+step*(num-1);
                        Int32 count;
                        havejishu=0;
                        ptr=ptr_ed;
                        for(n=num-1;n>=0;n--)
                        {
                            if(*ptr!=0)
                            {
                                if(havejishu==0)
                                {
                                    havejishu=1;
                                    nohave=0;
                                    eD=n;
                                }
                                else if(havejishu==1)
                                {
                                    eD=n;
                                    nohave=0;
                                }
                            }
                            else if(havejishu==1)
                            {
                                nohave++;
                                if(nohave>kongxi)
                                {
                                    Int32 t,st;
                                    havejishu=0;
                                    st=eD-1;
                                    if(st<0)
                                        st=0;
                                    count=st;
                                    for(t=0;t<count;t++)
                                    {
                                        ptr=ptr-step;
                                        *ptr=0;
                                    }
                                    break;
                                }
                            }
                            ptr=ptr-step;
                        }
                    }

                    for(p=nHeight-minSide;p<nHeight;p++)
                    {
                        Int32 num=minSide-(p-minSide);
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[(nStartY+p)*nnWidth+nStartX+nWidth-1];
                        Uint8 *ptr_ed=ptr+step*(num-1);
                        Int32 count;
                        havejishu=0;
                        ptr=ptr_ed;
                        for(n=num-1;n>=0;n--)
                        {
                            if(*ptr!=0)
                            {
                                if(havejishu==0)
                                {
                                    havejishu=1;
                                    nohave=0;
                                    eD=n;
                                }
                                else if(havejishu==1)
                                {
                                    eD=n;
                                    nohave=0;
                                }
                            }
                            else if(havejishu==1)
                            {
                                nohave++;
                                if(nohave>kongxi)
                                {
                                    Int32 t,st;
                                    havejishu=0;
                                    st=eD-1;
                                    if(st<0)
                                        st=0;
                                    count=st;
                                    for(t=0;t<count;t++)
                                    {
                                        ptr=ptr-step;
                                        *ptr=0;
                                    }
                                    break;
                                }
                            }
                            ptr=ptr-step;
                        }
                    }
                }
            }
            break;
            case MHC_T_TO_B_135:
            {
                Int32 minSide=MIN(nWidth,nHeight);
                Int32 step=nnWidth+1;
                Int32 p;
                if(nWidth>=nHeight)
                {

                    for(p=0;p<minSide;p++)
                    {
                        Int32 num=minSide-p;
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[(nStartY+p)*nnWidth+nStartX];
                        Int32 count;
                        havejishu=0;
                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                if(havejishu==0)
                                {
                                    havejishu=1;
                                    nohave=0;
                                    eD=n;
                                }
                                else if(havejishu==1)
                                {
                                    eD=n;
                                    nohave=0;
                                }
                            }
                            else if(havejishu==1)
                            {
                                nohave++;
                                if(nohave>kongxi)
                                {
                                    Int32 t,st;
                                    havejishu=0;
                                    st=eD+1;
                                    if(st>num)
                                        st=num;
                                    count=num-st;
                                    for(t=0;t<count;t++)
                                    {
                                        ptr=ptr+step;
                                        *ptr=0;
                                    }
                                    break;
                                }
                            }
                            ptr=ptr+step;
                        }
                    }

                    for(p=1;p<nWidth-minSide;p++)
                    {
                        Int32 num=minSide;
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[nStartY*nnWidth+nStartX+p];
                        Int32 count;
                        havejishu=0;
                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                if(havejishu==0)
                                {
                                    havejishu=1;
                                    nohave=0;
                                    eD=n;
                                }
                                else if(havejishu==1)
                                {
                                    eD=n;
                                    nohave=0;
                                }
                            }
                            else if(havejishu==1)
                            {
                                nohave++;
                                if(nohave>kongxi)
                                {
                                    Int32 t,st;
                                    havejishu=0;
                                    st=eD+1;
                                    if(st>num)
                                        st=num;
                                    count=num-st;
                                    for(t=0;t<count;t++)
                                    {
                                        ptr=ptr+step;
                                        *ptr=0;
                                    }
                                    break;
                                }
                            }
                            ptr=ptr+step;
                        }
                    }

                    for(p=nWidth-minSide;p<nWidth;p++)
                    {
                        Int32 num=nWidth-p;
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[nStartY*nnWidth+nStartX+p];
                        Int32 count;
                        havejishu=0;
                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                if(havejishu==0)
                                {
                                    havejishu=1;
                                    nohave=0;
                                    eD=n;
                                }
                                else if(havejishu==1)
                                {
                                    eD=n;
                                    nohave=0;
                                }
                            }
                            else if(havejishu==1)
                            {
                                nohave++;
                                if(nohave>kongxi)
                                {
                                    Int32 t,st;
                                    havejishu=0;
                                    st=eD+1;
                                    if(st>num)
                                        st=num;
                                    count=num-st;
                                    for(t=0;t<count;t++)
                                    {
                                        ptr=ptr+step;
                                        *ptr=0;
                                    }
                                    break;
                                }
                            }
                            ptr=ptr+step;
                        }
                    }
                }
                else
                {

                    for(p=nHeight-minSide;p<nHeight;p++)
                    {
                        Int32 num=nHeight-p;
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[(nStartY+p)*nnWidth+nStartX];
                        Int32 count;
                        havejishu=0;
                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                if(havejishu==0)
                                {
                                    havejishu=1;
                                    nohave=0;
                                    eD=n;
                                }
                                else if(havejishu==1)
                                {
                                    eD=n;
                                    nohave=0;
                                }
                            }
                            else if(havejishu==1)
                            {
                                nohave++;
                                if(nohave>kongxi)
                                {
                                    Int32 t,st;
                                    havejishu=0;
                                    st=eD+1;
                                    if(st>num)
                                        st=num;
                                    count=num-st;
                                    for(t=0;t<count;t++)
                                    {
                                        ptr=ptr+step;
                                        *ptr=0;
                                    }
                                    break;
                                }
                            }
                            ptr=ptr+step;
                        }
                    }

                    for(p=1;p<nHeight-minSide;p++)
                    {
                        Int32 num=minSide;
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[(nStartY+p)*nnWidth+nStartX];
                        Int32 count;
                        havejishu=0;
                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                if(havejishu==0)
                                {
                                    havejishu=1;
                                    nohave=0;
                                    eD=n;
                                }
                                else if(havejishu==1)
                                {
                                    eD=n;
                                    nohave=0;
                                }
                            }
                            else if(havejishu==1)
                            {
                                nohave++;
                                if(nohave>kongxi)
                                {
                                    Int32 t,st;
                                    havejishu=0;
                                    st=eD+1;
                                    if(st>num)
                                        st=num;
                                    count=num-st;
                                    for(t=0;t<count;t++)
                                    {
                                        ptr=ptr+step;
                                        *ptr=0;
                                    }
                                    break;
                                }
                            }
                            ptr=ptr+step;
                        }
                    }

                    for(p=0;p<minSide;p++)
                    {
                        Int32 num=minSide-p;
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[nStartY*nnWidth+nStartX+p];
                        Int32 count;
                        havejishu=0;
                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                if(havejishu==0)
                                {
                                    havejishu=1;
                                    nohave=0;
                                    eD=n;
                                }
                                else if(havejishu==1)
                                {
                                    eD=n;
                                    nohave=0;
                                }
                            }
                            else if(havejishu==1)
                            {
                                nohave++;
                                if(nohave>kongxi)
                                {
                                    Int32 t,st;
                                    havejishu=0;
                                    st=eD+1;
                                    if(st>num)
                                        st=num;
                                    count=num-st;
                                    for(t=0;t<count;t++)
                                    {
                                        ptr=ptr+step;
                                        *ptr=0;
                                    }
                                    break;
                                }
                            }
                            ptr=ptr+step;
                        }
                    }
                }
            }
            break;
            case MHC_B_TO_T_135:
            {
                Int32 minSide=MIN(nWidth,nHeight);
                Int32 step=nnWidth+1;
                Int32 p;
                if(nWidth>=nHeight)
                {

                    for(p=0;p<minSide;p++)
                    {
                        Int32 num=minSide-p;
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[(nStartY+p)*nnWidth+nStartX];
                        Uint8 *ptr_ed=ptr+step*(num-1);
                        Int32 count;
                        havejishu=0;
                        ptr=ptr_ed;
                        for(n=num-1;n>=0;n--)
                        {
                            if(*ptr!=0)
                            {
                                if(havejishu==0)
                                {
                                    havejishu=1;
                                    nohave=0;
                                    eD=n;
                                }
                                else if(havejishu==1)
                                {
                                    eD=n;
                                    nohave=0;
                                }
                            }
                            else if(havejishu==1)
                            {
                                nohave++;
                                if(nohave>kongxi)
                                {
                                    Int32 t,st;
                                    havejishu=0;
                                    st=eD-1;
                                    if(st<0)
                                        st=0;
                                    count=st;
                                    for(t=0;t<count;t++)
                                    {
                                        ptr=ptr-step;
                                        *ptr=0;
                                    }
                                    break;
                                }
                            }
                            ptr=ptr-step;
                        }
                    }

                    for(p=1;p<nWidth-minSide;p++)
                    {
                        Int32 num=minSide;
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[nStartY*nnWidth+nStartX+p];
                        Uint8 *ptr_ed=ptr+step*(num-1);
                        Int32 count;
                        havejishu=0;
                        ptr=ptr_ed;
                        for(n=num-1;n>=0;n--)
                        {
                            if(*ptr!=0)
                            {
                                if(havejishu==0)
                                {
                                    havejishu=1;
                                    nohave=0;
                                    eD=n;
                                }
                                else if(havejishu==1)
                                {
                                    eD=n;
                                    nohave=0;
                                }
                            }
                            else if(havejishu==1)
                            {
                                nohave++;
                                if(nohave>kongxi)
                                {
                                    Int32 t,st;
                                    havejishu=0;
                                    st=eD-1;
                                    if(st<0)
                                        st=0;
                                    count=st;
                                    for(t=0;t<count;t++)
                                    {
                                        ptr=ptr-step;
                                        *ptr=0;
                                    }
                                    break;
                                }
                            }
                            ptr=ptr-step;
                        }
                    }

                    for(p=nWidth-minSide;p<nWidth;p++)
                    {
                        Int32 num=nWidth-p;
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[nStartY*nnWidth+nStartX+p];
                        Uint8 *ptr_ed=ptr+step*(num-1);
                        Int32 count;
                        havejishu=0;
                        ptr=ptr_ed;
                        for(n=num-1;n>=0;n--)
                        {
                            if(*ptr!=0)
                            {
                                if(havejishu==0)
                                {
                                    havejishu=1;
                                    nohave=0;
                                    eD=n;
                                }
                                else if(havejishu==1)
                                {
                                    eD=n;
                                    nohave=0;
                                }
                            }
                            else if(havejishu==1)
                            {
                                nohave++;
                                if(nohave>kongxi)
                                {
                                    Int32 t,st;
                                    havejishu=0;
                                    st=eD-1;
                                    if(st<0)
                                        st=0;
                                    count=st;
                                    for(t=0;t<count;t++)
                                    {
                                        ptr=ptr-step;
                                        *ptr=0;
                                    }
                                    break;
                                }
                            }
                            ptr=ptr-step;
                        }
                    }
                }
                else
                {

                    for(p=nHeight-minSide;p<nHeight;p++)
                    {
                        Int32 num=nHeight-p;
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[(nStartY+p)*nnWidth+nStartX];
                        Uint8 *ptr_ed=ptr+step*(num-1);
                        Int32 count;
                        havejishu=0;
                        ptr=ptr_ed;
                        for(n=num-1;n>=0;n--)
                        {
                            if(*ptr!=0)
                            {
                                if(havejishu==0)
                                {
                                    havejishu=1;
                                    nohave=0;
                                    eD=n;
                                }
                                else if(havejishu==1)
                                {
                                    eD=n;
                                    nohave=0;
                                }
                            }
                            else if(havejishu==1)
                            {
                                nohave++;
                                if(nohave>kongxi)
                                {
                                    Int32 t,st;
                                    havejishu=0;
                                    st=eD-1;
                                    if(st<0)
                                        st=0;
                                    count=st;
                                    for(t=0;t<count;t++)
                                    {
                                        ptr=ptr-step;
                                        *ptr=0;
                                    }
                                    break;
                                }
                            }
                            ptr=ptr-step;
                        }
                    }

                    for(p=1;p<nHeight-minSide;p++)
                    {
                        Int32 num=minSide;
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[(nStartY+p)*nnWidth+nStartX];
                        Uint8 *ptr_ed=ptr+step*(num-1);
                        Int32 count;
                        havejishu=0;
                        ptr=ptr_ed;
                        for(n=num-1;n>=0;n--)
                        {
                            if(*ptr!=0)
                            {
                                if(havejishu==0)
                                {
                                    havejishu=1;
                                    nohave=0;
                                    eD=n;
                                }
                                else if(havejishu==1)
                                {
                                    eD=n;
                                    nohave=0;
                                }
                            }
                            else if(havejishu==1)
                            {
                                nohave++;
                                if(nohave>kongxi)
                                {
                                    Int32 t,st;
                                    havejishu=0;
                                    st=eD-1;
                                    if(st<0)
                                        st=0;
                                    count=st;
                                    for(t=0;t<count;t++)
                                    {
                                        ptr=ptr-step;
                                        *ptr=0;
                                    }
                                    break;
                                }
                            }
                            ptr=ptr-step;
                        }
                    }

                    for(p=0;p<minSide;p++)
                    {
                        Int32 num=minSide-p;
                        Int32 n;
                        Uint8 *ptr=&matIn.ptr_uchar[nStartY*nnWidth+nStartX+p];
                        Uint8 *ptr_ed=ptr+step*(num-1);
                        Int32 count;
                        havejishu=0;
                        ptr=ptr_ed;
                        for(n=num-1;n>=0;n--)
                        {
                            if(*ptr!=0)
                            {
                                if(havejishu==0)
                                {
                                    havejishu=1;
                                    nohave=0;
                                    eD=n;
                                }
                                else if(havejishu==1)
                                {
                                    eD=n;
                                    nohave=0;
                                }
                            }
                            else if(havejishu==1)
                            {
                                nohave++;
                                if(nohave>kongxi)
                                {
                                    Int32 t,st;
                                    havejishu=0;
                                    st=eD-1;
                                    if(st<0)
                                        st=0;
                                    count=st;
                                    for(t=0;t<count;t++)
                                    {
                                        ptr=ptr-step;
                                        *ptr=0;
                                    }
                                    break;
                                }
                            }
                            ptr=ptr-step;
                        }
                    }
                }
            }
            break;
            default:
                return 1;
            break;
        }

        return 0;
    }

    Int8 MyGeteverfirstdistancebry(Mat matIn,getever Mod,Int32 distance,Mat *matOut)
    {
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        Int32 nnWidth=matIn.nWidth;
        Int32 x,y;
        Int32 dy;
        Int32 ST,ED;
        Mat matIntemp;

        if(matIn.data==matOut->data)
        {
            switch(matIn._type)
            {
                case CCV_8UC1:
                break;
                default:
                    return 1;
                break;
            }
            matIntemp=MatCreatClone(matIn,(Uint8*)u8_buffer_x1Temp6);
        }
        else
        {
            matIntemp=matIn;
            getcloneinfo(matIntemp,matOut);
        }

        MatSet1col(matOut,0);

        switch(Mod)
        {
            case MHC_R_TO_L:
                for(y=nStartY;y<nStartY+nHeight;y++)
                {
                    for(x=nStartX+nWidth-1;x>=nStartX;x--)
                    {
                        if(matIntemp.ptr_uchar[y*nnWidth+x]!=0)
                        {
                            Int32 nStx=x-distance+1;
                            Int32 longnum;
                            if(nStx<nStartX)
                            {
                                nStx=nStartX;
                            }
                            longnum=x-nStx+1;
                            memcpy(&matOut->data[y*nnWidth+nStx],&matIntemp.data[y*nnWidth+nStx],longnum);
                            break;
                        }
                    }
                }
            break;
            case MHC_L_TO_R:
                for(y=nStartY;y<nStartY+nHeight;y++)
                {
                    for(x=nStartX;x<nStartX+nWidth;x++)
                    {
                        if(matIntemp.ptr_uchar[y*nnWidth+x]!=0)
                        {
                            Int32 nEdx=x+distance;
                            Int32 longnum;
                            if(nEdx>nStartX+nWidth)
                            {
                                nEdx=nStartX+nWidth;
                            }
                            longnum=nEdx-x;
                            memcpy(&matOut->data[y*nnWidth+x],&matIntemp.data[y*nnWidth+x],longnum);
                            break;
                        }
                    }
                }
            break;
            case MHC_T_TO_B:
                for(x=nStartX;x<nStartX+nWidth;x++)
                {
                    for(y=nStartY;y<nStartY+nHeight;y++)
                    {
                        if(matIntemp.ptr_uchar[y*nnWidth+x]!=0)
                        {
                            Int32 nEdy=y+distance;
                            if(nEdy>nStartY+nHeight)
                            {
                                nEdy=nStartY+nHeight;
                            }
                            for(dy=y;dy<nEdy;dy++)
                            {
                                matOut->data[dy*nnWidth+x]=matIntemp.data[dy*nnWidth+x];
                            }
                            break;
                        }
                    }
                }
            break;
            case MHC_B_TO_T:
                for(x=nStartX;x<nStartX+nWidth;x++)
                {
                    for(y=nStartY+nHeight-1;y>=nStartY;y--)
                    {
                        if(matIntemp.ptr_uchar[y*nnWidth+x]!=0)
                        {
                            Int32 nSty=y-distance+1;
                            if(nSty<nStartY)
                            {
                                nSty=nStartY;
                            }
                            for(dy=nSty;dy<=y;dy++)
                            {
                                matOut->data[dy*nnWidth+x]=matIntemp.data[dy*nnWidth+x];
                            }
                            break;
                        }
                    }
                }
            break;
            case MHC_T_TO_B_45:
            {
                Int32 minSide=MIN(nWidth,nHeight);
                Int32 step=nnWidth-1;
                Int32 p;
                if(nWidth>=nHeight)
                {

                    for(p=0;p<minSide;p++)
                    {
                        Int32 num=p+1;
                        Int32 n;
                        Uint8 *ptr=&matIntemp.ptr_uchar[nStartY*nnWidth+p+nStartX];
                        Uint8 *ptrIm=&matOut->data[nStartY*nnWidth+p+nStartX];
                        Uint8 *ptr_stIm=ptrIm;
                        Int32 count;

                        ST=-1;
                        ED=-1;
                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                ST=n;
                                break;
                            }
                            ptr=ptr+step;
                        }
                        if(ST!=-1)
                        {
                            ED=n+distance;
                            if(ED>num)
                                ED=num;
                            count=ED-ST;
                            ptrIm=ptr_stIm+ST*step;
                            for(n=0;n<count;n++)
                            {
                                *ptrIm=*ptr;
                                ptr=ptr+step;
                                ptrIm=ptrIm+step;
                            }
                        }
                    }

                    for(p=minSide;p<nWidth-1;p++)
                    {
                        Int32 num=minSide;
                        Int32 n;
                        Uint8 *ptr=&matIntemp.ptr_uchar[nStartY*nnWidth+p+nStartX];
                        Uint8 *ptrIm=&matOut->data[nStartY*nnWidth+p+nStartX];
                        Uint8 *ptr_stIm=ptrIm;
                        Int32 count;
                        ST=-1;
                        ED=-1;
                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                ST=n;
                                break;
                            }
                            ptr=ptr+step;
                        }
                        if(ST!=-1)
                        {
                            ED=n+distance;
                            if(ED>num)
                                ED=num;
                            count=ED-ST;
                            ptrIm=ptr_stIm+ST*step;
                            for(n=0;n<count;n++)
                            {
                                *ptrIm=*ptr;
                                ptr=ptr+step;
                                ptrIm=ptrIm+step;
                            }
                        }
                    }

                    for(p=0;p<minSide;p++)
                    {
                        Int32 num=minSide-p;
                        Int32 n;
                        Uint8 *ptr=&matIntemp.ptr_uchar[(nStartY+p)*nnWidth+nStartX+nWidth-1];
                        Uint8 *ptrIm=&matOut->data[(nStartY+p)*nnWidth+nStartX+nWidth-1];
                        Uint8 *ptr_stIm=ptrIm;
                        Int32 count;
                        ST=-1;
                        ED=-1;
                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                ST=n;
                                break;
                            }
                            ptr=ptr+step;
                        }
                        if(ST!=-1)
                        {
                            ED=n+distance;
                            if(ED>num)
                                ED=num;
                            count=ED-ST;
                            ptrIm=ptr_stIm+ST*step;
                            for(n=0;n<count;n++)
                            {
                                *ptrIm=*ptr;
                                ptr=ptr+step;
                                ptrIm=ptrIm+step;
                            }
                        }
                    }
                }
                else
                {
                    for(p=0;p<minSide;p++)
                    {
                        Int32 num=p+1;
                        Int32 n;
                        Uint8 *ptr=&matIntemp.ptr_uchar[nStartY*nnWidth+p+nStartX];
                        Uint8 *ptrIm=&matOut->data[nStartY*nnWidth+p+nStartX];
                        Uint8 *ptr_stIm=ptrIm;
                        Int32 count;
                        ST=-1;
                        ED=-1;
                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                ST=n;
                                break;
                            }
                            ptr=ptr+step;
                        }
                        if(ST!=-1)
                        {
                            ED=n+distance;
                            if(ED>num)
                                ED=num;
                            count=ED-ST;
                            ptrIm=ptr_stIm+ST*step;
                            for(n=0;n<count;n++)
                            {
                                *ptrIm=*ptr;
                                ptr=ptr+step;
                                ptrIm=ptrIm+step;
                            }
                        }
                    }

                    for(p=minSide;p<nHeight;p++)
                    {
                        Int32 num=minSide;
                        Int32 n;
                        Uint8 *ptr=&matIntemp.ptr_uchar[(nStartY+p-minSide)*nnWidth+nStartX+nWidth-1];
                        Uint8 *ptrIm=&matOut->data[(nStartY+p-minSide)*nnWidth+nStartX+nWidth-1];
                        Uint8 *ptr_stIm=ptrIm;
                        Int32 count;
                        ST=-1;
                        ED=-1;
                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                ST=n;
                                break;
                            }
                            ptr=ptr+step;
                        }
                        if(ST!=-1)
                        {
                            ED=n+distance;
                            if(ED>num)
                                ED=num;
                            count=ED-ST;
                            ptrIm=ptr_stIm+ST*step;
                            for(n=0;n<count;n++)
                            {
                                *ptrIm=*ptr;
                                ptr=ptr+step;
                                ptrIm=ptrIm+step;
                            }
                        }
                    }

                    for(p=nHeight-minSide;p<nHeight;p++)
                    {
                        Int32 num=minSide-(p-minSide);
                        Int32 n;
                        Uint8 *ptr=&matIntemp.ptr_uchar[(nStartY+p)*nnWidth+nStartX+nWidth-1];
                        Uint8 *ptrIm=&matOut->data[(nStartY+p)*nnWidth+nStartX+nWidth-1];
                        Uint8 *ptr_stIm=ptrIm;
                        Int32 count;
                        ST=-1;
                        ED=-1;
                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                ST=n;
                                break;
                            }
                            ptr=ptr+step;
                        }
                        if(ST!=-1)
                        {
                            ED=n+distance;
                            if(ED>num)
                                ED=num;
                            count=ED-ST;
                            ptrIm=ptr_stIm+ST*step;
                            for(n=0;n<count;n++)
                            {
                                *ptrIm=*ptr;
                                ptr=ptr+step;
                                ptrIm=ptrIm+step;
                            }
                        }
                    }
                }
            }
            break;
            case MHC_B_TO_T_45:
            {
                Int32 minSide=MIN(nWidth,nHeight);
                Int32 step=nnWidth-1;
                Int32 p;
                if(nWidth>=nHeight)
                {

                    for(p=0;p<minSide;p++)
                    {
                        Int32 num=p+1;
                        Int32 n;
                        Uint8 *ptr=&matIntemp.ptr_uchar[nStartY*nnWidth+p+nStartX];
                        Uint8 *ptrIm=&matOut->data[nStartY*nnWidth+p+nStartX];
                        Uint8 *ptr_ed=ptr+step*(num-1);
                        Uint8 *ptr_stIm=ptrIm;
                        Int32 count;

                        ST=-1;
                        ED=-1;
                        ptr=ptr_ed;
                        for(n=num-1;n>=0;n--)
                        {
                            if(*ptr!=0)
                            {
                                ED=n;
                                break;
                            }
                            ptr=ptr-step;
                        }
                        if(ED!=-1)
                        {
                            ST=n-distance;
                            if(ST<0)
                                ST=0;
                            count=ED-ST;
                            ptrIm=ptr_stIm+ED*step;
                            for(n=0;n<count;n++)
                            {
                                *ptrIm=*ptr;
                                ptr=ptr-step;
                                ptrIm=ptrIm-step;
                            }
                        }
                    }

                    for(p=minSide;p<nWidth-1;p++)
                    {
                        Int32 num=minSide;
                        Int32 n;
                        Uint8 *ptr=&matIntemp.ptr_uchar[nStartY*nnWidth+p+nStartX];
                        Uint8 *ptrIm=&matOut->data[nStartY*nnWidth+p+nStartX];
                        Uint8 *ptr_ed=ptr+step*(num-1);
                        Uint8 *ptr_stIm=ptrIm;
                        Int32 count;
                        ST=-1;
                        ED=-1;
                        ptr=ptr_ed;
                        for(n=num-1;n>=0;n--)
                        {
                            if(*ptr!=0)
                            {
                                ED=n;
                                break;
                            }
                            ptr=ptr-step;
                        }
                        if(ED!=-1)
                        {
                            ST=n-distance;
                            if(ST<0)
                                ST=0;
                            count=ED-ST;
                            ptrIm=ptr_stIm+ED*step;
                            for(n=0;n<count;n++)
                            {
                                *ptrIm=*ptr;
                                ptr=ptr-step;
                                ptrIm=ptrIm-step;
                            }
                        }
                    }

                    for(p=0;p<minSide;p++)
                    {
                        Int32 num=minSide-p;
                        Int32 n;
                        Uint8 *ptr=&matIntemp.ptr_uchar[(nStartY+p)*nnWidth+nStartX+nWidth-1];
                        Uint8 *ptrIm=&matOut->data[(nStartY+p)*nnWidth+nStartX+nWidth-1];
                        Uint8 *ptr_ed=ptr+step*(num-1);
                        Uint8 *ptr_stIm=ptrIm;
                        Int32 count;
                        ST=-1;
                        ED=-1;
                        ptr=ptr_ed;
                        for(n=num-1;n>=0;n--)
                        {
                            if(*ptr!=0)
                            {
                                ED=n;
                                break;
                            }
                            ptr=ptr-step;
                        }
                        if(ED!=-1)
                        {
                            ST=n-distance;
                            if(ST<0)
                                ST=0;
                            count=ED-ST;
                            ptrIm=ptr_stIm+ED*step;
                            for(n=0;n<count;n++)
                            {
                                *ptrIm=*ptr;
                                ptr=ptr-step;
                                ptrIm=ptrIm-step;
                            }
                        }
                    }
                }
                else
                {

                    for(p=0;p<minSide;p++)
                    {
                        Int32 num=p+1;
                        Int32 n;
                        Uint8 *ptr=&matIntemp.ptr_uchar[nStartY*nnWidth+p+nStartX];
                        Uint8 *ptrIm=&matOut->data[nStartY*nnWidth+p+nStartX];
                        Uint8 *ptr_ed=ptr+step*(num-1);
                        Uint8 *ptr_stIm=ptrIm;
                        Int32 count;
                        ST=-1;
                        ED=-1;
                        ptr=ptr_ed;
                        for(n=num-1;n>=0;n--)
                        {
                            if(*ptr!=0)
                            {
                                ED=n;
                                break;
                            }
                            ptr=ptr-step;
                        }
                        if(ED!=-1)
                        {
                            ST=n-distance;
                            if(ST<0)
                                ST=0;
                            count=ED-ST;
                            ptrIm=ptr_stIm+ED*step;
                            for(n=0;n<count;n++)
                            {
                                *ptrIm=*ptr;
                                ptr=ptr-step;
                                ptrIm=ptrIm-step;
                            }
                        }
                    }

                    for(p=minSide;p<nHeight;p++)
                    {
                        Int32 num=minSide;
                        Int32 n;
                        Uint8 *ptr=&matIntemp.ptr_uchar[(nStartY+p-minSide)*nnWidth+nStartX+nWidth-1];
                        Uint8 *ptrIm=&matOut->data[(nStartY+p-minSide)*nnWidth+nStartX+nWidth-1];
                        Uint8 *ptr_ed=ptr+step*(num-1);
                        Uint8 *ptr_stIm=ptrIm;
                        Int32 count;
                        ST=-1;
                        ED=-1;
                        ptr=ptr_ed;
                        for(n=num-1;n>=0;n--)
                        {
                            if(*ptr!=0)
                            {
                                ED=n;
                                break;
                            }
                            ptr=ptr-step;
                        }
                        if(ED!=-1)
                        {
                            ST=n-distance;
                            if(ST<0)
                                ST=0;
                            count=ED-ST;
                            ptrIm=ptr_stIm+ED*step;
                            for(n=0;n<count;n++)
                            {
                                *ptrIm=*ptr;
                                ptr=ptr-step;
                                ptrIm=ptrIm-step;
                            }
                        }
                    }

                    for(p=nHeight-minSide;p<nHeight;p++)
                    {
                        Int32 num=minSide-(p-minSide);
                        Int32 n;
                        Uint8 *ptr=&matIntemp.ptr_uchar[(nStartY+p)*nnWidth+nStartX+nWidth-1];
                        Uint8 *ptrIm=&matOut->data[(nStartY+p)*nnWidth+nStartX+nWidth-1];
                        Uint8 *ptr_ed=ptr+step*(num-1);
                        Uint8 *ptr_stIm=ptrIm;
                        Int32 count;
                        ST=-1;
                        ED=-1;
                        ptr=ptr_ed;
                        for(n=num-1;n>=0;n--)
                        {
                            if(*ptr!=0)
                            {
                                ED=n;
                                break;
                            }
                            ptr=ptr-step;
                        }
                        if(ED!=-1)
                        {
                            ST=n-distance;
                            if(ST<0)
                                ST=0;
                            count=ED-ST;
                            ptrIm=ptr_stIm+ED*step;
                            for(n=0;n<count;n++)
                            {
                                *ptrIm=*ptr;
                                ptr=ptr-step;
                                ptrIm=ptrIm-step;
                            }
                        }
                    }
                }
            }
            break;
            case MHC_T_TO_B_135:
            {
                Int32 minSide=MIN(nWidth,nHeight);
                Int32 step=nnWidth+1;
                Int32 p;
                if(nWidth>=nHeight)
                {

                    for(p=0;p<minSide;p++)
                    {
                        Int32 num=minSide-p;
                        Int32 n;
                        Uint8 *ptr=&matIntemp.ptr_uchar[(nStartY+p)*nnWidth+nStartX];
                        Uint8 *ptrIm=&matOut->data[(nStartY+p)*nnWidth+nStartX];
                        Uint8 *ptr_stIm=ptrIm;
                        Int32 count;
                        ST=-1;
                        ED=-1;
                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                ST=n;
                                break;
                            }
                            ptr=ptr+step;
                        }
                        if(ST!=-1)
                        {
                            ED=n+distance;
                            if(ED>num)
                                ED=num;
                            count=ED-ST;
                            ptrIm=ptr_stIm+ST*step;
                            for(n=0;n<count;n++)
                            {
                                *ptrIm=*ptr;
                                ptr=ptr+step;
                                ptrIm=ptrIm+step;
                            }
                        }
                    }

                    for(p=1;p<nWidth-minSide;p++)
                    {
                        Int32 num=minSide;
                        Int32 n;
                        Uint8 *ptr=&matIntemp.ptr_uchar[nStartY*nnWidth+nStartX+p];
                        Uint8 *ptrIm=&matOut->data[nStartY*nnWidth+nStartX+p];
                        Uint8 *ptr_stIm=ptrIm;
                        Int32 count;
                        ST=-1;
                        ED=-1;
                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                ST=n;
                                break;
                            }
                            ptr=ptr+step;
                        }
                        if(ST!=-1)
                        {
                            ED=n+distance;
                            if(ED>num)
                                ED=num;
                            count=ED-ST;
                            ptrIm=ptr_stIm+ST*step;
                            for(n=0;n<count;n++)
                            {
                                *ptrIm=*ptr;
                                ptr=ptr+step;
                                ptrIm=ptrIm+step;
                            }
                        }
                    }

                    for(p=nWidth-minSide;p<nWidth;p++)
                    {
                        Int32 num=nWidth-p;
                        Int32 n;
                        Uint8 *ptr=&matIntemp.ptr_uchar[nStartY*nnWidth+nStartX+p];
                        Uint8 *ptrIm=&matOut->data[nStartY*nnWidth+nStartX+p];
                        Uint8 *ptr_stIm=ptrIm;
                        Int32 count;
                        ST=-1;
                        ED=-1;
                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                ST=n;
                                break;
                            }
                            ptr=ptr+step;
                        }
                        if(ST!=-1)
                        {
                            ED=n+distance;
                            if(ED>num)
                                ED=num;
                            count=ED-ST;
                            ptrIm=ptr_stIm+ST*step;
                            for(n=0;n<count;n++)
                            {
                                *ptrIm=*ptr;
                                ptr=ptr+step;
                                ptrIm=ptrIm+step;
                            }
                        }
                    }
                }
                else
                {
                    for(p=nHeight-minSide;p<nHeight;p++)
                    {
                        Int32 num=nHeight-p;
                        Int32 n;
                        Uint8 *ptr=&matIntemp.ptr_uchar[(nStartY+p)*nnWidth+nStartX];
                        Uint8 *ptrIm=&matOut->data[(nStartY+p)*nnWidth+nStartX];
                        Uint8 *ptr_stIm=ptrIm;
                        Int32 count;
                        ST=-1;
                        ED=-1;
                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                ST=n;
                                break;
                            }
                            ptr=ptr+step;
                        }
                        if(ST!=-1)
                        {
                            ED=n+distance;
                            if(ED>num)
                                ED=num;
                            count=ED-ST;
                            ptrIm=ptr_stIm+ST*step;
                            for(n=0;n<count;n++)
                            {
                                *ptrIm=*ptr;
                                ptr=ptr+step;
                                ptrIm=ptrIm+step;
                            }
                        }
                    }

                    for(p=1;p<nHeight-minSide;p++)
                    {
                        Int32 num=minSide;
                        Int32 n;
                        Uint8 *ptr=&matIntemp.ptr_uchar[(nStartY+p)*nnWidth+nStartX];
                        Uint8 *ptrIm=&matOut->data[(nStartY+p)*nnWidth+nStartX];
                        Uint8 *ptr_stIm=ptrIm;
                        Int32 count;
                        ST=-1;
                        ED=-1;
                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                ST=n;
                                break;
                            }
                            ptr=ptr+step;
                        }
                        if(ST!=-1)
                        {
                            ED=n+distance;
                            if(ED>num)
                                ED=num;
                            count=ED-ST;
                            ptrIm=ptr_stIm+ST*step;
                            for(n=0;n<count;n++)
                            {
                                *ptrIm=*ptr;
                                ptr=ptr+step;
                                ptrIm=ptrIm+step;
                            }
                        }
                    }

                    for(p=0;p<minSide;p++)
                    {
                        Int32 num=minSide-p;
                        Int32 n;
                        Uint8 *ptr=&matIntemp.ptr_uchar[nStartY*nnWidth+nStartX+p];
                        Uint8 *ptrIm=&matOut->data[nStartY*nnWidth+nStartX+p];
                        Uint8 *ptr_stIm=ptrIm;
                        Int32 count;
                        ST=-1;
                        ED=-1;
                        for(n=0;n<num;n++)
                        {
                            if(*ptr!=0)
                            {
                                ST=n;
                                break;
                            }
                            ptr=ptr+step;
                        }
                        if(ST!=-1)
                        {
                            ED=n+distance;
                            if(ED>num)
                                ED=num;
                            count=ED-ST;
                            ptrIm=ptr_stIm+ST*step;
                            for(n=0;n<count;n++)
                            {
                                *ptrIm=*ptr;
                                ptr=ptr+step;
                                ptrIm=ptrIm+step;
                            }
                        }
                    }
                }
            }
            break;
            case MHC_B_TO_T_135:
            {
                Int32 minSide=MIN(nWidth,nHeight);
                Int32 step=nnWidth+1;
                Int32 p;
                if(nWidth>=nHeight)
                {

                    for(p=0;p<minSide;p++)
                    {
                        Int32 num=minSide-p;
                        Int32 n;
                        Uint8 *ptr=&matIntemp.ptr_uchar[(nStartY+p)*nnWidth+nStartX];
                        Uint8 *ptrIm=&matOut->data[(nStartY+p)*nnWidth+nStartX];
                        Uint8 *ptr_ed=ptr+step*(num-1);
                        Uint8 *ptr_stIm=ptrIm;
                        Int32 count;
                        ST=-1;
                        ED=-1;
                        ptr=ptr_ed;
                        for(n=num-1;n>=0;n--)
                        {
                            if(*ptr!=0)
                            {
                                ED=n;
                                break;
                            }
                            ptr=ptr-step;
                        }
                        if(ED!=-1)
                        {
                            ST=n-distance;
                            if(ST<0)
                                ST=0;
                            count=ED-ST;
                            ptrIm=ptr_stIm+ED*step;
                            for(n=0;n<count;n++)
                            {
                                *ptrIm=*ptr;
                                ptr=ptr-step;
                                ptrIm=ptrIm-step;
                            }
                        }
                    }

                    for(p=1;p<nWidth-minSide;p++)
                    {
                        Int32 num=minSide;
                        Int32 n;
                        Uint8 *ptr=&matIntemp.ptr_uchar[nStartY*nnWidth+nStartX+p];
                        Uint8 *ptrIm=&matOut->data[nStartY*nnWidth+nStartX+p];
                        Uint8 *ptr_ed=ptr+step*(num-1);
                        Uint8 *ptr_stIm=ptrIm;
                        Int32 count;
                        ST=-1;
                        ED=-1;
                        ptr=ptr_ed;
                        for(n=num-1;n>=0;n--)
                        {
                            if(*ptr!=0)
                            {
                                ED=n;
                                break;
                            }
                            ptr=ptr-step;
                        }
                        if(ED!=-1)
                        {
                            ST=n-distance;
                            if(ST<0)
                                ST=0;
                            count=ED-ST;
                            ptrIm=ptr_stIm+ED*step;
                            for(n=0;n<count;n++)
                            {
                                *ptrIm=*ptr;
                                ptr=ptr-step;
                                ptrIm=ptrIm-step;
                            }
                        }
                    }

                    for(p=nWidth-minSide;p<nWidth;p++)
                    {
                        Int32 num=nWidth-p;
                        Int32 n;
                        Uint8 *ptr=&matIntemp.ptr_uchar[nStartY*nnWidth+nStartX+p];
                        Uint8 *ptrIm=&matOut->data[nStartY*nnWidth+nStartX+p];
                        Uint8 *ptr_ed=ptr+step*(num-1);
                        Uint8 *ptr_stIm=ptrIm;
                        Int32 count;
                        ST=-1;
                        ED=-1;
                        ptr=ptr_ed;
                        for(n=num-1;n>=0;n--)
                        {
                            if(*ptr!=0)
                            {
                                ED=n;
                                break;
                            }
                            ptr=ptr-step;
                        }
                        if(ED!=-1)
                        {
                            ST=n-distance;
                            if(ST<0)
                                ST=0;
                            count=ED-ST;
                            ptrIm=ptr_stIm+ED*step;
                            for(n=0;n<count;n++)
                            {
                                *ptrIm=*ptr;
                                ptr=ptr-step;
                                ptrIm=ptrIm-step;
                            }
                        }
                    }
                }
                else
                {
                    for(p=nHeight-minSide;p<nHeight;p++)
                    {
                        Int32 num=nHeight-p;
                        Int32 n;
                        Uint8 *ptr=&matIntemp.ptr_uchar[(nStartY+p)*nnWidth+nStartX];
                        Uint8 *ptrIm=&matOut->data[(nStartY+p)*nnWidth+nStartX];
                        Uint8 *ptr_ed=ptr+step*(num-1);
                        Uint8 *ptr_stIm=ptrIm;
                        Int32 count;
                        ST=-1;
                        ED=-1;
                        ptr=ptr_ed;
                        for(n=num-1;n>=0;n--)
                        {
                            if(*ptr!=0)
                            {
                                ED=n;
                                break;
                            }
                            ptr=ptr-step;
                        }
                        if(ED!=-1)
                        {
                            ST=n-distance;
                            if(ST<0)
                                ST=0;
                            count=ED-ST;
                            ptrIm=ptr_stIm+ED*step;
                            for(n=0;n<count;n++)
                            {
                                *ptrIm=*ptr;
                                ptr=ptr-step;
                                ptrIm=ptrIm-step;
                            }
                        }
                    }

                    for(p=1;p<nHeight-minSide;p++)
                    {
                        Int32 num=minSide;
                        Int32 n;
                        Uint8 *ptr=&matIntemp.ptr_uchar[(nStartY+p)*nnWidth+nStartX];
                        Uint8 *ptrIm=&matOut->data[(nStartY+p)*nnWidth+nStartX];
                        Uint8 *ptr_ed=ptr+step*(num-1);
                        Uint8 *ptr_stIm=ptrIm;
                        Int32 count;
                        ST=-1;
                        ED=-1;
                        ptr=ptr_ed;
                        for(n=num-1;n>=0;n--)
                        {
                            if(*ptr!=0)
                            {
                                ED=n;
                                break;
                            }
                            ptr=ptr-step;
                        }
                        if(ED!=-1)
                        {
                            ST=n-distance;
                            if(ST<0)
                                ST=0;
                            count=ED-ST;
                            ptrIm=ptr_stIm+ED*step;
                            for(n=0;n<count;n++)
                            {
                                *ptrIm=*ptr;
                                ptr=ptr-step;
                                ptrIm=ptrIm-step;
                            }
                        }
                    }

                    for(p=0;p<minSide;p++)
                    {
                        Int32 num=minSide-p;
                        Int32 n;
                        Uint8 *ptr=&matIntemp.ptr_uchar[nStartY*nnWidth+nStartX+p];
                        Uint8 *ptrIm=&matOut->data[nStartY*nnWidth+nStartX+p];
                        Uint8 *ptr_ed=ptr+step*(num-1);
                        Uint8 *ptr_stIm=ptrIm;
                        Int32 count;
                        ST=-1;
                        ED=-1;
                        ptr=ptr_ed;
                        for(n=num-1;n>=0;n--)
                        {
                            if(*ptr!=0)
                            {
                                ED=n;
                                break;
                            }
                            ptr=ptr-step;
                        }
                        if(ED!=-1)
                        {
                            ST=n-distance;
                            if(ST<0)
                                ST=0;
                            count=ED-ST;
                            ptrIm=ptr_stIm+ED*step;
                            for(n=0;n<count;n++)
                            {
                                *ptrIm=*ptr;
                                ptr=ptr-step;
                                ptrIm=ptrIm-step;
                            }
                        }
                    }
                }
            }
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 MyConectComperMat(MyConect *ImageConectIn,Mat mask,Int32 Gapmax,Int32 *mianji,Int32 *longsize)
    {
        Int32 n,m;
        Int32 nnWidth=ImageConectIn->nWidth;
        Int32 i32_mianji=0;
        Int32 i32_longsize=0;
        Int32 max_longsize=0;
        Int32 no_longsize=0;
        if(0!=judgeCMaskSize(ImageConectIn,mask))
            return 1;
        for(n=0;n<ImageConectIn->AllMarkPointCount;n++)
        {
            for(m=0;m<ImageConectIn->AllMarkPoint[n].PointArea;m++)
            {
                Int32 x=ImageConectIn->AllMarkPoint[n].point[m].x;
                Int32 y=ImageConectIn->AllMarkPoint[n].point[m].y;
                if(mask.data[y*nnWidth+x]!=0)
                {
                    i32_mianji++;
                    i32_longsize++;
                    no_longsize=0;
                }
                else
                {
                    no_longsize++;
                    if(no_longsize>Gapmax)
                    {
                        if(max_longsize<i32_longsize)
                        {
                            max_longsize=i32_longsize;
                        }
                        i32_longsize=0;
                    }
                }
            }
        }
        *mianji=i32_mianji;
        *longsize=max_longsize;
        return 0;
    }

    Int8 GetMotorLine(Ver2v verIn,Int32 time,linefittype Mod,L_Point32 *motorOut)
    {
        double K,R;
        Int32 N=verIn.num;
        Int64 sumxx,sumx,sumy,sumxy;
        Vec2v *i32_data=(Vec2v*)u8_ver_temp_1;
        Int32 halfnum;
        Vec2v head,tail;
        if(verIn.num<verIn.buf32_num)
        {
            return 1;
        }
        switch(Mod)
        {
            case MHC_LINER_FITTING:
                halfnum=(verIn.num>>1);
                memcpy(i32_data,verIn.point,halfnum*sizeof(Vec2v));
                QuickSortVer2v_ver1X(i32_data,halfnum);
                head=i32_data[halfnum>>1];
                memcpy(i32_data,&verIn.point[halfnum],(verIn.num-halfnum)*sizeof(Vec2v));
                QuickSortVer2v_ver1X(i32_data,verIn.num-halfnum);
                tail=i32_data[(verIn.num-halfnum)>>1];
                if(tail.vec1.x-head.vec1.x!=0)
                {
                    K=(double)(tail.vec2.x-head.vec2.x)/(double)(tail.vec1.x-head.vec1.x);
                    R=(double)(tail.vec1.x*head.vec2.x-head.vec1.x*tail.vec2.x)/(double)(tail.vec1.x-head.vec1.x);
                    motorOut->x=(time-R)/K;
                }
                else
                {
                    motorOut->x=head.vec1.x;
                }
                memcpy(i32_data,verIn.point,halfnum*sizeof(Vec2v));
                QuickSortVer2v_ver1Y(i32_data,halfnum);
                head=i32_data[halfnum>>1];
                memcpy(i32_data,&verIn.point[halfnum],(verIn.num-halfnum)*sizeof(Vec2v));
                QuickSortVer2v_ver1Y(i32_data,verIn.num-halfnum);
                tail=i32_data[(verIn.num-halfnum)>>1];
                if(tail.vec1.y-head.vec1.y!=0)
                {
                    K=(double)(tail.vec2.y-head.vec2.y)/(double)(tail.vec1.y-head.vec1.y);
                    R=(double)(tail.vec1.y*head.vec2.y-head.vec1.y*tail.vec2.y)/(double)(tail.vec1.y-head.vec1.y);
                    motorOut->y=(time-R)/K;
                }
                else
                {
                    motorOut->y=head.vec1.y;
                }
            break;
            case MHC_LEAST_SQUARE_FITTING:
                sumx=i64_calculatesumx_XT(verIn);
                sumy=i64_calculatesumy_XT(verIn);
                sumxy=i64_calculatesumxy_XT(verIn);
                sumxx=i64_calculatesquare_XT(verIn);

                if(N*sumxx-sumx*sumx!=0)
                {
                    K=(double)(N*sumxy-sumx*sumy)/(double)(N*sumxx-sumx*sumx);
                    R=(double)(sumxx*sumy-sumx*sumxy)/(double)(N*sumxx-sumx*sumx);
                    motorOut->x=(time-R)/K;
                }
                else
                {
                    motorOut->x=verIn.point[0].vec1.x;
                }
                sumx=i64_calculatesumx_YT(verIn);
                sumy=i64_calculatesumy_YT(verIn);
                sumxy=i64_calculatesumxy_YT(verIn);
                sumxx=i64_calculatesquare_YT(verIn);

                if(N*sumxx-sumx*sumx!=0)
                {
                    K=(double)(N*sumxy-sumx*sumy)/(double)(N*sumxx-sumx*sumx);
                    R=(double)(sumxx*sumy-sumx*sumxy)/(double)(N*sumxx-sumx*sumx);
                    motorOut->y=(time-R)/K;
                }
                else
                {
                    motorOut->y=verIn.point[0].vec1.y;
                }
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 MyCirculation(Mat *matIn_Out,circulatype Mod,Int32 size)
    {
        Int32 nStartX=matIn_Out->startx;
        Int32 nStartY=matIn_Out->starty;
        Int32 nWidth=matIn_Out->width;
        Int32 nHeight=matIn_Out->height;
        Uint32 nnWidth=matIn_Out->nWidth;
        Uint8 *u8_buffer=(Uint8*)u8_buffer_x3Temp1;
        Uint16 *u16_buffer=(Uint16*)u8_buffer_x3Temp1;
        Int32 j;

        switch(matIn_Out->_type)
        {
            case CCV_8UC1:
                switch(Mod)
                {
                    case MHC_CIRCULA_DOWN_TO_TOP:
                        for(j=nStartY;j<nStartY+size;j++)
                        {
                            memcpy(&u8_buffer[(j-nStartY)*nnWidth],&matIn_Out->ptr_uchar[j*nnWidth],nWidth*sizeof(Uint8));
                        }
                        for(j=nStartY;j<nStartY+nHeight-size;j++)
                        {
                            memcpy(&matIn_Out->ptr_uchar[j*nnWidth+nStartX],&matIn_Out->ptr_uchar[(j+size)*nnWidth+nStartX],nWidth*sizeof(Uint8));
                        }
                        for(j=nStartY+nHeight-size;j<nStartY+nHeight;j++)
                        {
                            memcpy(&matIn_Out->ptr_uchar[j*nnWidth+nStartX],&u8_buffer[(j-(nStartY+nHeight-size))*nnWidth],nWidth*sizeof(Uint8));
                        }
                    break;
                    case MHC_CIRCULA_TOP_TO_DOWN:
                        for(j=nStartY+nHeight-1;j>nStartY+nHeight-1-size;j--)
                        {
                            memcpy(&u8_buffer[((nStartY+nHeight-1)-j)*nnWidth],&matIn_Out->ptr_uchar[j*nnWidth+nStartX],nWidth*sizeof(Uint8));
                        }
                        for(j=nStartY+nHeight-1;j>=nStartY+size;j--)
                        {
                            memcpy(&matIn_Out->ptr_uchar[j*nnWidth+nStartX],&matIn_Out->ptr_uchar[(j-size)*nnWidth+nStartX],nWidth*sizeof(Uint8));
                        }
                        for(j=nStartY+size-1;j>=nStartY;j--)
                        {
                            memcpy(&matIn_Out->ptr_uchar[j*nnWidth+nStartX],&u8_buffer[((nStartY+size-1)-j)*nnWidth],nWidth*sizeof(Uint8));
                        }
                    break;
                    default:
                        return 1;
                    break;
                }
            break;
            case CCV_16UC1:
                switch(Mod)
                {
                    case MHC_CIRCULA_DOWN_TO_TOP:
                        for(j=nStartY;j<nStartY+size;j++)
                        {
                            memcpy(&u16_buffer[(j-nStartY)*nnWidth],&matIn_Out->ptr_ushort[j*nnWidth],nWidth*sizeof(Uint16));
                        }
                        for(j=nStartY;j<nStartY+nHeight-size;j++)
                        {
                            memcpy(&matIn_Out->ptr_ushort[j*nnWidth+nStartX],&matIn_Out->ptr_ushort[(j+size)*nnWidth+nStartX],nWidth*sizeof(Uint16));
                        }
                        for(j=nStartY+nHeight-size;j<nStartY+nHeight;j++)
                        {
                            memcpy(&matIn_Out->ptr_ushort[j*nnWidth+nStartX],&u16_buffer[(j-(nStartY+nHeight-size))*nnWidth],nWidth*sizeof(Uint16));
                        }
                    break;
                    case MHC_CIRCULA_TOP_TO_DOWN:
                        for(j=nStartY+nHeight-1;j>nStartY+nHeight-1-size;j--)
                        {
                            memcpy(&u16_buffer[((nStartY+nHeight-1)-j)*nnWidth],&matIn_Out->ptr_ushort[j*nnWidth+nStartX],nWidth*sizeof(Uint16));
                        }
                        for(j=nStartY+nHeight-1;j>=nStartY+size;j--)
                        {
                            memcpy(&matIn_Out->ptr_ushort[j*nnWidth+nStartX],&matIn_Out->ptr_ushort[(j-size)*nnWidth+nStartX],nWidth*sizeof(Uint16));
                        }
                        for(j=nStartY+size-1;j>=nStartY;j--)
                        {
                            memcpy(&matIn_Out->ptr_ushort[j*nnWidth+nStartX],&u16_buffer[((nStartY+size-1)-j)*nnWidth],nWidth*sizeof(Uint16));
                        }
                    break;
                    default:
                        return 1;
                    break;
                }
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 MyDelJudgeNoLine(MyConect *ImageConectIn,MyConect *ImageConectOut,Int32 linewidth,Int32 top_deep_hight)
    {
        Int32 mianji=0;
        Int32 Index;
        Int32 AllMarkPointCount=0;

        if(ImageConectOut==ImageConectIn)
        {
            MyCopyObjQuick(ImageConectIn,&conect_buffer3);
        }

        ImageConectOut->mianji=0;
        ImageConectOut->AllMarkPointCount=0;
        ImageConectOut->nHeight=ImageConectIn->nHeight;
        ImageConectOut->nWidth=ImageConectIn->nWidth;
        ImageConectOut->startx=ImageConectIn->startx;
        ImageConectOut->starty=ImageConectIn->starty;
        ImageConectOut->height=ImageConectIn->height;
        ImageConectOut->width=ImageConectIn->width;
        ImageConectOut->memPoint=ImageConectIn->memPoint;

        if(ImageConectOut!=ImageConectIn)
        {
            for(Index=0; Index<ImageConectIn->AllMarkPointCount; Index++)
            {
                Int32 reallinewidth=ImageConectIn->AllMarkPoint[Index].right-ImageConectIn->AllMarkPoint[Index].left+1;
                Int32 realtop_deep_hight=ImageConectIn->AllMarkPoint[Index].bottom-ImageConectIn->AllMarkPoint[Index].top+1;
                if(reallinewidth<linewidth&&realtop_deep_hight>top_deep_hight)
                {
                    continue;
                }
                else
                {
                    ImageConectOut->AllMarkPoint[AllMarkPointCount]=ImageConectIn->AllMarkPoint[Index];
                    AllMarkPointCount++;
                    mianji=mianji+ImageConectIn->AllMarkPoint[Index].PointArea;
                }
            }
        }
        else
        {
            for(Index=0; Index<conect_buffer3.AllMarkPointCount; Index++)
            {
                Int32 reallinewidth=ImageConectIn->AllMarkPoint[Index].right-conect_buffer3.AllMarkPoint[Index].left+1;
                Int32 realtop_deep_hight=ImageConectIn->AllMarkPoint[Index].bottom-conect_buffer3.AllMarkPoint[Index].top+1;
                if(reallinewidth<linewidth&&realtop_deep_hight>top_deep_hight)
                {
                    continue;
                }
                else
                {
                    ImageConectOut->AllMarkPoint[AllMarkPointCount]=conect_buffer3.AllMarkPoint[Index];
                    AllMarkPointCount++;
                    mianji=mianji+ImageConectIn->AllMarkPoint[Index].PointArea;
                }
            }
        }
        ImageConectOut->AllMarkPointCount=AllMarkPointCount;
        ImageConectOut->mianji=mianji;
        return 0;
    }

    Int8 MyGetXlong(Mat matIn,Int32 *XlongOut)
    {
        Uint32 nnWidth=matIn.nWidth;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        Int32 x,y;
        *XlongOut=0;

        for(x=nStartX;x<nStartX+nWidth;x++)
        {
            for(y=nStartY;y<nStartY+nHeight;y++)
            {
                if(matIn.data[y*nnWidth+x]!=0)
                {
                    (*XlongOut)++;
                    break;
                }
            }
        }
        return 0;
    }

    Int8 MyGetYlong(Mat matIn,Int32 *YlongOut)
    {
        Uint32 nnWidth=matIn.nWidth;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        Int32 x,y;
        *YlongOut=0;

        for(y=nStartY;y<nStartY+nHeight;y++)
        {
            for(x=nStartX;x<nStartX+nWidth;x++)
            {
                if(matIn.data[y*nnWidth+x]!=0)
                {
                    (*YlongOut)++;
                    break;
                }
            }
        }
        return 0;
    }

    Int8 MyGetBigCannyforminCanny(Mat matInBig,Mat matInSmall,Mat *matOut,Int32 size,Int32 value)
    {
        Int32 nnWidth_min=matInSmall.nWidth;
        Int32 nStartX_min=matInSmall.startx;
        Int32 nStartY_min=matInSmall.starty;
        Int32 nWidth_min=matInSmall.width;
        Int32 nHeight_min=matInSmall.height;
        Int32 nnWidth=matInBig.nWidth;
        Int32 nStartX=matInBig.startx;
        Int32 nStartY=matInBig.starty;
        Int32 nWidth=matInBig.width;
        Int32 nHeight=matInBig.height;
        Int32 i,j;
        Int32 x,y;
        Int32 deep=0;
        Int32 top=matInBig.nHeight;
        Int32 left=matInBig.nWidth;
        Int32 right=0;

        getcloneinfo(matInBig,matOut);
        MatSet1col(matOut,0);

        for(i=nStartX_min;i<nStartX_min+nWidth_min;i++)
        {
            Int32 Stj=-1;
            Int32 Edj=-1;
            Int32 Sti;
            Int32 Edi;
            Int32 i32_min=257;
            Int32 i32_max=-1;
            for(j=nStartY_min;j<nStartY_min+nHeight_min;j++)
            {
                if(matInSmall.data[j*nnWidth_min+i]!=0)
                {
                    Stj=j;
                    break;
                }
            }
            if(Stj==-1)
                continue;
            for(j=nStartY_min+nHeight_min-1;j>=nStartY_min;j--)
            {
                if(matInSmall.data[j*nnWidth_min+i]!=0)
                {
                    Edj=j;
                    break;
                }
            }
            Stj=Stj*4-size;
            Edj=Edj*4+size;
            Sti=i*4-2;
            Edi=i*4+2;
            if(Stj<nStartY)
                Stj=nStartY;
            if(Stj>nHeight+nStartY-1)
                Stj=nHeight+nStartY-1;
            if(Edj<nStartY)
                Edj=nStartY;
            if(Edj>nHeight+nStartY-1)
                Edi=nHeight+nStartY-1;
            if(Sti<nStartX)
                Sti=nStartX;
            if(Sti>nStartX+nWidth-1)
                Sti=nStartX+nWidth-1;
            if(Edi<nStartX)
                Edi=nStartX;
            if(Edi>nStartX+nWidth-1)
                Edi=nStartX+nWidth-1;

            for(y=Stj;y<=Edj;y++)
            {
                for(x=Sti;x<=Edi;x++)
                {
                    Int32 val=matInBig.ptr_uchar[y*nnWidth+x];
                    if(i32_min>val)
                    {
                        i32_min=val;
                    }
                    if(i32_max<val)
                    {
                        i32_max=val;
                    }
                }
            }
            if(i32_max-i32_min>=value)
            {
                Int32 i32_dec=(255<<8)/(i32_max-i32_min);
                for(y=Stj;y<=Edj;y++)
                {
                    for(x=Sti;x<=Edi;x++)
                    {
                        Int32 val=(((matInBig.ptr_uchar[y*nnWidth+x]-i32_min)*i32_dec)>>8);
                        if(val>255)
                            val=255;
                        if(val<0)
                            val=0;
                        matOut->data[y*nnWidth+x]=(Uint8)val;
                    }
                }
            }
            if(Stj<top)
            {
                top=Stj;
            }
            if(Edj>deep)
            {
                deep=Edj;
            }
            if(Sti<left)
            {
                left=Sti;
            }
            if(Edi>right)
            {
                right=Edi;
            }
        }
        if(deep!=0&&right!=0)
        {
            matOut->starty=top;
            matOut->startx=left;
            matOut->width=right-left+1;
            matOut->height=deep-top+1;
        }
        return 0;
    }

    Int8 MyGetBigCannyforminCanny_rowline(Mat matInBig,Mat matInSmall,Mat *matOut,L_line lineIn,Int32 lineInsize,Int32 value)
    {
        Int32 nnWidth_min=matInSmall.nWidth;
        Mat cvline=MatCreatzero(3,nnWidth_min,CCV_8UC1,u8_buffer_x1Temp6);
        Int32 m;
        L_line32 l32_line;
        L_line32 l32_templine;

        getcloneinfo(matInBig,matOut);
        MatSet1col(matOut,0);
        Myconnection(matInSmall,&conect_buffer2,1,0,MHC_8LT,u8_buffer_x1Temp5);
        if(conect_buffer2.AllMarkPointCount==0)
        {
            return 0;
        }
        for(m=0;m<conect_buffer2.AllMarkPointCount;m++)
        {
            Uint32 left=conect_buffer2.AllMarkPoint[m].left;
            Uint32 right=conect_buffer2.AllMarkPoint[m].right;
            memset(&cvline.data[nnWidth_min+left],255,right-left+1);
        }
        Myconnection(cvline,&conect_buffer2,1,0,MHC_8LT,u8_buffer_x1Temp5);
        Myline16to32(lineIn,&l32_line);
        for(m=0;m<conect_buffer2.AllMarkPointCount;m++)
        {
            Int32 left=conect_buffer2.AllMarkPoint[m].left;
            Int32 right=conect_buffer2.AllMarkPoint[m].right;
            l32_templine.st.x=left;
            MyGetLine32Ypos(l32_line,left,&l32_templine.st.y);
            l32_templine.ed.x=right;
            MyGetLine32Ypos(l32_line,right,&l32_templine.ed.y);
            l32_templine.st.x=(l32_templine.st.x<<2);
            l32_templine.st.y=(l32_templine.st.y<<2);
            l32_templine.ed.x=(l32_templine.ed.x<<2);
            l32_templine.ed.y=(l32_templine.ed.y<<2);

            Mynormalize_rowXY_line32(matInBig,matOut,l32_templine,lineInsize,value);
        }

        return 0;
    }

    Int8 Mynormalize_rowXY_line32_INVbry(Mat matIn,Mat *matOut,L_line32 l32_line,Int32 lineInsize,double value,Int32 bry_value,binarysidemod bry_mod,Mat smallIn,Int32 size_value)
    {
        Int32 nnWidth=matIn.nWidth;
        Int32 nnHeight=matIn.nHeight;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        Int32 j;
        Int32 i32_max,i32_min;
        float f_max,f_min;
        double d_max,d_min;
        Int32 i32_dec;
        Int64 i64_dec;
        double d_dec;
        Int32 i32_value=(Int32)(value+0.5);
        float f_value=(float)value;
        Int32 n;
        Int32 oldj=RANDOM_MAX;
        Int32 *jdata=(Int32*)u8_buffer_x1Temp1;

        matOut->nWidth=matIn.nWidth;
        matOut->nHeight=matIn.nHeight;
        matOut->startx=matIn.startx;
        matOut->starty=matIn.starty;
        matOut->width=matIn.width;
        matOut->height=matIn.height;
        MyconvertTo(matOut,CCV_8UC1);

        MyLinetoPoint(nnHeight,nnWidth,l32_line.st,l32_line.ed,CV_LINE_8LT,1,&conect_buffer3,u8_buffer_x1Temp3);
        for(n=0;n<conect_buffer3.AllMarkPoint[0].PointArea;n++)
        {
            Int32 stj=conect_buffer3.AllMarkPoint[0].point[n].y-lineInsize/2;
            Int32 i=conect_buffer3.AllMarkPoint[0].point[n].x;
            Int32 endj=stj+lineInsize;
            if(oldj!=i)
                oldj=i;
            else
                continue;
            if(i<nStartX||i>=nStartX+nWidth)
                continue;
            if(stj<nStartY)
            {
                stj=nStartY;
            }
            if(stj>nStartY+nHeight-1)
            {
                stj=nStartY+nHeight-1;
            }
            if(endj<nStartY)
            {
                endj=nStartY;
            }
            if(endj>nStartY+nHeight-1)
            {
                endj=nStartY+nHeight-1;
            }
            switch(matIn._type)
            {
                case CCV_8UC1:
                    i32_min=matIn.ptr_uchar[stj*nnWidth+i];
                    i32_max=matIn.ptr_uchar[stj*nnWidth+i];
                    for(j=stj;j<=endj;j++)
                    {
                        Int32 val=matIn.ptr_uchar[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        Int32 count=0;
                        i32_dec=(255<<8)/(i32_max-i32_min);
                        for(j=stj;j<=endj;j++)
                        {
                            Int32 val=(((matIn.ptr_uchar[j*nnWidth+i]-i32_min)*i32_dec)>>8);
                            switch(bry_mod)
                            {
                                case MHC_BARINYSIDE_VALUE_INV:
                                    if(val>bry_value)
                                        matOut->data[j*nnWidth+i]=0;
                                    else
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            matOut->data[j*nnWidth+i]=255;
                                            jdata[count++]=j;
                                        }
                                        else
                                        {
                                            matOut->data[j*nnWidth+i]=0;
                                        }
                                    }
                                break;
                                case MHC_BARINYSIDE_VALUE:
                                    if(val<bry_value)
                                        matOut->data[j*nnWidth+i]=0;
                                    else
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            matOut->data[j*nnWidth+i]=255;
                                            jdata[count++]=j;
                                        }
                                        else
                                        {
                                            matOut->data[j*nnWidth+i]=0;
                                        }
                                    }
                                break;
                                default:
                                    return 1;
                                break;
                            }
                        }
                        if(count>size_value)
                        {
                            Int32 n;
                            for(n=0;n<count;n++)
                            {
                                matOut->data[jdata[n]*nnWidth+i]=0;
                            }
                        }
                    }
                break;
                case CCV_8SC1:
                    i32_min=matIn.ptr_char[stj*nnWidth+i];
                    i32_max=matIn.ptr_char[stj*nnWidth+i];
                    for(j=stj;j<=endj;j++)
                    {
                        Int32 val=matIn.ptr_char[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        Int32 count=0;
                        i32_dec=(255<<8)/(i32_max-i32_min);
                        for(j=stj;j<=endj;j++)
                        {
                            Int32 val=(((matIn.ptr_char[j*nnWidth+i]-i32_min)*i32_dec)>>8);
                            switch(bry_mod)
                            {
                                case MHC_BARINYSIDE_VALUE_INV:
                                    if(val>bry_value)
                                        matOut->data[j*nnWidth+i]=0;
                                    else
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            matOut->data[j*nnWidth+i]=255;
                                            jdata[count++]=j;
                                        }
                                        else
                                        {
                                            matOut->data[j*nnWidth+i]=0;
                                        }
                                    }
                                break;
                                case MHC_BARINYSIDE_VALUE:
                                    if(val<bry_value)
                                        matOut->data[j*nnWidth+i]=0;
                                    else
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            matOut->data[j*nnWidth+i]=255;
                                            jdata[count++]=j;
                                        }
                                        else
                                        {
                                            matOut->data[j*nnWidth+i]=0;
                                        }
                                    }
                                break;
                                default:
                                    return 1;
                                break;
                            }
                        }
                        if(count>size_value)
                        {
                            Int32 n;
                            for(n=0;n<count;n++)
                            {
                                matOut->data[jdata[n]*nnWidth+i]=0;
                            }
                        }
                    }
                break;
                case CCV_16UC1:
                    i32_min=matIn.ptr_ushort[stj*nnWidth+i];
                    i32_max=matIn.ptr_ushort[stj*nnWidth+i];
                    for(j=stj;j<=endj;j++)
                    {
                        Int32 val=matIn.ptr_ushort[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        Int32 count=0;
                        i32_dec=(255<<8)/(i32_max-i32_min);
                        for(j=stj;j<=endj;j++)
                        {
                            Int32 val=(((matIn.ptr_ushort[j*nnWidth+i]-i32_min)*i32_dec)>>16);
                            switch(bry_mod)
                            {
                                case MHC_BARINYSIDE_VALUE_INV:
                                    if(val>bry_value)
                                        matOut->data[j*nnWidth+i]=0;
                                    else
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            matOut->data[j*nnWidth+i]=255;
                                            jdata[count++]=j;
                                        }
                                        else
                                        {
                                            matOut->data[j*nnWidth+i]=0;
                                        }
                                    }
                                break;
                                case MHC_BARINYSIDE_VALUE:
                                    if(val<bry_value)
                                        matOut->data[j*nnWidth+i]=0;
                                    else
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            matOut->data[j*nnWidth+i]=255;
                                            jdata[count++]=j;
                                        }
                                        else
                                        {
                                            matOut->data[j*nnWidth+i]=0;
                                        }
                                    }
                                default:
                                    return 1;
                                break;
                            }
                        }
                        if(count>size_value)
                        {
                            Int32 n;
                            for(n=0;n<count;n++)
                            {
                                matOut->data[jdata[n]*nnWidth+i]=0;
                            }
                        }
                    }
                break;
                case CCV_16SC1:
                    i32_min=matIn.ptr_short[stj*nnWidth+i];
                    i32_max=matIn.ptr_short[stj*nnWidth+i];
                    for(j=stj;j<=endj;j++)
                    {
                        Int32 val=matIn.ptr_short[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        Int32 count=0;
                        i32_dec=(255<<8)/(i32_max-i32_min);
                        for(j=stj;j<=endj;j++)
                        {
                            Int32 val=(((matIn.ptr_short[j*nnWidth+i]-i32_min)*i32_dec)>>16);
                            switch(bry_mod)
                            {
                                case MHC_BARINYSIDE_VALUE_INV:
                                    if(val>bry_value)
                                        matOut->data[j*nnWidth+i]=0;
                                    else
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            matOut->data[j*nnWidth+i]=255;
                                            jdata[count++]=j;
                                        }
                                        else
                                        {
                                            matOut->data[j*nnWidth+i]=0;
                                        }
                                    }
                                break;
                                case MHC_BARINYSIDE_VALUE:
                                    if(val<bry_value)
                                        matOut->data[j*nnWidth+i]=0;
                                    else
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            matOut->data[j*nnWidth+i]=255;
                                            jdata[count++]=j;
                                        }
                                        else
                                        {
                                            matOut->data[j*nnWidth+i]=0;
                                        }
                                    }
                                default:
                                    return 1;
                                break;
                            }
                        }
                        if(count>size_value)
                        {
                            Int32 n;
                            for(n=0;n<count;n++)
                            {
                                matOut->data[jdata[n]*nnWidth+i]=0;
                            }
                        }
                    }
                break;
                case CCV_32SC1:
                    i32_min=matIn.ptr_int[stj*nnWidth+i];
                    i32_max=matIn.ptr_int[stj*nnWidth+i];
                    for(j=stj;j<=endj;j++)
                    {
                        Int32 val=matIn.ptr_int[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        Int32 count=0;
                        i64_dec=(((Uint64)255)<<32)/(i32_max-i32_min);
                        for(j=stj;j<=endj;j++)
                        {
                            Int32 val=(((matIn.ptr_int[j*nnWidth+i]-i32_min)*i64_dec)>>32);
                            switch(bry_mod)
                            {
                                case MHC_BARINYSIDE_VALUE_INV:
                                    if(val>bry_value)
                                        matOut->data[j*nnWidth+i]=0;
                                    else
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            matOut->data[j*nnWidth+i]=255;
                                            jdata[count++]=j;
                                        }
                                        else
                                        {
                                            matOut->data[j*nnWidth+i]=0;
                                        }
                                    }
                                break;
                                case MHC_BARINYSIDE_VALUE:
                                    if(val<bry_value)
                                        matOut->data[j*nnWidth+i]=0;
                                    else
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            matOut->data[j*nnWidth+i]=255;
                                            jdata[count++]=j;
                                        }
                                        else
                                        {
                                            matOut->data[j*nnWidth+i]=0;
                                        }
                                    }
                                default:
                                    return 1;
                                break;
                            }
                        }
                        if(count>size_value)
                        {
                            Int32 n;
                            for(n=0;n<count;n++)
                            {
                                matOut->data[jdata[n]*nnWidth+i]=0;
                            }
                        }
                    }
                break;
                case CCV_32FC1:
                    f_min=matIn.ptr_float[stj*nnWidth+i];
                    f_max=matIn.ptr_float[stj*nnWidth+i];
                    for(j=stj;j<=endj;j++)
                    {
                        float val=matIn.ptr_float[j*nnWidth+i];
                        if(f_min>val)
                        {
                            f_min=val;
                        }
                        if(f_max<val)
                        {
                            f_max=val;
                        }
                    }
                    if(f_max-f_min>=f_value)
                    {
                        Int32 count=0;
                        d_dec=255.0/(double)(f_max-f_min);
                        for(j=stj;j<=endj;j++)
                        {
                            Int32 val=(matIn.ptr_float[j*nnWidth+i]-f_min)*d_dec+0.5;
                            switch(bry_mod)
                            {
                                case MHC_BARINYSIDE_VALUE_INV:
                                    if(val>bry_value)
                                        matOut->data[j*nnWidth+i]=0;
                                    else
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            matOut->data[j*nnWidth+i]=255;
                                            jdata[count++]=j;
                                        }
                                        else
                                        {
                                            matOut->data[j*nnWidth+i]=0;
                                        }
                                    }
                                break;
                                case MHC_BARINYSIDE_VALUE:
                                    if(val<bry_value)
                                        matOut->data[j*nnWidth+i]=0;
                                    else
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            matOut->data[j*nnWidth+i]=255;
                                            jdata[count++]=j;
                                        }
                                        else
                                        {
                                            matOut->data[j*nnWidth+i]=0;
                                        }
                                    }
                                break;
                                default:
                                    return 1;
                                break;
                            }
                        }
                        if(count>size_value)
                        {
                            Int32 n;
                            for(n=0;n<count;n++)
                            {
                                matOut->data[jdata[n]*nnWidth+i]=0;
                            }
                        }
                    }
                break;
                case CCV_64FC1:
                    d_min=matIn.ptr_double[stj*nnWidth+i];
                    d_max=matIn.ptr_double[stj*nnWidth+i];
                    for(j=stj;j<=endj;j++)
                    {
                        double val=matIn.ptr_double[j*nnWidth+i];
                        if(d_min>val)
                        {
                            d_min=val;
                        }
                        if(d_max<val)
                        {
                            d_max=val;
                        }
                    }
                    if(d_max-d_min>=value)
                    {
                        Int32 count=0;
                        d_dec=255.0/(double)(d_max-d_min);
                        for(j=stj;j<=endj;j++)
                        {
                            Int32 val=(matIn.ptr_double[j*nnWidth+i]-d_min)*d_dec+0.5;
                            switch(bry_mod)
                            {
                                case MHC_BARINYSIDE_VALUE_INV:
                                    if(val>bry_value)
                                        matOut->data[j*nnWidth+i]=0;
                                    else
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            matOut->data[j*nnWidth+i]=255;
                                            jdata[count++]=j;
                                        }
                                        else
                                        {
                                            matOut->data[j*nnWidth+i]=0;
                                        }
                                    }
                                break;
                                case MHC_BARINYSIDE_VALUE:
                                    if(val<bry_value)
                                        matOut->data[j*nnWidth+i]=0;
                                    else
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            matOut->data[j*nnWidth+i]=255;
                                            jdata[count++]=j;
                                        }
                                        else
                                        {
                                            matOut->data[j*nnWidth+i]=0;
                                        }
                                    }
                                break;
                                default:
                                    return 1;
                                break;
                            }
                        }
                        if(count>size_value)
                        {
                            Int32 n;
                            for(n=0;n<count;n++)
                            {
                                matOut->data[jdata[n]*nnWidth+i]=0;
                            }
                        }
                    }
                break;
                default:
                    return 2;
                break;
            }
        }

        return 0;
    }

    Int8 MyGetBigCannyforminCanny_rowline_bry(Mat matInBig,Mat matInSmall,Mat *matOut,L_line lineIn,Int32 lineInsize,Int32 value,Int32 bry_value,binarysidemod bry_mod,Int32 size_value,Int32 *leftOut,Int32 *rightOut,Int32 *topOut,Int32 *bottomOut)
    {
        Int32 nnWidth_min=matInSmall.nWidth;
        Mat cvline=MatCreatzero(3,nnWidth_min,CCV_8UC1,u8_buffer_x1Temp6);
        Int32 m;
        L_line32 l32_line;
        L_line32 l32_templine;
        Int32 temptop1,temptop2,temptop;
        Int32 tempdeep;

        getcloneinfo(matInBig,matOut);
        MatSet1col(matOut,0);
        Myconnection(matInSmall,&conect_buffer2,1,0,MHC_8LT,u8_buffer_x1Temp5);
        if(conect_buffer2.AllMarkPointCount==0)
        {
            *leftOut=0;
            *rightOut=0;
            *topOut=0;
            *bottomOut=0;
            return 0;
        }
        for(m=0;m<conect_buffer2.AllMarkPointCount;m++)
        {
            Uint32 left=conect_buffer2.AllMarkPoint[m].left;
            Uint32 right=conect_buffer2.AllMarkPoint[m].right;
            memset(&cvline.data[nnWidth_min+left],255,right-left+1);
        }
        Myconnection(cvline,&conect_buffer2,1,0,MHC_8LT,u8_buffer_x1Temp5);
        Myline16to32(lineIn,&l32_line);
        for(m=0;m<conect_buffer2.AllMarkPointCount;m++)
        {
            Int32 left=conect_buffer2.AllMarkPoint[m].left;
            Int32 right=conect_buffer2.AllMarkPoint[m].right;
            l32_templine.st.x=left;
            MyGetLine32Ypos(l32_line,left,&l32_templine.st.y);
            l32_templine.ed.x=right;
            MyGetLine32Ypos(l32_line,right,&l32_templine.ed.y);
            l32_templine.st.x=(l32_templine.st.x<<2);
            l32_templine.st.y=(l32_templine.st.y<<2);
            l32_templine.ed.x=(l32_templine.ed.x<<2);
            l32_templine.ed.y=(l32_templine.ed.y<<2);

            Mynormalize_rowXY_line32_INVbry(matInBig,matOut,l32_templine,lineInsize,value,bry_value,bry_mod,matInSmall,size_value);
        }
        *leftOut=(conect_buffer2.AllMarkPoint[0].left<<2);
        *rightOut=(conect_buffer2.AllMarkPoint[conect_buffer2.AllMarkPointCount-1].right<<2);
        MyGetLine32Ypos(l32_line,conect_buffer2.AllMarkPoint[0].left,&temptop1);
        MyGetLine32Ypos(l32_line,conect_buffer2.AllMarkPoint[conect_buffer2.AllMarkPointCount-1].right,&temptop2);
        temptop=MIN(temptop1,temptop2);
        temptop=(temptop<<2)-(lineInsize>>2);
        if(temptop<(Int32)matInBig.starty)
        {
            temptop=matInBig.starty;
        }
        tempdeep=MAX(temptop1,temptop2);
        tempdeep=(tempdeep<<2)-(lineInsize>>2)+lineInsize;
        if(tempdeep>matInBig.starty+matInBig.height-1)
        {
            tempdeep=matInBig.starty+matInBig.height-1;
        }
        *topOut=temptop;
        *bottomOut=tempdeep;
        return 0;
    }

    Int8 Mynormalize_rowXY_line32_INVlinePoint(Mat matIn,Int32 *Xpoint,Int32 *Ypoint,Int32 *Totalcount,L_line32 l32_line,Int32 lineInsize,double value,Int32 bry_value,binarysidemod bry_mod,Mat smallIn,Int32 size_value)
    {
        Int32 nnWidth=matIn.nWidth;
        Int32 nnHeight=matIn.nHeight;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        Int32 j;
        Int32 i32_max,i32_min;
        float f_max,f_min;
        double d_max,d_min;
        Int32 i32_dec;
        Int64 i64_dec;
        double d_dec;
        Int32 i32_value=(Int32)(value+0.5);
        float f_value=(float)value;
        Int32 n;
        Int32 oldj=RANDOM_MAX;
        Int32 *jdata=(Int32*)u8_buffer_x1Temp1;

        MyLinetoPoint(nnHeight,nnWidth,l32_line.st,l32_line.ed,CV_LINE_8LT,1,&conect_buffer3,u8_buffer_x1Temp3);
        for(n=0;n<conect_buffer3.AllMarkPoint[0].PointArea;n++)
        {
            Int32 stj=conect_buffer3.AllMarkPoint[0].point[n].y-lineInsize/2;
            Int32 i=conect_buffer3.AllMarkPoint[0].point[n].x;
            Int32 endj=stj+lineInsize;
            if(oldj!=i)
                oldj=i;
            else
                continue;
            if(i<nStartX||i>=nStartX+nWidth)
                continue;
            if(stj<nStartY)
            {
                stj=nStartY;
            }
            if(stj>nStartY+nHeight-1)
            {
                stj=nStartY+nHeight-1;
            }
            if(endj<nStartY)
            {
                endj=nStartY;
            }
            if(endj>nStartY+nHeight-1)
            {
                endj=nStartY+nHeight-1;
            }
            switch(matIn._type)
            {
                case CCV_8UC1:
                    i32_min=matIn.ptr_uchar[stj*nnWidth+i];
                    i32_max=matIn.ptr_uchar[stj*nnWidth+i];
                    for(j=stj;j<=endj;j++)
                    {
                        Int32 val=matIn.ptr_uchar[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        Int32 count=0;
                        i32_dec=(255<<8)/(i32_max-i32_min);
                        for(j=stj;j<=endj;j++)
                        {
                            Int32 val=(((matIn.ptr_uchar[j*nnWidth+i]-i32_min)*i32_dec)>>8);
                            switch(bry_mod)
                            {
                                case MHC_BARINYSIDE_VALUE_INV:
                                    if(val<=bry_value)
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            jdata[count++]=j;
                                        }
                                    }
                                break;
                                case MHC_BARINYSIDE_VALUE:
                                    if(val>=bry_value)
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            jdata[count++]=j;
                                        }
                                    }
                                    break;
                                default:
                                    return 1;
                                break;
                            }
                        }
                        if(count<=size_value)
                        {
                            Int32 n;
                            for(n=0;n<count;n++)
                            {
                                Xpoint[*Totalcount]=i;
                                Ypoint[*Totalcount]=jdata[n];
                                (*Totalcount)++;
                            }
                        }
                    }
                break;
                case CCV_8SC1:
                    i32_min=matIn.ptr_char[stj*nnWidth+i];
                    i32_max=matIn.ptr_char[stj*nnWidth+i];
                    for(j=stj;j<=endj;j++)
                    {
                        Int32 val=matIn.ptr_char[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        Int32 count=0;
                        i32_dec=(255<<8)/(i32_max-i32_min);
                        for(j=stj;j<=endj;j++)
                        {
                            Int32 val=(((matIn.ptr_char[j*nnWidth+i]-i32_min)*i32_dec)>>8);
                            switch(bry_mod)
                            {
                                case MHC_BARINYSIDE_VALUE_INV:
                                    if(val<=bry_value)
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            jdata[count++]=j;
                                        }
                                    }
                                break;
                                case MHC_BARINYSIDE_VALUE:
                                    if(val>=bry_value)
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            jdata[count++]=j;
                                        }
                                    }
                                break;
                                default:
                                    return 1;
                                break;
                            }
                        }
                        if(count<=size_value)
                        {
                            Int32 n;
                            for(n=0;n<count;n++)
                            {
                                Xpoint[*Totalcount]=i;
                                Ypoint[*Totalcount]=jdata[n];
                                (*Totalcount)++;
                            }
                        }
                    }
                break;
                case CCV_16UC1:
                    i32_min=matIn.ptr_ushort[stj*nnWidth+i];
                    i32_max=matIn.ptr_ushort[stj*nnWidth+i];
                    for(j=stj;j<=endj;j++)
                    {
                        Int32 val=matIn.ptr_ushort[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        Int32 count=0;
                        i32_dec=(255<<8)/(i32_max-i32_min);
                        for(j=stj;j<=endj;j++)
                        {
                            Int32 val=(((matIn.ptr_ushort[j*nnWidth+i]-i32_min)*i32_dec)>>16);
                            switch(bry_mod)
                            {
                                case MHC_BARINYSIDE_VALUE_INV:
                                    if(val<=bry_value)
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            jdata[count++]=j;
                                        }
                                    }
                                break;
                                case MHC_BARINYSIDE_VALUE:
                                    if(val>=bry_value)
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            jdata[count++]=j;
                                        }
                                    }
                                break;
                                default:
                                    return 1;
                                break;
                            }
                        }
                        if(count<=size_value)
                        {
                            Int32 n;
                            for(n=0;n<count;n++)
                            {
                                Xpoint[*Totalcount]=i;
                                Ypoint[*Totalcount]=jdata[n];
                                (*Totalcount)++;
                            }
                        }
                    }
                break;
                case CCV_16SC1:
                    i32_min=matIn.ptr_short[stj*nnWidth+i];
                    i32_max=matIn.ptr_short[stj*nnWidth+i];
                    for(j=stj;j<=endj;j++)
                    {
                        Int32 val=matIn.ptr_short[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        Int32 count=0;
                        i32_dec=(255<<8)/(i32_max-i32_min);
                        for(j=stj;j<=endj;j++)
                        {
                            Int32 val=(((matIn.ptr_short[j*nnWidth+i]-i32_min)*i32_dec)>>16);
                            switch(bry_mod)
                            {
                                case MHC_BARINYSIDE_VALUE_INV:
                                    if(val<=bry_value)
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            jdata[count++]=j;
                                        }
                                    }
                                break;
                                case MHC_BARINYSIDE_VALUE:
                                    if(val>=bry_value)
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            jdata[count++]=j;
                                        }
                                    }
                                break;
                                default:
                                    return 1;
                                break;
                            }
                        }
                        if(count<=size_value)
                        {
                            Int32 n;
                            for(n=0;n<count;n++)
                            {
                                Xpoint[*Totalcount]=i;
                                Ypoint[*Totalcount]=jdata[n];
                                (*Totalcount)++;
                            }
                        }
                    }
                break;
                case CCV_32SC1:
                    i32_min=matIn.ptr_int[stj*nnWidth+i];
                    i32_max=matIn.ptr_int[stj*nnWidth+i];
                    for(j=stj;j<=endj;j++)
                    {
                        Int32 val=matIn.ptr_int[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        Int32 count=0;
                        i64_dec=(((Uint64)255)<<32)/(i32_max-i32_min);
                        for(j=stj;j<=endj;j++)
                        {
                            Int32 val=(((matIn.ptr_int[j*nnWidth+i]-i32_min)*i64_dec)>>32);
                            switch(bry_mod)
                            {
                                case MHC_BARINYSIDE_VALUE_INV:
                                    if(val<=bry_value)
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            jdata[count++]=j;
                                        }
                                    }
                                break;
                                case MHC_BARINYSIDE_VALUE:
                                    if(val>=bry_value)
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            jdata[count++]=j;
                                        }
                                    }
                                break;
                                default:
                                    return 1;
                                break;
                            }
                        }
                        if(count<=size_value)
                        {
                            Int32 n;
                            for(n=0;n<count;n++)
                            {
                                Xpoint[*Totalcount]=i;
                                Ypoint[*Totalcount]=jdata[n];
                                (*Totalcount)++;
                            }
                        }
                    }
                break;
                case CCV_32FC1:
                    f_min=matIn.ptr_float[stj*nnWidth+i];
                    f_max=matIn.ptr_float[stj*nnWidth+i];
                    for(j=stj;j<=endj;j++)
                    {
                        float val=matIn.ptr_float[j*nnWidth+i];
                        if(f_min>val)
                        {
                            f_min=val;
                        }
                        if(f_max<val)
                        {
                            f_max=val;
                        }
                    }
                    if(f_max-f_min>=f_value)
                    {
                        Int32 count=0;
                        d_dec=255.0/(double)(f_max-f_min);
                        for(j=stj;j<=endj;j++)
                        {
                            Int32 val=(matIn.ptr_float[j*nnWidth+i]-f_min)*d_dec+0.5;
                            switch(bry_mod)
                            {
                                case MHC_BARINYSIDE_VALUE_INV:
                                    if(val<=bry_value)
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            jdata[count++]=j;
                                        }
                                    }
                                break;
                                case MHC_BARINYSIDE_VALUE:
                                    if(val>=bry_value)
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            jdata[count++]=j;
                                        }
                                    }
                                break;
                                default:
                                    return 1;
                                break;
                            }
                        }
                        if(count<=size_value)
                        {
                            Int32 n;
                            for(n=0;n<count;n++)
                            {
                                Xpoint[*Totalcount]=i;
                                Ypoint[*Totalcount]=jdata[n];
                                (*Totalcount)++;
                            }
                        }
                    }
                break;
                case CCV_64FC1:
                    d_min=matIn.ptr_double[stj*nnWidth+i];
                    d_max=matIn.ptr_double[stj*nnWidth+i];
                    for(j=stj;j<=endj;j++)
                    {
                        double val=matIn.ptr_double[j*nnWidth+i];
                        if(d_min>val)
                        {
                            d_min=val;
                        }
                        if(d_max<val)
                        {
                            d_max=val;
                        }
                    }
                    if(d_max-d_min>=value)
                    {
                        Int32 count=0;
                        d_dec=255.0/(double)(d_max-d_min);
                        for(j=stj;j<=endj;j++)
                        {
                            Int32 val=(matIn.ptr_double[j*nnWidth+i]-d_min)*d_dec+0.5;
                            switch(bry_mod)
                            {
                                case MHC_BARINYSIDE_VALUE_INV:
                                    if(val<=bry_value)
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            jdata[count++]=j;
                                        }
                                    }
                                break;
                                case MHC_BARINYSIDE_VALUE:
                                    if(val>=bry_value)
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            jdata[count++]=j;
                                        }
                                    }
                                break;
                                default:
                                    return 1;
                                break;
                            }
                        }
                        if(count<=size_value)
                        {
                            Int32 n;
                            for(n=0;n<count;n++)
                            {
                                Xpoint[*Totalcount]=i;
                                Ypoint[*Totalcount]=jdata[n];
                                (*Totalcount)++;
                            }
                        }
                    }
                break;
                default:
                    return 2;
                break;
            }
        }

        return 0;
    }

    Int8 Mynormalize_rowXY_line32_HOVlinePoint(Mat matIn,Uint16 *pEdgeMapList,Uint16 *pEdgeMapListNum,L_line32 l32_line,Int32 lineInsize,double value,Int32 bry_value,binarysidemod bry_mod,Mat smallIn,Int32 size_value)
    {
        Int32 nnWidth=matIn.nWidth;
        Int32 nnHeight=matIn.nHeight;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        Int32 j;
        Int32 i32_max,i32_min;
        float f_max,f_min;
        double d_max,d_min;
        Int32 i32_dec;
        Int64 i64_dec;
        double d_dec;
        Int32 i32_value=(Int32)(value+0.5);
        float f_value=(float)value;
        Int32 n;
        Int32 oldj=RANDOM_MAX;
        Int32 *jdata=(Int32*)u8_buffer_x1Temp1;

        MyLinetoPoint(nnHeight,nnWidth,l32_line.st,l32_line.ed,CV_LINE_8LT,1,&conect_buffer3,u8_buffer_x1Temp3);
        for(n=0;n<conect_buffer3.AllMarkPoint[0].PointArea;n++)
        {
            Int32 stj=conect_buffer3.AllMarkPoint[0].point[n].y-lineInsize/2;
            Int32 i=conect_buffer3.AllMarkPoint[0].point[n].x;
            Int32 endj=stj+lineInsize;
            if(oldj!=i)
                oldj=i;
            else
                continue;
            if(i<nStartX||i>=nStartX+nWidth)
                continue;
            if(stj<nStartY)
            {
                stj=nStartY;
            }
            if(stj>nStartY+nHeight-1)
            {
                stj=nStartY+nHeight-1;
            }
            if(endj<nStartY)
            {
                endj=nStartY;
            }
            if(endj>nStartY+nHeight-1)
            {
                endj=nStartY+nHeight-1;
            }
            switch(matIn._type)
            {
                case CCV_8UC1:
                    i32_min=matIn.ptr_uchar[stj*nnWidth+i];
                    i32_max=matIn.ptr_uchar[stj*nnWidth+i];
                    for(j=stj;j<=endj;j++)
                    {
                        Int32 val=matIn.ptr_uchar[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        Int32 count=0;
                        i32_dec=(255<<8)/(i32_max-i32_min);
                        for(j=stj;j<=endj;j++)
                        {
                            Int32 val=(((matIn.ptr_uchar[j*nnWidth+i]-i32_min)*i32_dec)>>8);
                            switch(bry_mod)
                            {
                                case MHC_BARINYSIDE_VALUE_INV:
                                    if(val<=bry_value)
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            jdata[count++]=j;
                                        }
                                    }
                                break;
                                case MHC_BARINYSIDE_VALUE:
                                    if(val>=bry_value)
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            jdata[count++]=j;
                                        }
                                    }
                                    break;
                                default:
                                    return 1;
                                break;
                            }
                        }
                        if(count<=size_value)
                        {
                            Int32 n;
                            for(n=0;n<count;n++)
                            {
                                pEdgeMapList[(*pEdgeMapListNum)*2]=i;
                                pEdgeMapList[(*pEdgeMapListNum)*2+1]=jdata[n];
                                (*pEdgeMapListNum)++;
                            }
                        }
                    }
                break;
                case CCV_8SC1:
                    i32_min=matIn.ptr_char[stj*nnWidth+i];
                    i32_max=matIn.ptr_char[stj*nnWidth+i];
                    for(j=stj;j<=endj;j++)
                    {
                        Int32 val=matIn.ptr_char[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        Int32 count=0;
                        i32_dec=(255<<8)/(i32_max-i32_min);
                        for(j=stj;j<=endj;j++)
                        {
                            Int32 val=(((matIn.ptr_char[j*nnWidth+i]-i32_min)*i32_dec)>>8);
                            switch(bry_mod)
                            {
                                case MHC_BARINYSIDE_VALUE_INV:
                                    if(val<=bry_value)
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            jdata[count++]=j;
                                        }
                                    }
                                break;
                                case MHC_BARINYSIDE_VALUE:
                                    if(val>=bry_value)
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            jdata[count++]=j;
                                        }
                                    }
                                break;
                                default:
                                    return 1;
                                break;
                            }
                        }
                        if(count<=size_value)
                        {
                            Int32 n;
                            for(n=0;n<count;n++)
                            {
                                pEdgeMapList[(*pEdgeMapListNum)*2]=i;
                                pEdgeMapList[(*pEdgeMapListNum)*2+1]=jdata[n];
                                (*pEdgeMapListNum)++;
                            }
                        }
                    }
                break;
                case CCV_16UC1:
                    i32_min=matIn.ptr_ushort[stj*nnWidth+i];
                    i32_max=matIn.ptr_ushort[stj*nnWidth+i];
                    for(j=stj;j<=endj;j++)
                    {
                        Int32 val=matIn.ptr_ushort[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        Int32 count=0;
                        i32_dec=(255<<8)/(i32_max-i32_min);
                        for(j=stj;j<=endj;j++)
                        {
                            Int32 val=(((matIn.ptr_ushort[j*nnWidth+i]-i32_min)*i32_dec)>>16);
                            switch(bry_mod)
                            {
                                case MHC_BARINYSIDE_VALUE_INV:
                                    if(val<=bry_value)
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            jdata[count++]=j;
                                        }
                                    }
                                break;
                                case MHC_BARINYSIDE_VALUE:
                                    if(val>=bry_value)
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            jdata[count++]=j;
                                        }
                                    }
                                break;
                                default:
                                    return 1;
                                break;
                            }
                        }
                        if(count<=size_value)
                        {
                            Int32 n;
                            for(n=0;n<count;n++)
                            {
                                pEdgeMapList[(*pEdgeMapListNum)*2]=i;
                                pEdgeMapList[(*pEdgeMapListNum)*2+1]=jdata[n];
                                (*pEdgeMapListNum)++;
                            }
                        }
                    }
                break;
                case CCV_16SC1:
                    i32_min=matIn.ptr_short[stj*nnWidth+i];
                    i32_max=matIn.ptr_short[stj*nnWidth+i];
                    for(j=stj;j<=endj;j++)
                    {
                        Int32 val=matIn.ptr_short[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        Int32 count=0;
                        i32_dec=(255<<8)/(i32_max-i32_min);
                        for(j=stj;j<=endj;j++)
                        {
                            Int32 val=(((matIn.ptr_short[j*nnWidth+i]-i32_min)*i32_dec)>>16);
                            switch(bry_mod)
                            {
                                case MHC_BARINYSIDE_VALUE_INV:
                                    if(val<=bry_value)
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            jdata[count++]=j;
                                        }
                                    }
                                break;
                                case MHC_BARINYSIDE_VALUE:
                                    if(val>=bry_value)
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            jdata[count++]=j;
                                        }
                                    }
                                break;
                                default:
                                    return 1;
                                break;
                            }
                        }
                        if(count<=size_value)
                        {
                            Int32 n;
                            for(n=0;n<count;n++)
                            {
                                pEdgeMapList[(*pEdgeMapListNum)*2]=i;
                                pEdgeMapList[(*pEdgeMapListNum)*2+1]=jdata[n];
                                (*pEdgeMapListNum)++;
                            }
                        }
                    }
                break;
                case CCV_32SC1:
                    i32_min=matIn.ptr_int[stj*nnWidth+i];
                    i32_max=matIn.ptr_int[stj*nnWidth+i];
                    for(j=stj;j<=endj;j++)
                    {
                        Int32 val=matIn.ptr_int[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        Int32 count=0;
                        i64_dec=(((Uint64)255)<<32)/(i32_max-i32_min);
                        for(j=stj;j<=endj;j++)
                        {
                            Int32 val=(((matIn.ptr_int[j*nnWidth+i]-i32_min)*i64_dec)>>32);
                            switch(bry_mod)
                            {
                                case MHC_BARINYSIDE_VALUE_INV:
                                    if(val<=bry_value)
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            jdata[count++]=j;
                                        }
                                    }
                                break;
                                case MHC_BARINYSIDE_VALUE:
                                    if(val>=bry_value)
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            jdata[count++]=j;
                                        }
                                    }
                                break;
                                default:
                                    return 1;
                                break;
                            }
                        }
                        if(count<=size_value)
                        {
                            Int32 n;
                            for(n=0;n<count;n++)
                            {
                                pEdgeMapList[(*pEdgeMapListNum)*2]=i;
                                pEdgeMapList[(*pEdgeMapListNum)*2+1]=jdata[n];
                                (*pEdgeMapListNum)++;
                            }
                        }
                    }
                break;
                case CCV_32FC1:
                    f_min=matIn.ptr_float[stj*nnWidth+i];
                    f_max=matIn.ptr_float[stj*nnWidth+i];
                    for(j=stj;j<=endj;j++)
                    {
                        float val=matIn.ptr_float[j*nnWidth+i];
                        if(f_min>val)
                        {
                            f_min=val;
                        }
                        if(f_max<val)
                        {
                            f_max=val;
                        }
                    }
                    if(f_max-f_min>=f_value)
                    {
                        Int32 count=0;
                        d_dec=255.0/(double)(f_max-f_min);
                        for(j=stj;j<=endj;j++)
                        {
                            Int32 val=(matIn.ptr_float[j*nnWidth+i]-f_min)*d_dec+0.5;
                            switch(bry_mod)
                            {
                                case MHC_BARINYSIDE_VALUE_INV:
                                    if(val<=bry_value)
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            jdata[count++]=j;
                                        }
                                    }
                                break;
                                case MHC_BARINYSIDE_VALUE:
                                    if(val>=bry_value)
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            jdata[count++]=j;
                                        }
                                    }
                                break;
                                default:
                                    return 1;
                                break;
                            }
                        }
                        if(count<=size_value)
                        {
                            Int32 n;
                            for(n=0;n<count;n++)
                            {
                                pEdgeMapList[(*pEdgeMapListNum)*2]=i;
                                pEdgeMapList[(*pEdgeMapListNum)*2+1]=jdata[n];
                                (*pEdgeMapListNum)++;
                            }
                        }
                    }
                break;
                case CCV_64FC1:
                    d_min=matIn.ptr_double[stj*nnWidth+i];
                    d_max=matIn.ptr_double[stj*nnWidth+i];
                    for(j=stj;j<=endj;j++)
                    {
                        double val=matIn.ptr_double[j*nnWidth+i];
                        if(d_min>val)
                        {
                            d_min=val;
                        }
                        if(d_max<val)
                        {
                            d_max=val;
                        }
                    }
                    if(d_max-d_min>=value)
                    {
                        Int32 count=0;
                        d_dec=255.0/(double)(d_max-d_min);
                        for(j=stj;j<=endj;j++)
                        {
                            Int32 val=(matIn.ptr_double[j*nnWidth+i]-d_min)*d_dec+0.5;
                            switch(bry_mod)
                            {
                                case MHC_BARINYSIDE_VALUE_INV:
                                    if(val<=bry_value)
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            jdata[count++]=j;
                                        }
                                    }
                                break;
                                case MHC_BARINYSIDE_VALUE:
                                    if(val>=bry_value)
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            jdata[count++]=j;
                                        }
                                    }
                                break;
                                default:
                                    return 1;
                                break;
                            }
                        }
                        if(count<=size_value)
                        {
                            Int32 n;
                            for(n=0;n<count;n++)
                            {
                                pEdgeMapList[(*pEdgeMapListNum)*2]=i;
                                pEdgeMapList[(*pEdgeMapListNum)*2+1]=jdata[n];
                                (*pEdgeMapListNum)++;
                            }
                        }
                    }
                break;
                default:
                    return 2;
                break;
            }
        }

        return 0;
    }


    Int8 MyGetBigCannyforminCanny_rowline_outline(Mat matInBig,Mat matInSmall,L_line *lineOut,houghlineinfo *houghinfoOut,sqaretype Mod,L_line lineIn,Int32 lineInsize,Int32 value,Int32 bry_value,binarysidemod bry_mod,Int32 size_value)
    {
        Int32 nnWidth_min=matInSmall.nWidth;
        Mat cvline=MatCreatzero(3,nnWidth_min,CCV_8UC1,u8_buffer_x1Temp6);
        Int32 m;
        L_line32 l32_line;
        L_line32 l32_templine;
        Int32 *dataXIn=(Int32*)u8_buffer_x3Temp1;
        Int32 *dataYIn=(Int32*)u8_buffer_x1Temp4;
        Int32 datacount=0;
        Uint16 *pEdgeMapList=(Uint16*)u8_buffer_x3Temp1;
        Uint16 pEdgeMapListNum=0;
        Mat Hough;
        MyCountLine linetemp;
        Uint16 nnWidth=matInBig.nWidth;
        Uint16 nnHeight=matInBig.nHeight;

        Myconnection(matInSmall,&conect_buffer2,1,0,MHC_8LT,u8_buffer_x1Temp5);
        if(conect_buffer2.AllMarkPointCount==0)
        {
            return 1;
        }
        for(m=0;m<conect_buffer2.AllMarkPointCount;m++)
        {
            Uint32 left=conect_buffer2.AllMarkPoint[m].left;
            Uint32 right=conect_buffer2.AllMarkPoint[m].right;
            memset(&cvline.data[nnWidth_min+left],255,right-left+1);
        }
        Myconnection(cvline,&conect_buffer2,1,0,MHC_8LT,u8_buffer_x1Temp5);
        Myline16to32(lineIn,&l32_line);
        for(m=0;m<conect_buffer2.AllMarkPointCount;m++)
        {
            Int32 left=conect_buffer2.AllMarkPoint[m].left;
            Int32 right=conect_buffer2.AllMarkPoint[m].right;
            l32_templine.st.x=left;
            MyGetLine32Ypos(l32_line,left,&l32_templine.st.y);
            l32_templine.ed.x=right;
            MyGetLine32Ypos(l32_line,right,&l32_templine.ed.y);
            l32_templine.st.x=(l32_templine.st.x<<2);
            l32_templine.st.y=(l32_templine.st.y<<2);
            l32_templine.ed.x=(l32_templine.ed.x<<2);
            l32_templine.ed.y=(l32_templine.ed.y<<2);
            switch(Mod)
            {
                case MHC_LINE_SQARE:
                case MHC_VAR_SQARE:
                case MHC_HEADTAIL_SQARE:
                case MHC_MIXDIS_SQARE:
                    Mynormalize_rowXY_line32_INVlinePoint(matInBig,dataXIn,dataYIn,&datacount,l32_templine,lineInsize,value,bry_value,bry_mod,matInSmall,size_value);
                break;
                case MHC_HOUGH_SQARE:
                    Mynormalize_rowXY_line32_HOVlinePoint(matInBig,pEdgeMapList,&pEdgeMapListNum,l32_templine,lineInsize,value,bry_value,bry_mod,matInSmall,size_value);
                break;
                default:
                    return 1;
                break;
            }
        }
        switch(Mod)
        {
            case MHC_LINE_SQARE:
            case MHC_VAR_SQARE:
            case MHC_HEADTAIL_SQARE:
            case MHC_MIXDIS_SQARE:
                if(0!=MyData_sqare_line(dataXIn,dataYIn,datacount,matInBig.nWidth,matInBig.nHeight,Mod,lineOut,houghinfoOut))
                    return 1;
            break;
            case MHC_HOUGH_SQARE:
                if(pEdgeMapListNum==0)
                    return 1;
                Hough=HoughCreat(u8_buffer_x1Temp1);
                MyPoint_to_Hough(pEdgeMapList,nnWidth,nnHeight,pEdgeMapListNum,&Hough);
                if(0!=MyHough_to_maxline(Hough,nnWidth,nnHeight,&linetemp))
                    return 1;
                *lineOut=linetemp.line[0];
                *houghinfoOut=linetemp.houghinfo[0];
                break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    Int8 MyGetBigCannyforminCanny_line(Mat matInBig,Mat matInSmall,Mat *matOut,L_line lineIn,Int32 lineInsize,Int32 value)
    {
        Int32 nnHeight_min=matInSmall.nHeight;
        Mat cvline=MatCreatzero(3,nnHeight_min,CCV_8UC1,u8_buffer_x1Temp6);
        Int32 m;
        L_line32 l32_line;
        L_line32 l32_templine;

        getcloneinfo(matInBig,matOut);
        MatSet1col(matOut,0);
        Myconnection(matInSmall,&conect_buffer2,1,0,MHC_8LT,u8_buffer_x1Temp5);
        if(conect_buffer2.AllMarkPointCount==0)
        {
            return 0;
        }
        for(m=0;m<conect_buffer2.AllMarkPointCount;m++)
        {
            Uint32 top=conect_buffer2.AllMarkPoint[m].top;
            Uint32 bottom=conect_buffer2.AllMarkPoint[m].bottom;
            memset(&cvline.data[nnHeight_min+top],255,bottom-top+1);
        }
        Myconnection(cvline,&conect_buffer2,1,0,MHC_8LT,u8_buffer_x1Temp5);
        Myline16to32(lineIn,&l32_line);
        for(m=0;m<conect_buffer2.AllMarkPointCount;m++)
        {
            Int32 top=conect_buffer2.AllMarkPoint[m].left;
            Int32 bottom=conect_buffer2.AllMarkPoint[m].right;
            MyGetLine32Xpos(l32_line,top,&l32_templine.st.x);
            l32_templine.st.y=top;
            MyGetLine32Xpos(l32_line,bottom,&l32_templine.ed.x);
            l32_templine.ed.y=bottom;
            l32_templine.st.x=(l32_templine.st.x<<2);
            l32_templine.st.y=(l32_templine.st.y<<2);
            l32_templine.ed.x=(l32_templine.ed.x<<2);
            l32_templine.ed.y=(l32_templine.ed.y<<2);

            Mynormalize_lineXY_line32(matInBig,matOut,l32_templine,lineInsize,value);
        }

        return 0;
    }

    Int8 Mynormalize_lineXY_line32_INVbry(Mat matIn,Mat *matOut,L_line32 l32_line,Int32 lineInsize,double value,Int32 bry_value,binarysidemod bry_mod,Mat smallIn,Int32 size_value)
    {
        Int32 nnWidth=matIn.nWidth;
        Int32 nnHeight=matIn.nHeight;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        Int32 i;
        Int32 i32_max,i32_min;
        float f_max,f_min;
        double d_max,d_min;
        Int32 i32_dec;
        Int64 i64_dec;
        double d_dec;
        Int32 i32_value=(Int32)(value+0.5);
        float f_value=(float)value;
        Int32 n;
        Int32 oldj=RANDOM_MAX;

        matOut->nWidth=matIn.nWidth;
        matOut->nHeight=matIn.nHeight;
        matOut->startx=matIn.startx;
        matOut->starty=matIn.starty;
        matOut->width=matIn.width;
        matOut->height=matIn.height;
        MyconvertTo(matOut,CCV_8UC1);

        MyLinetoPoint(nnHeight,nnWidth,l32_line.st,l32_line.ed,CV_LINE_8LT,1,&conect_buffer3,u8_buffer_x1Temp3);
        for(n=0;n<conect_buffer3.AllMarkPoint[0].PointArea;n++)
        {
            Int32 sti=conect_buffer3.AllMarkPoint[0].point[n].x-lineInsize/2;
            Int32 j=conect_buffer3.AllMarkPoint[0].point[n].y;
            Int32 endi=sti+lineInsize;
            if(oldj!=j)
                oldj=j;
            else
                continue;
            if(j<nStartY||j>=nStartY+nHeight)
                continue;
            if(sti<nStartX)
            {
                sti=nStartX;
            }
            if(sti>nStartX+nWidth-1)
            {
                sti=nStartX+nWidth-1;
            }
            if(endi<nStartX)
            {
                endi=nStartX;
            }
            if(endi>nStartX+nWidth-1)
            {
                endi=nStartX+nWidth-1;
            }
            switch(matIn._type)
            {
                case CCV_8UC1:
                    i32_min=matIn.ptr_uchar[j*nnWidth+sti];
                    i32_max=matIn.ptr_uchar[j*nnWidth+sti];
                    for(i=sti;i<=endi;i++)
                    {
                        Int32 val=matIn.ptr_uchar[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        Int32 count=0;
                        i32_dec=(255<<8)/(i32_max-i32_min);
                        for(i=sti;i<=endi;i++)
                        {
                            Int32 val=(((matIn.ptr_uchar[j*nnWidth+i]-i32_min)*i32_dec)>>8);
                            switch(bry_mod)
                            {
                                case MHC_BARINYSIDE_VALUE_INV:
                                    if(val>bry_value)
                                        matOut->data[j*nnWidth+i]=0;
                                    else
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            matOut->data[j*nnWidth+i]=255;
                                            count++;
                                        }
                                        else
                                        {
                                            matOut->data[j*nnWidth+i]=0;
                                        }
                                    }
                                break;
                                case MHC_BARINYSIDE_VALUE:
                                    if(val<bry_value)
                                        matOut->data[j*nnWidth+i]=0;
                                    else
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            matOut->data[j*nnWidth+i]=255;
                                            count++;
                                        }
                                        else
                                        {
                                            matOut->data[j*nnWidth+i]=0;
                                        }
                                    }
                                break;
                                default:
                                    return 1;
                                break;
                            }
                        }
                        if(count>size_value)
                        {
                            memset(&matOut->data[j*nnWidth+sti],0,endi-sti+1);
                        }
                    }
                break;
                case CCV_8SC1:
                    i32_min=matIn.ptr_char[j*nnWidth+sti];
                    i32_max=matIn.ptr_char[j*nnWidth+sti];
                    for(i=sti;i<=endi;i++)
                    {
                        Int32 val=matIn.ptr_char[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        Int32 count=0;
                        i32_dec=(255<<8)/(i32_max-i32_min);
                        for(i=sti;i<=endi;i++)
                        {
                            Int32 val=(((matIn.ptr_char[j*nnWidth+i]-i32_min)*i32_dec)>>8);
                            switch(bry_mod)
                            {
                                case MHC_BARINYSIDE_VALUE_INV:
                                    if(val>bry_value)
                                        matOut->data[j*nnWidth+i]=0;
                                    else
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            matOut->data[j*nnWidth+i]=255;
                                            count++;
                                        }
                                        else
                                        {
                                            matOut->data[j*nnWidth+i]=0;
                                        }
                                    }
                                break;
                                case MHC_BARINYSIDE_VALUE:
                                    if(val<bry_value)
                                        matOut->data[j*nnWidth+i]=0;
                                    else
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            matOut->data[j*nnWidth+i]=255;
                                            count++;
                                        }
                                        else
                                        {
                                            matOut->data[j*nnWidth+i]=0;
                                        }
                                    }
                                break;
                                default:
                                    return 1;
                                break;
                            }
                        }
                        if(count>size_value)
                        {
                            memset(&matOut->data[j*nnWidth+sti],0,endi-sti+1);
                        }
                    }
                break;
                case CCV_16UC1:
                    i32_min=matIn.ptr_ushort[j*nnWidth+sti];
                    i32_max=matIn.ptr_ushort[j*nnWidth+sti];
                    for(i=sti;i<=endi;i++)
                    {
                        Int32 val=matIn.ptr_ushort[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        Int32 count=0;
                        i32_dec=(255<<8)/(i32_max-i32_min);
                        for(i=sti;i<=endi;i++)
                        {
                            Int32 val=(((matIn.ptr_ushort[j*nnWidth+i]-i32_min)*i32_dec)>>16);
                            switch(bry_mod)
                            {
                                case MHC_BARINYSIDE_VALUE_INV:
                                    if(val>bry_value)
                                        matOut->data[j*nnWidth+i]=0;
                                    else
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            matOut->data[j*nnWidth+i]=255;
                                            count++;
                                        }
                                        else
                                        {
                                            matOut->data[j*nnWidth+i]=0;
                                        }
                                    }
                                break;
                                case MHC_BARINYSIDE_VALUE:
                                    if(val<bry_value)
                                        matOut->data[j*nnWidth+i]=0;
                                    else
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            matOut->data[j*nnWidth+i]=255;
                                            count++;
                                        }
                                        else
                                        {
                                            matOut->data[j*nnWidth+i]=0;
                                        }
                                    }
                                break;
                                default:
                                    return 1;
                                break;
                            }
                        }
                        if(count>size_value)
                        {
                            memset(&matOut->data[j*nnWidth+sti],0,endi-sti+1);
                        }
                    }
                break;
                case CCV_16SC1:
                    i32_min=matIn.ptr_short[j*nnWidth+sti];
                    i32_max=matIn.ptr_short[j*nnWidth+sti];
                    for(i=sti;i<=endi;i++)
                    {
                        Int32 val=matIn.ptr_short[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        Int32 count=0;
                        i32_dec=(255<<8)/(i32_max-i32_min);
                        for(i=sti;i<=endi;i++)
                        {
                            Int32 val=(((matIn.ptr_short[j*nnWidth+i]-i32_min)*i32_dec)>>16);
                            switch(bry_mod)
                            {
                                case MHC_BARINYSIDE_VALUE_INV:
                                    if(val>bry_value)
                                        matOut->data[j*nnWidth+i]=0;
                                    else
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            matOut->data[j*nnWidth+i]=255;
                                            count++;
                                        }
                                        else
                                        {
                                            matOut->data[j*nnWidth+i]=0;
                                        }
                                    }
                                break;
                                case MHC_BARINYSIDE_VALUE:
                                    if(val<bry_value)
                                        matOut->data[j*nnWidth+i]=0;
                                    else
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            matOut->data[j*nnWidth+i]=255;
                                            count++;
                                        }
                                        else
                                        {
                                            matOut->data[j*nnWidth+i]=0;
                                        }
                                    }
                                break;
                                default:
                                    return 1;
                                break;
                            }
                        }
                        if(count>size_value)
                        {
                            memset(&matOut->data[j*nnWidth+sti],0,endi-sti+1);
                        }
                    }
                break;
                case CCV_32SC1:
                    i32_min=matIn.ptr_int[j*nnWidth+sti];
                    i32_max=matIn.ptr_int[j*nnWidth+sti];
                    for(i=sti;i<=endi;i++)
                    {
                        Int32 val=matIn.ptr_int[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        Int32 count=0;
                        i64_dec=(((Uint64)255)<<32)/(i32_max-i32_min);
                        for(i=sti;i<=endi;i++)
                        {
                            Int32 val=(((matIn.ptr_int[j*nnWidth+i]-i32_min)*i64_dec)>>32);
                            switch(bry_mod)
                            {
                                case MHC_BARINYSIDE_VALUE_INV:
                                    if(val>bry_value)
                                        matOut->data[j*nnWidth+i]=0;
                                    else
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            matOut->data[j*nnWidth+i]=255;
                                            count++;
                                        }
                                        else
                                        {
                                            matOut->data[j*nnWidth+i]=0;
                                        }
                                    }
                                break;
                                case MHC_BARINYSIDE_VALUE:
                                    if(val<bry_value)
                                        matOut->data[j*nnWidth+i]=0;
                                    else
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            matOut->data[j*nnWidth+i]=255;
                                            count++;
                                        }
                                        else
                                        {
                                            matOut->data[j*nnWidth+i]=0;
                                        }
                                    }
                                break;
                                default:
                                    return 1;
                                break;
                            }
                        }
                        if(count>size_value)
                        {
                            memset(&matOut->data[j*nnWidth+sti],0,endi-sti+1);
                        }
                    }
                break;
                case CCV_32FC1:
                    f_min=matIn.ptr_float[j*nnWidth+sti];
                    f_max=matIn.ptr_float[j*nnWidth+sti];
                    for(i=sti;i<=endi;j++)
                    {
                        float val=matIn.ptr_float[j*nnWidth+i];
                        if(f_min>val)
                        {
                            f_min=val;
                        }
                        if(f_max<val)
                        {
                            f_max=val;
                        }
                    }
                    if(f_max-f_min>=f_value)
                    {
                        Int32 count=0;
                        d_dec=255.0/(double)(f_max-f_min);
                        for(i=sti;i<=endi;i++)
                        {
                            Int32 val=(matIn.ptr_float[j*nnWidth+i]-f_min)*d_dec+0.5;
                            switch(bry_mod)
                            {
                                case MHC_BARINYSIDE_VALUE_INV:
                                    if(val>bry_value)
                                        matOut->data[j*nnWidth+i]=0;
                                    else
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            matOut->data[j*nnWidth+i]=255;
                                            count++;
                                        }
                                        else
                                        {
                                            matOut->data[j*nnWidth+i]=0;
                                        }
                                    }
                                break;
                                case MHC_BARINYSIDE_VALUE:
                                    if(val<bry_value)
                                        matOut->data[j*nnWidth+i]=0;
                                    else
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            matOut->data[j*nnWidth+i]=255;
                                            count++;
                                        }
                                        else
                                        {
                                            matOut->data[j*nnWidth+i]=0;
                                        }
                                    }
                                break;
                                default:
                                    return 1;
                                break;
                            }
                        }
                        if(count>size_value)
                        {
                            memset(&matOut->data[j*nnWidth+sti],0,endi-sti+1);
                        }
                    }
                break;
                case CCV_64FC1:
                    d_min=matIn.ptr_double[j*nnWidth+sti];
                    d_max=matIn.ptr_double[j*nnWidth+sti];
                    for(i=sti;i<=endi;i++)
                    {
                        double val=matIn.ptr_double[j*nnWidth+i];
                        if(d_min>val)
                        {
                            d_min=val;
                        }
                        if(d_max<val)
                        {
                            d_max=val;
                        }
                    }
                    if(d_max-d_min>=value)
                    {
                        Int32 count=0;
                        d_dec=255.0/(double)(d_max-d_min);
                        for(i=sti;i<=endi;i++)
                        {
                            Int32 val=(matIn.ptr_double[j*nnWidth+i]-d_min)*d_dec+0.5;
                            switch(bry_mod)
                            {
                                case MHC_BARINYSIDE_VALUE_INV:
                                    if(val>bry_value)
                                        matOut->data[j*nnWidth+i]=0;
                                    else
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            matOut->data[j*nnWidth+i]=255;
                                            count++;
                                        }
                                        else
                                        {
                                            matOut->data[j*nnWidth+i]=0;
                                        }
                                    }
                                break;
                                case MHC_BARINYSIDE_VALUE:
                                    if(val<bry_value)
                                        matOut->data[j*nnWidth+i]=0;
                                    else
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            matOut->data[j*nnWidth+i]=255;
                                            count++;
                                        }
                                        else
                                        {
                                            matOut->data[j*nnWidth+i]=0;
                                        }
                                    }
                                break;
                                default:
                                    return 1;
                                break;
                            }
                        }
                        if(count>size_value)
                        {
                            memset(&matOut->data[j*nnWidth+sti],0,endi-sti+1);
                        }
                    }
                break;
                default:
                    return 2;
                break;
            }
        }

        return 0;
    }

    Int8 MyGetBigCannyforminCanny_line_bry(Mat matInBig,Mat matInSmall,Mat *matOut,L_line lineIn,Int32 lineInsize,Int32 value,Int32 bry_value,binarysidemod bry_mod,Int32 size_value,Int32 *leftOut,Int32 *rightOut,Int32 *topOut,Int32 *bottomOut)
    {
        Int32 nnHeight_min=matInSmall.nHeight;
        Mat cvline=MatCreatzero(3,nnHeight_min,CCV_8UC1,u8_buffer_x1Temp6);
        Int32 m;
        L_line32 l32_line;
        L_line32 l32_templine;
        Int32 templeft1,templeft2,templeft;
        Int32 tempright;

        getcloneinfo(matInBig,matOut);
        MatSet1col(matOut,0);
        Myconnection(matInSmall,&conect_buffer2,1,0,MHC_8LT,u8_buffer_x1Temp5);
        if(conect_buffer2.AllMarkPointCount==0)
        {
            *leftOut=0;
            *rightOut=0;
            *topOut=0;
            *bottomOut=0;
            return 0;
        }
        for(m=0;m<conect_buffer2.AllMarkPointCount;m++)
        {
            Uint32 top=conect_buffer2.AllMarkPoint[m].top;
            Uint32 bottom=conect_buffer2.AllMarkPoint[m].bottom;
            memset(&cvline.data[nnHeight_min+top],255,bottom-top+1);
        }
        Myconnection(cvline,&conect_buffer2,1,0,MHC_8LT,u8_buffer_x1Temp5);
        Myline16to32(lineIn,&l32_line);
        for(m=0;m<conect_buffer2.AllMarkPointCount;m++)
        {
            Int32 top=conect_buffer2.AllMarkPoint[m].left;
            Int32 bottom=conect_buffer2.AllMarkPoint[m].right;
            MyGetLine32Xpos(l32_line,top,&l32_templine.st.x);
            l32_templine.st.y=top;
            MyGetLine32Xpos(l32_line,bottom,&l32_templine.ed.x);
            l32_templine.ed.y=bottom;
            l32_templine.st.x=(l32_templine.st.x<<2);
            l32_templine.st.y=(l32_templine.st.y<<2);
            l32_templine.ed.x=(l32_templine.ed.x<<2);
            l32_templine.ed.y=(l32_templine.ed.y<<2);

            Mynormalize_lineXY_line32_INVbry(matInBig,matOut,l32_templine,lineInsize,value,bry_value,bry_mod,matInSmall,size_value);
        }
        *topOut=(conect_buffer2.AllMarkPoint[0].left<<2);
        *bottomOut=(conect_buffer2.AllMarkPoint[conect_buffer2.AllMarkPointCount-1].right<<2);


        MyGetLine32Ypos(l32_line,conect_buffer2.AllMarkPoint[0].left,&templeft1);
        MyGetLine32Ypos(l32_line,conect_buffer2.AllMarkPoint[conect_buffer2.AllMarkPointCount-1].right,&templeft2);
        templeft=MIN(templeft1,templeft2);
        templeft=(templeft<<2)-(lineInsize>>2);
        if(templeft<(Int32)matInBig.startx)
        {
            templeft=matInBig.startx;
        }
        tempright=MAX(templeft1,templeft2);
        tempright=(tempright<<2)-(lineInsize>>2)+lineInsize;
        if(tempright>matInBig.startx+matInBig.width-1)
        {
            tempright=matInBig.startx+matInBig.width-1;
        }
        *leftOut=templeft;
        *rightOut=tempright;

        return 0;
    }

    Int8 Mynormalize_lineXY_line32_INVlinePoint(Mat matIn,Int32 *Xpoint,Int32 *Ypoint,Int32 *Totalcount,L_line32 l32_line,Int32 lineInsize,double value,Int32 bry_value,binarysidemod bry_mod,Mat smallIn,Int32 size_value)
    {
        Int32 nnWidth=matIn.nWidth;
        Int32 nnHeight=matIn.nHeight;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        Int32 i;
        Int32 i32_max,i32_min;
        float f_max,f_min;
        double d_max,d_min;
        Int32 i32_dec;
        Int64 i64_dec;
        double d_dec;
        Int32 i32_value=(Int32)(value+0.5);
        float f_value=(float)value;
        Int32 n;
        Int32 oldj=RANDOM_MAX;
        Int32 *idata=(Int32*)u8_buffer_x1Temp1;

        MyLinetoPoint(nnHeight,nnWidth,l32_line.st,l32_line.ed,CV_LINE_8LT,1,&conect_buffer3,u8_buffer_x1Temp3);
        for(n=0;n<conect_buffer3.AllMarkPoint[0].PointArea;n++)
        {
            Int32 sti=conect_buffer3.AllMarkPoint[0].point[n].x-lineInsize/2;
            Int32 j=conect_buffer3.AllMarkPoint[0].point[n].y;
            Int32 endi=sti+lineInsize;
            if(oldj!=j)
                oldj=j;
            else
                continue;
            if(j<nStartY||j>=nStartY+nHeight)
                continue;
            if(sti<nStartX)
            {
                sti=nStartX;
            }
            if(sti>nStartX+nWidth-1)
            {
                sti=nStartX+nWidth-1;
            }
            if(endi<nStartX)
            {
                endi=nStartX;
            }
            if(endi>nStartX+nWidth-1)
            {
                endi=nStartX+nWidth-1;
            }
            switch(matIn._type)
            {
                case CCV_8UC1:
                    i32_min=matIn.ptr_uchar[j*nnWidth+sti];
                    i32_max=matIn.ptr_uchar[j*nnWidth+sti];
                    for(i=sti;i<=endi;i++)
                    {
                        Int32 val=matIn.ptr_uchar[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        Int32 count=0;
                        i32_dec=(255<<8)/(i32_max-i32_min);
                        for(i=sti;i<=endi;i++)
                        {
                            Int32 val=(((matIn.ptr_uchar[j*nnWidth+i]-i32_min)*i32_dec)>>8);
                            switch(bry_mod)
                            {
                                case MHC_BARINYSIDE_VALUE_INV:
                                    if(val<=bry_value)
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            idata[count++]=i;
                                        }
                                    }
                                break;
                                case MHC_BARINYSIDE_VALUE:
                                    if(val>=bry_value)
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            idata[count++]=i;
                                        }
                                    }
                                break;
                                default:
                                    return 1;
                                break;
                            }
                        }
                        if(count<=size_value)
                        {
                            Int32 n;
                            for(n=0;n<count;n++)
                            {
                                Xpoint[*Totalcount]=idata[n];
                                Ypoint[*Totalcount]=j;
                                (*Totalcount)++;
                            }
                        }
                    }
                break;
                case CCV_8SC1:
                    i32_min=matIn.ptr_char[j*nnWidth+sti];
                    i32_max=matIn.ptr_char[j*nnWidth+sti];
                    for(i=sti;i<=endi;i++)
                    {
                        Int32 val=matIn.ptr_char[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        Int32 count=0;
                        i32_dec=(255<<8)/(i32_max-i32_min);
                        for(i=sti;i<=endi;i++)
                        {
                            Int32 val=(((matIn.ptr_char[j*nnWidth+i]-i32_min)*i32_dec)>>8);
                            switch(bry_mod)
                            {
                                case MHC_BARINYSIDE_VALUE_INV:
                                    if(val<=bry_value)
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            idata[count++]=i;
                                        }
                                    }
                                break;
                                case MHC_BARINYSIDE_VALUE:
                                    if(val>=bry_value)
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            idata[count++]=i;
                                        }
                                    }
                                break;
                                default:
                                    return 1;
                                break;
                            }
                        }
                        if(count<=size_value)
                        {
                            Int32 n;
                            for(n=0;n<count;n++)
                            {
                                Xpoint[*Totalcount]=idata[n];
                                Ypoint[*Totalcount]=j;
                                (*Totalcount)++;
                            }
                        }
                    }
                break;
                case CCV_16UC1:
                    i32_min=matIn.ptr_ushort[j*nnWidth+sti];
                    i32_max=matIn.ptr_ushort[j*nnWidth+sti];
                    for(i=sti;i<=endi;i++)
                    {
                        Int32 val=matIn.ptr_ushort[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        Int32 count=0;
                        i32_dec=(255<<8)/(i32_max-i32_min);
                        for(i=sti;i<=endi;i++)
                        {
                            Int32 val=(((matIn.ptr_ushort[j*nnWidth+i]-i32_min)*i32_dec)>>8);
                            switch(bry_mod)
                            {
                                case MHC_BARINYSIDE_VALUE_INV:
                                    if(val<=bry_value)
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            idata[count++]=i;
                                        }
                                    }
                                break;
                                case MHC_BARINYSIDE_VALUE:
                                    if(val>=bry_value)
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            idata[count++]=i;
                                        }
                                    }
                                break;
                                default:
                                    return 1;
                                break;
                            }
                        }
                        if(count<=size_value)
                        {
                            Int32 n;
                            for(n=0;n<count;n++)
                            {
                                Xpoint[*Totalcount]=idata[n];
                                Ypoint[*Totalcount]=j;
                                (*Totalcount)++;
                            }
                        }
                    }
                break;
                case CCV_16SC1:
                    i32_min=matIn.ptr_short[j*nnWidth+sti];
                    i32_max=matIn.ptr_short[j*nnWidth+sti];
                    for(i=sti;i<=endi;i++)
                    {
                        Int32 val=matIn.ptr_short[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        Int32 count=0;
                        i32_dec=(255<<8)/(i32_max-i32_min);
                        for(i=sti;i<=endi;i++)
                        {
                            Int32 val=(((matIn.ptr_short[j*nnWidth+i]-i32_min)*i32_dec)>>8);
                            switch(bry_mod)
                            {
                                case MHC_BARINYSIDE_VALUE_INV:
                                    if(val<=bry_value)
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            idata[count++]=i;
                                        }
                                    }
                                break;
                                case MHC_BARINYSIDE_VALUE:
                                    if(val>=bry_value)
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            idata[count++]=i;
                                        }
                                    }
                                break;
                                default:
                                    return 1;
                                break;
                            }
                        }
                        if(count<=size_value)
                        {
                            Int32 n;
                            for(n=0;n<count;n++)
                            {
                                Xpoint[*Totalcount]=idata[n];
                                Ypoint[*Totalcount]=j;
                                (*Totalcount)++;
                            }
                        }
                    }
                break;
                case CCV_32SC1:
                    i32_min=matIn.ptr_int[j*nnWidth+sti];
                    i32_max=matIn.ptr_int[j*nnWidth+sti];
                    for(i=sti;i<=endi;i++)
                    {
                        Int32 val=matIn.ptr_int[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        Int32 count=0;
                        i64_dec=(((Uint64)255)<<32)/(i32_max-i32_min);
                        for(i=sti;i<=endi;i++)
                        {
                            Int32 val=(((matIn.ptr_int[j*nnWidth+i]-i32_min)*i64_dec)>>8);
                            switch(bry_mod)
                            {
                                case MHC_BARINYSIDE_VALUE_INV:
                                    if(val<=bry_value)
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            idata[count++]=i;
                                        }
                                    }
                                break;
                                case MHC_BARINYSIDE_VALUE:
                                    if(val>=bry_value)
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            idata[count++]=i;
                                        }
                                    }
                                break;
                                default:
                                    return 1;
                                break;
                            }
                        }
                        if(count<=size_value)
                        {
                            Int32 n;
                            for(n=0;n<count;n++)
                            {
                                Xpoint[*Totalcount]=idata[n];
                                Ypoint[*Totalcount]=j;
                                (*Totalcount)++;
                            }
                        }
                    }
                break;
                case CCV_32FC1:
                    f_min=matIn.ptr_float[j*nnWidth+sti];
                    f_max=matIn.ptr_float[j*nnWidth+sti];
                    for(i=sti;i<=endi;j++)
                    {
                        float val=matIn.ptr_float[j*nnWidth+i];
                        if(f_min>val)
                        {
                            f_min=val;
                        }
                        if(f_max<val)
                        {
                            f_max=val;
                        }
                    }
                    if(f_max-f_min>=f_value)
                    {
                        Int32 count=0;
                        d_dec=255.0/(double)(f_max-f_min);
                        for(i=sti;i<=endi;i++)
                        {
                            Int32 val=(matIn.ptr_float[j*nnWidth+i]-f_min)*d_dec+0.5;
                            switch(bry_mod)
                            {
                                case MHC_BARINYSIDE_VALUE_INV:
                                    if(val<=bry_value)
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            idata[count++]=i;
                                        }
                                    }
                                break;
                                case MHC_BARINYSIDE_VALUE:
                                    if(val>=bry_value)
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            idata[count++]=i;
                                        }
                                    }
                                break;
                                default:
                                    return 1;
                                break;
                            }
                        }
                        if(count<=size_value)
                        {
                            Int32 n;
                            for(n=0;n<count;n++)
                            {
                                Xpoint[*Totalcount]=idata[n];
                                Ypoint[*Totalcount]=j;
                                (*Totalcount)++;
                            }
                        }
                    }
                break;
                case CCV_64FC1:
                    d_min=matIn.ptr_double[j*nnWidth+sti];
                    d_max=matIn.ptr_double[j*nnWidth+sti];
                    for(i=sti;i<=endi;i++)
                    {
                        double val=matIn.ptr_double[j*nnWidth+i];
                        if(d_min>val)
                        {
                            d_min=val;
                        }
                        if(d_max<val)
                        {
                            d_max=val;
                        }
                    }
                    if(d_max-d_min>=value)
                    {
                        Int32 count=0;
                        d_dec=255.0/(double)(d_max-d_min);
                        for(i=sti;i<=endi;i++)
                        {
                            Int32 val=(matIn.ptr_double[j*nnWidth+i]-d_min)*d_dec+0.5;
                            switch(bry_mod)
                            {
                                case MHC_BARINYSIDE_VALUE_INV:
                                    if(val<=bry_value)
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            idata[count++]=i;
                                        }
                                    }
                                break;
                                case MHC_BARINYSIDE_VALUE:
                                    if(val>=bry_value)
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            idata[count++]=i;
                                        }
                                    }
                                break;
                                default:
                                    return 1;
                                break;
                            }
                        }
                        if(count<=size_value)
                        {
                            Int32 n;
                            for(n=0;n<count;n++)
                            {
                                Xpoint[*Totalcount]=idata[n];
                                Ypoint[*Totalcount]=j;
                                (*Totalcount)++;
                            }
                        }
                    }
                break;
                default:
                    return 2;
                break;
            }
        }

        return 0;
    }

    Int8 Mynormalize_lineXY_line32_HOVlinePoint(Mat matIn,Uint16 *pEdgeMapList,Uint16 *pEdgeMapListNum,L_line32 l32_line,Int32 lineInsize,double value,Int32 bry_value,binarysidemod bry_mod,Mat smallIn,Int32 size_value)
    {
        Int32 nnWidth=matIn.nWidth;
        Int32 nnHeight=matIn.nHeight;
        Int32 nStartX=matIn.startx;
        Int32 nStartY=matIn.starty;
        Int32 nWidth=matIn.width;
        Int32 nHeight=matIn.height;
        Int32 i;
        Int32 i32_max,i32_min;
        float f_max,f_min;
        double d_max,d_min;
        Int32 i32_dec;
        Int64 i64_dec;
        double d_dec;
        Int32 i32_value=(Int32)(value+0.5);
        float f_value=(float)value;
        Int32 n;
        Int32 oldj=RANDOM_MAX;
        Int32 *idata=(Int32*)u8_buffer_x1Temp1;

        MyLinetoPoint(nnHeight,nnWidth,l32_line.st,l32_line.ed,CV_LINE_8LT,1,&conect_buffer3,u8_buffer_x1Temp3);
        for(n=0;n<conect_buffer3.AllMarkPoint[0].PointArea;n++)
        {
            Int32 sti=conect_buffer3.AllMarkPoint[0].point[n].x-lineInsize/2;
            Int32 j=conect_buffer3.AllMarkPoint[0].point[n].y;
            Int32 endi=sti+lineInsize;
            if(oldj!=j)
                oldj=j;
            else
                continue;
            if(j<nStartY||j>=nStartY+nHeight)
                continue;
            if(sti<nStartX)
            {
                sti=nStartX;
            }
            if(sti>nStartX+nWidth-1)
            {
                sti=nStartX+nWidth-1;
            }
            if(endi<nStartX)
            {
                endi=nStartX;
            }
            if(endi>nStartX+nWidth-1)
            {
                endi=nStartX+nWidth-1;
            }
            switch(matIn._type)
            {
                case CCV_8UC1:
                    i32_min=matIn.ptr_uchar[j*nnWidth+sti];
                    i32_max=matIn.ptr_uchar[j*nnWidth+sti];
                    for(i=sti;i<=endi;i++)
                    {
                        Int32 val=matIn.ptr_uchar[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        Int32 count=0;
                        i32_dec=(255<<8)/(i32_max-i32_min);
                        for(i=sti;i<=endi;i++)
                        {
                            Int32 val=(((matIn.ptr_uchar[j*nnWidth+i]-i32_min)*i32_dec)>>8);
                            switch(bry_mod)
                            {
                                case MHC_BARINYSIDE_VALUE_INV:
                                    if(val<=bry_value)
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            idata[count++]=i;
                                        }
                                    }
                                break;
                                case MHC_BARINYSIDE_VALUE:
                                    if(val>=bry_value)
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            idata[count++]=i;
                                        }
                                    }
                                break;
                                default:
                                    return 1;
                                break;
                            }
                        }
                        if(count<=size_value)
                        {
                            Int32 n;
                            for(n=0;n<count;n++)
                            {
                                pEdgeMapList[(*pEdgeMapListNum)*2]=idata[n];
                                pEdgeMapList[(*pEdgeMapListNum)*2+1]=j;
                                (*pEdgeMapListNum)++;
                            }
                        }
                    }
                break;
                case CCV_8SC1:
                    i32_min=matIn.ptr_char[j*nnWidth+sti];
                    i32_max=matIn.ptr_char[j*nnWidth+sti];
                    for(i=sti;i<=endi;i++)
                    {
                        Int32 val=matIn.ptr_char[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        Int32 count=0;
                        i32_dec=(255<<8)/(i32_max-i32_min);
                        for(i=sti;i<=endi;i++)
                        {
                            Int32 val=(((matIn.ptr_char[j*nnWidth+i]-i32_min)*i32_dec)>>8);
                            switch(bry_mod)
                            {
                                case MHC_BARINYSIDE_VALUE_INV:
                                    if(val<=bry_value)
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            idata[count++]=i;
                                        }
                                    }
                                break;
                                case MHC_BARINYSIDE_VALUE:
                                    if(val>=bry_value)
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            idata[count++]=i;
                                        }
                                    }
                                break;
                                default:
                                    return 1;
                                break;
                            }
                        }
                        if(count<=size_value)
                        {
                            Int32 n;
                            for(n=0;n<count;n++)
                            {
                                pEdgeMapList[(*pEdgeMapListNum)*2]=idata[n];
                                pEdgeMapList[(*pEdgeMapListNum)*2+1]=j;
                                (*pEdgeMapListNum)++;
                            }
                        }
                    }
                break;
                case CCV_16UC1:
                    i32_min=matIn.ptr_ushort[j*nnWidth+sti];
                    i32_max=matIn.ptr_ushort[j*nnWidth+sti];
                    for(i=sti;i<=endi;i++)
                    {
                        Int32 val=matIn.ptr_ushort[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        Int32 count=0;
                        i32_dec=(255<<8)/(i32_max-i32_min);
                        for(i=sti;i<=endi;i++)
                        {
                            Int32 val=(((matIn.ptr_ushort[j*nnWidth+i]-i32_min)*i32_dec)>>8);
                            switch(bry_mod)
                            {
                                case MHC_BARINYSIDE_VALUE_INV:
                                    if(val<=bry_value)
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            idata[count++]=i;
                                        }
                                    }
                                break;
                                case MHC_BARINYSIDE_VALUE:
                                    if(val>=bry_value)
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            idata[count++]=i;
                                        }
                                    }
                                break;
                                default:
                                    return 1;
                                break;
                            }
                        }
                        if(count<=size_value)
                        {
                            Int32 n;
                            for(n=0;n<count;n++)
                            {
                                pEdgeMapList[(*pEdgeMapListNum)*2]=idata[n];
                                pEdgeMapList[(*pEdgeMapListNum)*2+1]=j;
                                (*pEdgeMapListNum)++;
                            }
                        }
                    }
                break;
                case CCV_16SC1:
                    i32_min=matIn.ptr_short[j*nnWidth+sti];
                    i32_max=matIn.ptr_short[j*nnWidth+sti];
                    for(i=sti;i<=endi;i++)
                    {
                        Int32 val=matIn.ptr_short[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        Int32 count=0;
                        i32_dec=(255<<8)/(i32_max-i32_min);
                        for(i=sti;i<=endi;i++)
                        {
                            Int32 val=(((matIn.ptr_short[j*nnWidth+i]-i32_min)*i32_dec)>>8);
                            switch(bry_mod)
                            {
                                case MHC_BARINYSIDE_VALUE_INV:
                                    if(val<=bry_value)
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            idata[count++]=i;
                                        }
                                    }
                                break;
                                case MHC_BARINYSIDE_VALUE:
                                    if(val>=bry_value)
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            idata[count++]=i;
                                        }
                                    }
                                break;
                                default:
                                    return 1;
                                break;
                            }
                        }
                        if(count<=size_value)
                        {
                            Int32 n;
                            for(n=0;n<count;n++)
                            {
                                pEdgeMapList[(*pEdgeMapListNum)*2]=idata[n];
                                pEdgeMapList[(*pEdgeMapListNum)*2+1]=j;
                                (*pEdgeMapListNum)++;
                            }
                        }
                    }
                break;
                case CCV_32SC1:
                    i32_min=matIn.ptr_int[j*nnWidth+sti];
                    i32_max=matIn.ptr_int[j*nnWidth+sti];
                    for(i=sti;i<=endi;i++)
                    {
                        Int32 val=matIn.ptr_int[j*nnWidth+i];
                        if(i32_min>val)
                        {
                            i32_min=val;
                        }
                        if(i32_max<val)
                        {
                            i32_max=val;
                        }
                    }
                    if(i32_max-i32_min>=i32_value)
                    {
                        Int32 count=0;
                        i64_dec=(((Uint64)255)<<32)/(i32_max-i32_min);
                        for(i=sti;i<=endi;i++)
                        {
                            Int32 val=(((matIn.ptr_int[j*nnWidth+i]-i32_min)*i64_dec)>>8);
                            switch(bry_mod)
                            {
                                case MHC_BARINYSIDE_VALUE_INV:
                                    if(val<=bry_value)
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            idata[count++]=i;
                                        }
                                    }
                                break;
                                case MHC_BARINYSIDE_VALUE:
                                    if(val>=bry_value)
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            idata[count++]=i;
                                        }
                                    }
                                break;
                                default:
                                    return 1;
                                break;
                            }
                        }
                        if(count<=size_value)
                        {
                            Int32 n;
                            for(n=0;n<count;n++)
                            {
                                pEdgeMapList[(*pEdgeMapListNum)*2]=idata[n];
                                pEdgeMapList[(*pEdgeMapListNum)*2+1]=j;
                                (*pEdgeMapListNum)++;
                            }
                        }
                    }
                break;
                case CCV_32FC1:
                    f_min=matIn.ptr_float[j*nnWidth+sti];
                    f_max=matIn.ptr_float[j*nnWidth+sti];
                    for(i=sti;i<=endi;j++)
                    {
                        float val=matIn.ptr_float[j*nnWidth+i];
                        if(f_min>val)
                        {
                            f_min=val;
                        }
                        if(f_max<val)
                        {
                            f_max=val;
                        }
                    }
                    if(f_max-f_min>=f_value)
                    {
                        Int32 count=0;
                        d_dec=255.0/(double)(f_max-f_min);
                        for(i=sti;i<=endi;i++)
                        {
                            Int32 val=(matIn.ptr_float[j*nnWidth+i]-f_min)*d_dec+0.5;
                            switch(bry_mod)
                            {
                                case MHC_BARINYSIDE_VALUE_INV:
                                    if(val<=bry_value)
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            idata[count++]=i;
                                        }
                                    }
                                break;
                                case MHC_BARINYSIDE_VALUE:
                                    if(val>=bry_value)
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            idata[count++]=i;
                                        }
                                    }
                                break;
                                default:
                                    return 1;
                                break;
                            }
                        }
                        if(count<=size_value)
                        {
                            Int32 n;
                            for(n=0;n<count;n++)
                            {
                                pEdgeMapList[(*pEdgeMapListNum)*2]=idata[n];
                                pEdgeMapList[(*pEdgeMapListNum)*2+1]=j;
                                (*pEdgeMapListNum)++;
                            }
                        }
                    }
                break;
                case CCV_64FC1:
                    d_min=matIn.ptr_double[j*nnWidth+sti];
                    d_max=matIn.ptr_double[j*nnWidth+sti];
                    for(i=sti;i<=endi;i++)
                    {
                        double val=matIn.ptr_double[j*nnWidth+i];
                        if(d_min>val)
                        {
                            d_min=val;
                        }
                        if(d_max<val)
                        {
                            d_max=val;
                        }
                    }
                    if(d_max-d_min>=value)
                    {
                        Int32 count=0;
                        d_dec=255.0/(double)(d_max-d_min);
                        for(i=sti;i<=endi;i++)
                        {
                            Int32 val=(matIn.ptr_double[j*nnWidth+i]-d_min)*d_dec+0.5;
                            switch(bry_mod)
                            {
                                case MHC_BARINYSIDE_VALUE_INV:
                                    if(val<=bry_value)
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            idata[count++]=i;
                                        }
                                    }
                                break;
                                case MHC_BARINYSIDE_VALUE:
                                    if(val>=bry_value)
                                    {
                                        Int32 di=(i>>2)-1;
                                        Int32 dj=(j>>2)-1;
                                        if(dj<0)
                                        {
                                            dj=0;
                                        }
                                        if(di<0)
                                        {
                                            di=0;
                                        }
                                        if(smallIn.ptr_uchar[dj*smallIn.nWidth+di]!=0)
                                        {
                                            idata[count++]=i;
                                        }
                                    }
                                break;
                                default:
                                    return 1;
                                break;
                            }
                        }
                        if(count<=size_value)
                        {
                            Int32 n;
                            for(n=0;n<count;n++)
                            {
                                pEdgeMapList[(*pEdgeMapListNum)*2]=idata[n];
                                pEdgeMapList[(*pEdgeMapListNum)*2+1]=j;
                                (*pEdgeMapListNum)++;
                            }
                        }
                    }
                break;
                default:
                    return 2;
                break;
            }
        }

        return 0;
    }


    Int8 MyGetBigCannyforminCanny_line_outline(Mat matInBig,Mat matInSmall,L_line *lineOut,houghlineinfo *houghinfoOut,sqaretype Mod,L_line lineIn,Int32 lineInsize,Int32 value,Int32 bry_value,binarysidemod bry_mod,Int32 size_value)
    {
        Int32 nnHeight_min=matInSmall.nHeight;
        Mat cvline=MatCreatzero(3,nnHeight_min,CCV_8UC1,u8_buffer_x1Temp6);
        Int32 m;
        L_line32 l32_line;
        L_line32 l32_templine;
        Int32 *dataXIn=(Int32*)u8_buffer_x3Temp1;
        Int32 *dataYIn=(Int32*)u8_buffer_x1Temp4;
        Int32 datacount=0;
        Uint16 *pEdgeMapList=(Uint16*)u8_buffer_x3Temp1;
        Uint16 pEdgeMapListNum=0;
        Mat Hough;
        MyCountLine linetemp;
        Uint16 nnWidth=matInBig.nWidth;
        Uint16 nnHeight=matInBig.nHeight;

        Myconnection(matInSmall,&conect_buffer2,1,0,MHC_8LT,u8_buffer_x1Temp5);
        if(conect_buffer2.AllMarkPointCount==0)
        {
            return 1;
        }
        for(m=0;m<conect_buffer2.AllMarkPointCount;m++)
        {
            Uint32 top=conect_buffer2.AllMarkPoint[m].top;
            Uint32 bottom=conect_buffer2.AllMarkPoint[m].bottom;
            memset(&cvline.data[nnHeight_min+top],255,bottom-top+1);
        }
        Myconnection(cvline,&conect_buffer2,1,0,MHC_8LT,u8_buffer_x1Temp5);
        Myline16to32(lineIn,&l32_line);
        for(m=0;m<conect_buffer2.AllMarkPointCount;m++)
        {
            Int32 top=conect_buffer2.AllMarkPoint[m].left;
            Int32 bottom=conect_buffer2.AllMarkPoint[m].right;
            MyGetLine32Xpos(l32_line,top,&l32_templine.st.x);
            l32_templine.st.y=top;
            MyGetLine32Xpos(l32_line,bottom,&l32_templine.ed.x);
            l32_templine.ed.y=bottom;
            l32_templine.st.x=(l32_templine.st.x<<2);
            l32_templine.st.y=(l32_templine.st.y<<2);
            l32_templine.ed.x=(l32_templine.ed.x<<2);
            l32_templine.ed.y=(l32_templine.ed.y<<2);
            switch(Mod)
            {
                case MHC_LINE_SQARE:
                case MHC_VAR_SQARE:
                case MHC_HEADTAIL_SQARE:
                case MHC_MIXDIS_SQARE:
                    Mynormalize_lineXY_line32_INVlinePoint(matInBig,dataXIn,dataYIn,&datacount,l32_templine,lineInsize,value,bry_value,bry_mod,matInSmall,size_value);
                break;
                case MHC_HOUGH_SQARE:
                    Mynormalize_lineXY_line32_HOVlinePoint(matInBig,pEdgeMapList,&pEdgeMapListNum,l32_templine,lineInsize,value,bry_value,bry_mod,matInSmall,size_value);
                break;
                default:
                    return 1;
                break;
            }
        }
        switch(Mod)
        {
            case MHC_LINE_SQARE:
            case MHC_VAR_SQARE:
            case MHC_HEADTAIL_SQARE:
            case MHC_MIXDIS_SQARE:
                if(0!=MyData_sqare_line(dataXIn,dataYIn,datacount,matInBig.nWidth,matInBig.nHeight,Mod,lineOut,houghinfoOut))
                    return 1;
            break;
            case MHC_HOUGH_SQARE:
                if(pEdgeMapListNum==0)
                    return 1;
                Hough=HoughCreat(u8_buffer_x1Temp1);
                MyPoint_to_Hough(pEdgeMapList,nnWidth,nnHeight,pEdgeMapListNum,&Hough);
                if(0!=MyHough_to_maxline(Hough,nnWidth,nnHeight,&linetemp))
                    return 1;
                *lineOut=linetemp.line[0];
                *houghinfoOut=linetemp.houghinfo[0];
            break;
            default:
                return 1;
            break;
        }
        return 0;
    }

    void createHammingWin()
    {
        for (int i = 0; i < STC_hammingWin.rows; i++)
        {
            for (int j = 0; j < STC_hammingWin.cols; j++)
            {
                STC_hammingWin.at<double>(i, j) = (0.54 - 0.46 * cos( 2 * CV_PI * i / STC_hammingWin.rows ))
                                            * (0.54 - 0.46 * cos( 2 * CV_PI * j / STC_hammingWin.cols ));
            }
        }
    }

    void createHammingWin_adapt(const cv::Mat frame,const cv::Rect box)
    {
        if (0.5*box.width-box.x>0)
        {
            STC_hammingWin_left_dis=0.5*box.width-box.x;
        }else STC_hammingWin_left_dis=0;
        if (1.5*box.width+box.x>frame.cols)
        {
            STC_hammingWin_right_dis=1.5*box.width+box.x-frame.cols;
        }else STC_hammingWin_right_dis=0;
        if (0.5*box.height-box.y>0)
        {
            STC_hammingWin_up_dis=0.5*box.height-box.y;
        }else STC_hammingWin_up_dis=0;
        if (1.5*box.height+box.y>frame.rows)
        {
            STC_hammingWin_down_dis=1.5*box.height+box.y-frame.rows;
        }else STC_hammingWin_down_dis=0;

        STC_hammingWin_adapt= STC_hammingWin(cv::Range(STC_hammingWin_up_dis,STC_hammingWin_up_dis+STC_cxtRegion.height),cv::Range(STC_hammingWin_left_dis,STC_hammingWin_left_dis+STC_cxtRegion.width));  //行  列
    }

    void getCxtPriorPosteriorModel(const cv::Mat image)
    {
        //CV_Assert(image.size == cxtPriorPro.size);

        double sum_prior(0), sum_post(0);
        for (int i = 0; i < STC_cxtRegion.height; i++)
        {
            for (int j = 0; j < STC_cxtRegion.width; j++)
            {
                double x = j + STC_cxtRegion.x;
                double y = i + STC_cxtRegion.y;
                double dist = sqrt((STC_center.x - x) * (STC_center.x - x) + (STC_center.y - y) * (STC_center.y - y));//与中心点的距离

                // equation (5) in the paper   3.1
                STC_cxtPriorPro.at<double>(i, j) = exp(- dist * dist / (2 * STC_sigma * STC_sigma));
                sum_prior += STC_cxtPriorPro.at<double>(i, j);

                // equation (6) in the paper  pow就是求次幂的,写法是 pow(a, b),意思是a的b次方   置信图3.2
                STC_cxtPosteriorPro.at<double>(i, j) = exp(- pow(dist / sqrt(STC_alpha), STC_beta));
                sum_post += STC_cxtPosteriorPro.at<double>(i, j);
            }
        }
        STC_cxtPriorPro.convertTo(STC_cxtPriorPro, -1, 1.0/sum_prior);//这个对比对/偏置参数到底怎么设置的
        STC_cxtPriorPro = STC_cxtPriorPro.mul(image);
        STC_cxtPosteriorPro.convertTo(STC_cxtPosteriorPro, -1, 1.0/sum_post);
        STC_cxtPosteriorPro = STC_cxtPosteriorPro.mul(image);
    }

    void complexOperation(const cv::Mat src1, const cv::Mat src2, cv::Mat &dst, int flag)
    {   //CV_Assert计算括号内表达式  ，如果其值为假（即为 0），那么它先向 stderr 打印一条出错信息，然后通过调用 abort 来终止程序运行。
    //  CV_Assert(src1.size == src2.size);//判断src1和src2尺寸是否相等
    //  CV_Assert(src1.channels() == 2);//判断src1通道数

        cv::Mat A_Real, A_Imag, B_Real, B_Imag, R_Real, R_Imag;
        std::vector<cv::Mat> planes;//MAT类型的数组
        cv::split(src1, planes);//分离src1的通道给planes
        planes[0].copyTo(A_Real);
        planes[1].copyTo(A_Imag);

        cv::split(src2, planes);
        planes[0].copyTo(B_Real);
        planes[1].copyTo(B_Imag);


       /*CV_ - this is just a prefix
         64 -表示双精度
         32-表示单精度
         F - 浮点
         Cx - 通道数,例如RGB就是三通道 */
        dst.create(src1.rows, src1.cols, CV_64FC2);//重新分配矩阵数据
        cv::split(dst, planes);
        R_Real = planes[0];
        R_Imag = planes[1];

        for (int i = 0; i < A_Real.rows; i++)
        {
            for (int j = 0; j < A_Real.cols; j++)
            {
                double a = A_Real.at<double>(i, j);
                double b = A_Imag.at<double>(i, j);
                double c = B_Real.at<double>(i, j);
                double d = B_Imag.at<double>(i, j);

                if (flag)
                {
                    // division: (a+bj) / (c+dj)
                    R_Real.at<double>(i, j) = (a * c + b * d) / (c * c + d * d + 0.000001);//实部与虚部被分开了
                    R_Imag.at<double>(i, j) = (b * c - a * d) / (c * c + d * d + 0.000001);
                }
                else
                {
                    // multiplication: (a+bj) * (c+dj)
                    R_Real.at<double>(i, j) = a * c - b * d;
                    R_Imag.at<double>(i, j) = b * c + a * d;
                }
            }
        }
        /*merge() 函数用于将 2 个有序序列合并为 1 个有序序列，前提是这 2 个有序序列的排序规则相同
        （要么都是升序，要么都是降序）。并且最终借助该函数获得的新有序序列，其排序规则也和这 2 个有序序列相同。*/
        cv::merge(planes, dst);
    }

    void learnSTCModel(const cv::Mat image)
    {
        // step 1: Get context prior and posterior probability 获取上下文先验概率和后验概率
        getCxtPriorPosteriorModel(image);

        // step 2-1: Execute 2D DFT for prior probability  为先验概率执行2D DFT  3..3
        cv::Mat priorFourier;
        cv::Mat planes1[] = {STC_cxtPriorPro, cv::Mat::zeros(STC_cxtPriorPro.size(), CV_64F)};
        cv::merge(planes1, 2, priorFourier);//
        cv::dft(priorFourier, priorFourier);//实现二维离散傅里叶变换

        // step 2-2: Execute 2D DFT for posterior probability
        cv::Mat postFourier;
        cv::Mat planes2[] = {STC_cxtPosteriorPro, cv::Mat::zeros(STC_cxtPosteriorPro.size(), CV_64F)};
        cv::merge(planes2, 2, postFourier);
        cv::dft(postFourier, postFourier);

        // step 3: Calculate the division 计算除法
        cv::Mat conditionalFourier;
        complexOperation(postFourier, priorFourier, conditionalFourier, 1);//？有一段代码没用

        // step 4: Execute 2D inverse DFT for conditional probability and we obtain STModel
        //对条件概率执行2D逆DFT，得到STModel
        cv::dft(conditionalFourier, STC_STModel, cv::DFT_INVERSE | cv::DFT_REAL_OUTPUT | cv::DFT_SCALE);

        // step 5: Use the learned spatial context model to update spatio-temporal context model
        //使用学习的空间上下文模型更新时空上下文模型
        cv::addWeighted(STC_STCModel, 1.0 - STC_rho, STC_STModel, STC_rho, 0.0, STC_STCModel);//图像混合
    }

    Int8 MySTC_init(Mat matIn,L_Point32 point,Int32 left,Int32 right,Int32 top,Int32 deep,double alpha,double beta,double rho,double sigma)
    {
        cv::Rect box;
        cv::Mat gray;
        if(matIn._type!=CCV_8UC1)
        {
            return 1;
        }
        if(point.x<=left||point.x>=right||point.y<=top||point.y>=deep)
        {
            return 1;
        }
        gray=cv::Mat(matIn.nHeight,matIn.nWidth,CV_8UC1);
        memcpy(gray.data,matIn.data,getsizeof(matIn._type)*matIn.nHeight*matIn.nWidth);

        box.x=left;
        box.y=top;
        box.width=right-left+1;
        box.height=deep-top+1;
        STC_alpha=alpha;
        STC_beta=beta;
        STC_rho=rho;
        STC_sigma=sigma * (box.width + box.height);

        STC_center.x = box.x + 0.5 * box.width;
        STC_center.y = box.y + 0.5 * box.height;
        STC_cxtRegion.width = 2 * box.width;
        STC_cxtRegion.height = 2 * box.height;
        STC_cxtRegion.x = STC_center.x - STC_cxtRegion.width * 0.5;
        STC_cxtRegion.y = STC_center.y - STC_cxtRegion.height * 0.5;
        STC_cxtRegion &= cv::Rect(0, 0, gray.cols, gray.rows);

        STC_cxtPriorPro = cv::Mat::zeros(STC_cxtRegion.height, STC_cxtRegion.width, CV_64FC1);//先验
        STC_cxtPosteriorPro = cv::Mat::zeros(STC_cxtRegion.height, STC_cxtRegion.width, CV_64FC1);//后验
        STC_STModel = cv::Mat::zeros(STC_cxtRegion.height, STC_cxtRegion.width, CV_64FC1);//条件
        STC_STCModel = cv::Mat::zeros(STC_cxtRegion.height, STC_cxtRegion.width, CV_64FC1);//上下文
        STC_hammingWin = cv::Mat::zeros(2 * box.height, 2 * box.width, CV_64FC1);
        createHammingWin();

        // normalized by subtracting the average intensity of that region
        //通过减去该区域的平均强度进行归一化
        cv::Scalar average = mean(gray(STC_cxtRegion));// mean计算数组元素的平均值
        cv::Mat context;
        gray(STC_cxtRegion).convertTo(context, CV_64FC1, 1.0, - average[0]);//通过缩放将GpuMat转换为另一种数据类型（非阻塞调用）

        // multiplies a Hamming window to reduce the frequency effect of image boundary
        //乘以Hamming窗口以减少图像边界的频率效应
        createHammingWin_adapt(gray,box);
        context = context.mul(STC_hammingWin_adapt);

        // learn Spatio-Temporal context model from first frame
        //从第一帧学习时空上下文模型
        learnSTCModel(context);
        return 0;
    }

    Int8 MySTC_tracker(Mat matIn,L_Point32 *pointOut,Int32 *left,Int32 *right,Int32 *top,Int32 *deep)
    {
        cv::Mat gray;
        cv::Rect trackBox;
        trackBox.x=*left;
        trackBox.y=*top;
        trackBox.width=*right-*left+1;
        trackBox.height=*deep-*top+1;

        gray=cv::Mat(matIn.nHeight,matIn.nWidth,CV_8UC1);
        memcpy(gray.data,matIn.data,getsizeof(matIn._type)*matIn.nHeight*matIn.nWidth);

        // normalized by subtracting the average intensity of that region
        //通过减去该区域的平均强度进行归一化
        cv::Scalar average = cv::mean(gray(STC_cxtRegion));
        cv::Mat context;
        gray(STC_cxtRegion).convertTo(context, CV_64FC1, 1.0, - average[0]);

        // multiplies a Hamming window to reduce the frequency effect of image boundary
        //乘以Hamming窗口以减少图像边界的频率效应
        createHammingWin_adapt(gray,trackBox);
        context = context.mul(STC_hammingWin_adapt);

        // step 1: Get context prior probability
        //获取上下文先验概率
        getCxtPriorPosteriorModel(context);

        // step 2-1: Execute 2D DFT for prior probability
        //为先验概率执行2D DFT
        cv::Mat priorFourier;
        cv::Mat planes1[] = {STC_cxtPriorPro, cv::Mat::zeros(STC_cxtPriorPro.size(), CV_64F)};
        cv::merge(planes1, 2, priorFourier);
        cv::dft(priorFourier, priorFourier);

        // step 2-2: Execute 2D DFT for conditional probability
        //步骤2-2：对条件概率执行2D DFT
        cv::Mat STCModelFourier;
        cv::Mat planes2[] = {STC_STCModel, cv::Mat::zeros(STC_STCModel.size(), CV_64F)};
        cv::merge(planes2, 2, STCModelFourier);
        cv::dft(STCModelFourier, STCModelFourier);

        // step 3: Calculate the multiplication 计算乘法
        cv::Mat postFourier;
        complexOperation(STCModelFourier, priorFourier, postFourier, 0);

        // step 4: Execute 2D inverse DFT for posterior probability namely confidence map
        //对后验概率即置信图执行2D逆DFT
        cv::Mat confidenceMap;
        cv::dft(postFourier, confidenceMap, cv::DFT_INVERSE | cv::DFT_REAL_OUTPUT| cv::DFT_SCALE);

        // step 5: Find the max position
        //找到最大位置
        cv::Point point;
        cv::minMaxLoc(confidenceMap, 0, 0, 0, &point);//在一个数组中找到全局最小值和全局最大值  4.1

        // step 6-1: update center, trackBox and context region
        //更新中心、trackBox和上下文区域
        STC_center.x = STC_cxtRegion.x + point.x;
        STC_center.y = STC_cxtRegion.y + point.y;
        trackBox.x = STC_center.x - 0.5 * trackBox.width;
        trackBox.y = STC_center.y - 0.5 * trackBox.height;
        trackBox &= cv::Rect(0, 0, gray.cols, gray.rows);

        (*pointOut).x=STC_center.x;
        (*pointOut).y=STC_center.y;

        STC_cxtRegion.width = 2 * trackBox.width;
        STC_cxtRegion.height = 2 * trackBox.height;
        STC_cxtRegion.x = STC_center.x - STC_cxtRegion.width * 0.5;
        STC_cxtRegion.y = STC_center.y - STC_cxtRegion.height * 0.5;
        STC_cxtRegion &= cv::Rect(0, 0, gray.cols, gray.rows);

        STC_cxtPriorPro.create(STC_cxtRegion.height, STC_cxtRegion.width, CV_64FC1);
        STC_cxtPosteriorPro.create(STC_cxtRegion.height, STC_cxtRegion.width, CV_64FC1);
        STC_STModel.create(STC_cxtRegion.height, STC_cxtRegion.width, CV_64FC1);
        STC_STCModel.create(STC_cxtRegion.height, STC_cxtRegion.width, CV_64FC1);

        // step 7: learn Spatio-Temporal context model from this frame for tracking next frame
        //从该帧学习时空上下文模型以跟踪下一帧
        average = cv::mean(gray(STC_cxtRegion));
        gray(STC_cxtRegion).convertTo(context, CV_64FC1, 1.0, - average[0]);

        createHammingWin_adapt(gray,trackBox);
        context = context.mul(STC_hammingWin_adapt);
        learnSTCModel(context);

        *left=trackBox.x;
        *right=trackBox.x+trackBox.width-1;
        *top=trackBox.y;
        *deep=trackBox.y+trackBox.height-1;
        return 0;
    }
}
